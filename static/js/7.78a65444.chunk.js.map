{"version":3,"sources":["../../file-android/dist/es/index-f8786b7d.js"],"names":["commonjsGlobal","globalThis","window","global","self","commonjsRequire","Error","createCommonjsModule","fn","module","exports","getCjsExportFromNamespace","n","options","currentElement","sax","parser","strict","opt","SAXParser","SAXStream","createStream","MAX_BUFFER_LENGTH","Stream","buffers","this","i","l","length","clearBuffers","q","c","bufferCheckPosition","lowercase","lowercasetags","looseCase","tags","closed","closedRoot","sawRoot","tag","error","noscript","state","S","BEGIN","strictEntities","ENTITIES","Object","create","XML_ENTITIES","attribList","xmlns","ns","rootNS","trackPosition","position","line","column","emit","EVENTS","o","F","prototype","keys","a","hasOwnProperty","push","end","_end","write","chunk","_typeof","toString","charAt","BEGIN_WHITESPACE","beginWhiteSpace","TEXT","starti","textNode","substring","isWhitespace","strictFail","TEXT_ENTITY","OPEN_WAKA","startTagPosition","SCRIPT","SCRIPT_ENDING","script","CLOSE_TAG","SGML_DECL","sgmlDecl","isMatch","nameStart","OPEN_TAG","tagName","PROC_INST","procInstName","procInstBody","pad","Array","join","toUpperCase","emitNode","CDATA","cdata","COMMENT","comment","DOCTYPE","doctype","isQuote","SGML_DECL_QUOTED","DOCTYPE_DTD","DOCTYPE_QUOTED","DOCTYPE_DTD_QUOTED","COMMENT_ENDING","COMMENT_ENDED","textopts","CDATA_ENDING","CDATA_ENDING_2","PROC_INST_ENDING","PROC_INST_BODY","name","body","nameBody","newTag","openTag","OPEN_TAG_SLASH","ATTRIB","closeTag","attribName","attribValue","ATTRIB_NAME","ATTRIB_VALUE","attrib","ATTRIB_NAME_SAW_WHITE","attributes","value","ATTRIB_VALUE_QUOTED","ATTRIB_VALUE_UNQUOTED","ATTRIB_VALUE_ENTITY_Q","ATTRIB_VALUE_CLOSED","isAttribEnd","ATTRIB_VALUE_ENTITY_U","CLOSE_TAG_SAW_WHITE","notMatch","returnState","buffer","parseEntity","entity","entityBody","entityStart","maxAllowed","Math","max","maxActual","len","closeText","m","checkBufferLength","resume","close","flush","stream","ex","streamWraps","filter","ev","apply","_parser","writable","readable","me","onend","onerror","er","_decoder","forEach","defineProperty","get","set","h","removeAllListeners","on","enumerable","configurable","constructor","data","Buffer","isBuffer","SD","string_decoder","StringDecoder","handler","indexOf","args","arguments","splice","call","XML_NAMESPACE","XMLNS_NAMESPACE","xml","regex","test","s","STATE","COMMENT_STARTING","key","e","String","fromCharCode","event","nodeType","text","trim","normalize","replace","message","parent","qname","attribute","qualName","split","prefix","local","qn","selfClosing","uri","JSON","stringify","p","nv","isSelfClosing","toLowerCase","t","closeTo","pop","x","num","entityLC","numStr","slice","parseInt","isNaN","fromCodePoint","result","stringFromCharCode","floor","highSurrogate","lowSurrogate","MAX_SIZE","codeUnits","index","codePoint","Number","isFinite","RangeError","arrayHelper","isArray","optionsHelper","copy","item","spaces","alwaysArray","compact","isArray$1","nativeType","nValue","bValue","addField","type","instructionFn","temp","instructionNameFn","elementsKey","element","typeKey","nameKey","instructionHasAttributes","attributesKey","instructionKey","addParent","parentKey","manipulateAttributes","attributesFn","nativeTypeAttributes","attributeValueFn","attributeNameFn","onInstruction","instruction","match","attrsRegExp","exec","ignoreDeclaration","declarationKey","ignoreInstruction","onStartElement","elementNameFn","ignoreAttributes","alwaysChildren","onText","ignoreText","captureSpacesBetweenElements","sanitize","onComment","ignoreComment","onEndElement","parentElement","onCdata","ignoreCdata","onDoctype","ignoreDoctype","onError","note","xml2js","userOptions","validateOptions","onopentag","ontext","oncomment","onclosetag","oncdata","ondoctype","onprocessinginstruction","currentElement$1","currentElementName","isArray$2","writeIndentation","depth","firstLine","writeAttributes","attr","attrName","quote","undefined","noQuotesForNativeAttributes","indentAttributes","writeDeclaration","declaration","writeInstruction","instructionName","instructionValue","writeComment","commentFn","writeCdata","cdataFn","writeDoctype","doctypeFn","writeText","textFn","writeElements","elements","reduce","indent","elementName","withClosingTag","fullTagEmptyElementFn","fullTagEmptyElement","indentText","indentCdata","indentInstruction","hasContent","writeElement","commentKey","doctypeKey","cdataKey","textKey","hasContentCompact","anyContent","writeElementCompact","writeElementsCompact","nodes","js2xml","js","validateOptions$2","lib","xml2json","validateOptions$1","k","v","json2xml","json","parse"],"mappings":";yJAAA,wOAIIA,EAAuC,qBAAfC,WAA6BA,WAA+B,qBAAXC,OAAyBA,OAA2B,qBAAXC,EAAyBA,EAAyB,qBAATC,KAAuBA,KAAO,GAE7L,SAASC,IACR,MAAM,IAAIC,MAAM,0EAGjB,SAASC,EAAqBC,EAAIC,GACjC,OAAiCD,EAA1BC,EAAS,CAAEC,QAAS,IAAiBD,EAAOC,SAAUD,EAAOC,QAGrE,SAASC,EAA2BC,GACnC,OAAOA,GAAKA,EAAC,SAAeA,EAG7B,IAutDIC,EACAC,EAxtDAC,EAAMR,GAAqB,SAAUE,EAAQC,IAE/C,SAAWK,GAETA,EAAIC,OAAS,SAAUC,EAAQC,GAC7B,OAAO,IAAIC,EAAUF,EAAQC,IAG/BH,EAAII,UAAYA,EAChBJ,EAAIK,UAAYA,EAChBL,EAAIM,aAkKJ,SAAsBJ,EAAQC,GAC5B,OAAO,IAAIE,EAAUH,EAAQC,IAzJ/BH,EAAIO,kBAAoB,MACxB,IA2IIC,EA3IAC,EAAU,CAAC,UAAW,WAAY,WAAY,UAAW,UAAW,eAAgB,eAAgB,SAAU,aAAc,cAAe,QAAS,UAGxJ,SAASL,EAAUF,EAAQC,GACzB,KAAMO,gBAAgBN,GACpB,OAAO,IAAIA,EAAUF,EAAQC,GAG/B,IAAIF,EAASS,MA+Ff,SAAsBT,GACpB,IAAK,IAAIU,EAAI,EAAGC,EAAIH,EAAQI,OAAQF,EAAIC,EAAGD,IACzCV,EAAOQ,EAAQE,IAAM,GAhGvBG,CAAab,GACbA,EAAOc,EAAId,EAAOe,EAAI,GACtBf,EAAOgB,oBAAsBjB,EAAIO,kBACjCN,EAAOE,IAAMA,GAAO,GACpBF,EAAOE,IAAIe,UAAYjB,EAAOE,IAAIe,WAAajB,EAAOE,IAAIgB,cAC1DlB,EAAOmB,UAAYnB,EAAOE,IAAIe,UAAY,cAAgB,cAC1DjB,EAAOoB,KAAO,GACdpB,EAAOqB,OAASrB,EAAOsB,WAAatB,EAAOuB,SAAU,EACrDvB,EAAOwB,IAAMxB,EAAOyB,MAAQ,KAC5BzB,EAAOC,SAAWA,EAClBD,EAAO0B,YAAczB,IAAUD,EAAOE,IAAIwB,UAC1C1B,EAAO2B,MAAQC,EAAEC,MACjB7B,EAAO8B,eAAiB9B,EAAOE,IAAI4B,eACnC9B,EAAO+B,SAAW/B,EAAO8B,eAAiBE,OAAOC,OAAOlC,EAAImC,cAAgBF,OAAOC,OAAOlC,EAAIgC,UAC9F/B,EAAOmC,WAAa,GAIhBnC,EAAOE,IAAIkC,QACbpC,EAAOqC,GAAKL,OAAOC,OAAOK,IAI5BtC,EAAOuC,eAAwC,IAAxBvC,EAAOE,IAAIsC,SAE9BxC,EAAOuC,gBACTvC,EAAOwC,SAAWxC,EAAOyC,KAAOzC,EAAO0C,OAAS,GAGlDC,EAAK3C,EAAQ,WArCfD,EAAI6C,OAAS,CAAC,OAAQ,wBAAyB,kBAAmB,UAAW,UAAW,eAAgB,YAAa,UAAW,WAAY,YAAa,QAAS,aAAc,QAAS,MAAO,QAAS,SAAU,gBAAiB,kBAwC/NZ,OAAOC,SACVD,OAAOC,OAAS,SAAUY,GACxB,SAASC,KAIT,OAFAA,EAAEC,UAAYF,EACH,IAAIC,IAKdd,OAAOgB,OACVhB,OAAOgB,KAAO,SAAUH,GACtB,IAAII,EAAI,GAER,IAAK,IAAIvC,KAAKmC,EACRA,EAAEK,eAAexC,IAAIuC,EAAEE,KAAKzC,GAGlC,OAAOuC,IAgEX9C,EAAU4C,UAAY,CACpBK,IAAK,WACHC,EAAK5C,OAEP6C,MAy2BF,SAAeC,GACb,IAAIvD,EAASS,KAEb,GAAIA,KAAKgB,MACP,MAAMhB,KAAKgB,MAGb,GAAIzB,EAAOqB,OACT,OAAOI,EAAMzB,EAAQ,wDAGvB,GAAc,OAAVuD,EACF,OAAOF,EAAKrD,GAGS,WAAnBwD,YAAQD,KACVA,EAAQA,EAAME,YAGhB,IAAI/C,EAAI,EACJK,EAAI,GAER,KACEA,EAAI2C,EAAOH,EAAO7C,KAClBV,EAAOe,EAAIA,EAENA,GAeL,OAXIf,EAAOuC,gBACTvC,EAAOwC,WAEG,OAANzB,GACFf,EAAOyC,OACPzC,EAAO0C,OAAS,GAEhB1C,EAAO0C,UAIH1C,EAAO2B,OACb,KAAKC,EAAEC,MAGL,GAFA7B,EAAO2B,MAAQC,EAAE+B,iBAEP,WAAN5C,EACF,SAGF6C,EAAgB5D,EAAQe,GACxB,SAEF,KAAKa,EAAE+B,iBACLC,EAAgB5D,EAAQe,GACxB,SAEF,KAAKa,EAAEiC,KACL,GAAI7D,EAAOuB,UAAYvB,EAAOsB,WAAY,CAGxC,IAFA,IAAIwC,EAASpD,EAAI,EAEVK,GAAW,MAANA,GAAmB,MAANA,IACvBA,EAAI2C,EAAOH,EAAO7C,OAETV,EAAOuC,gBACdvC,EAAOwC,WAEG,OAANzB,GACFf,EAAOyC,OACPzC,EAAO0C,OAAS,GAEhB1C,EAAO0C,UAKb1C,EAAO+D,UAAYR,EAAMS,UAAUF,EAAQpD,EAAI,GAGvC,MAANK,GAAef,EAAOuB,SAAWvB,EAAOsB,aAAetB,EAAOC,QAI3DgE,EAAalD,IAAQf,EAAOuB,UAAWvB,EAAOsB,YACjD4C,EAAWlE,EAAQ,mCAGX,MAANe,EACFf,EAAO2B,MAAQC,EAAEuC,YAEjBnE,EAAO+D,UAAYhD,IAVrBf,EAAO2B,MAAQC,EAAEwC,UACjBpE,EAAOqE,iBAAmBrE,EAAOwC,UAanC,SAEF,KAAKZ,EAAE0C,OAEK,MAANvD,EACFf,EAAO2B,MAAQC,EAAE2C,cAEjBvE,EAAOwE,QAAUzD,EAGnB,SAEF,KAAKa,EAAE2C,cACK,MAANxD,EACFf,EAAO2B,MAAQC,EAAE6C,WAEjBzE,EAAOwE,QAAU,IAAMzD,EACvBf,EAAO2B,MAAQC,EAAE0C,QAGnB,SAEF,KAAK1C,EAAEwC,UAEL,GAAU,MAANrD,EACFf,EAAO2B,MAAQC,EAAE8C,UACjB1E,EAAO2E,SAAW,QACb,GAAIV,EAAalD,SAAW,GAAI6D,EAAQC,EAAW9D,GACxDf,EAAO2B,MAAQC,EAAEkD,SACjB9E,EAAO+E,QAAUhE,OACZ,GAAU,MAANA,EACTf,EAAO2B,MAAQC,EAAE6C,UACjBzE,EAAO+E,QAAU,QACZ,GAAU,MAANhE,EACTf,EAAO2B,MAAQC,EAAEoD,UACjBhF,EAAOiF,aAAejF,EAAOkF,aAAe,OACvC,CAGL,GAFAhB,EAAWlE,EAAQ,eAEfA,EAAOqE,iBAAmB,EAAIrE,EAAOwC,SAAU,CACjD,IAAI2C,EAAMnF,EAAOwC,SAAWxC,EAAOqE,iBACnCtD,EAAI,IAAIqE,MAAMD,GAAKE,KAAK,KAAOtE,EAGjCf,EAAO+D,UAAY,IAAMhD,EACzBf,EAAO2B,MAAQC,EAAEiC,KAGnB,SAEF,KAAKjC,EAAE8C,UAj4BD,aAk4BC1E,EAAO2E,SAAW5D,GAAGuE,eACxBC,EAASvF,EAAQ,eACjBA,EAAO2B,MAAQC,EAAE4D,MACjBxF,EAAO2E,SAAW,GAClB3E,EAAOyF,MAAQ,IACNzF,EAAO2E,SAAW5D,IAAM,MACjCf,EAAO2B,MAAQC,EAAE8D,QACjB1F,EAAO2F,QAAU,GACjB3F,EAAO2E,SAAW,IAz4Bd,aA04BM3E,EAAO2E,SAAW5D,GAAGuE,eAC/BtF,EAAO2B,MAAQC,EAAEgE,SAEb5F,EAAO6F,SAAW7F,EAAOuB,UAC3B2C,EAAWlE,EAAQ,+CAGrBA,EAAO6F,QAAU,GACjB7F,EAAO2E,SAAW,IACH,MAAN5D,GACTwE,EAASvF,EAAQ,oBAAqBA,EAAO2E,UAC7C3E,EAAO2E,SAAW,GAClB3E,EAAO2B,MAAQC,EAAEiC,MACRiC,EAAQ/E,IACjBf,EAAO2B,MAAQC,EAAEmE,iBACjB/F,EAAO2E,UAAY5D,GAEnBf,EAAO2E,UAAY5D,EAGrB,SAEF,KAAKa,EAAEmE,iBACDhF,IAAMf,EAAOc,IACfd,EAAO2B,MAAQC,EAAE8C,UACjB1E,EAAOc,EAAI,IAGbd,EAAO2E,UAAY5D,EACnB,SAEF,KAAKa,EAAEgE,QACK,MAAN7E,GACFf,EAAO2B,MAAQC,EAAEiC,KACjB0B,EAASvF,EAAQ,YAAaA,EAAO6F,SACrC7F,EAAO6F,SAAU,IAEjB7F,EAAO6F,SAAW9E,EAER,MAANA,EACFf,EAAO2B,MAAQC,EAAEoE,YACRF,EAAQ/E,KACjBf,EAAO2B,MAAQC,EAAEqE,eACjBjG,EAAOc,EAAIC,IAIf,SAEF,KAAKa,EAAEqE,eACLjG,EAAO6F,SAAW9E,EAEdA,IAAMf,EAAOc,IACfd,EAAOc,EAAI,GACXd,EAAO2B,MAAQC,EAAEgE,SAGnB,SAEF,KAAKhE,EAAEoE,YACLhG,EAAO6F,SAAW9E,EAER,MAANA,EACFf,EAAO2B,MAAQC,EAAEgE,QACRE,EAAQ/E,KACjBf,EAAO2B,MAAQC,EAAEsE,mBACjBlG,EAAOc,EAAIC,GAGb,SAEF,KAAKa,EAAEsE,mBACLlG,EAAO6F,SAAW9E,EAEdA,IAAMf,EAAOc,IACfd,EAAO2B,MAAQC,EAAEoE,YACjBhG,EAAOc,EAAI,IAGb,SAEF,KAAKc,EAAE8D,QACK,MAAN3E,EACFf,EAAO2B,MAAQC,EAAEuE,eAEjBnG,EAAO2F,SAAW5E,EAGpB,SAEF,KAAKa,EAAEuE,eACK,MAANpF,GACFf,EAAO2B,MAAQC,EAAEwE,cACjBpG,EAAO2F,QAAUU,EAASrG,EAAOE,IAAKF,EAAO2F,SAEzC3F,EAAO2F,SACTJ,EAASvF,EAAQ,YAAaA,EAAO2F,SAGvC3F,EAAO2F,QAAU,KAEjB3F,EAAO2F,SAAW,IAAM5E,EACxBf,EAAO2B,MAAQC,EAAE8D,SAGnB,SAEF,KAAK9D,EAAEwE,cACK,MAANrF,GACFmD,EAAWlE,EAAQ,qBAGnBA,EAAO2F,SAAW,KAAO5E,EACzBf,EAAO2B,MAAQC,EAAE8D,SAEjB1F,EAAO2B,MAAQC,EAAEiC,KAGnB,SAEF,KAAKjC,EAAE4D,MACK,MAANzE,EACFf,EAAO2B,MAAQC,EAAE0E,aAEjBtG,EAAOyF,OAAS1E,EAGlB,SAEF,KAAKa,EAAE0E,aACK,MAANvF,EACFf,EAAO2B,MAAQC,EAAE2E,gBAEjBvG,EAAOyF,OAAS,IAAM1E,EACtBf,EAAO2B,MAAQC,EAAE4D,OAGnB,SAEF,KAAK5D,EAAE2E,eACK,MAANxF,GACEf,EAAOyF,OACTF,EAASvF,EAAQ,UAAWA,EAAOyF,OAGrCF,EAASvF,EAAQ,gBACjBA,EAAOyF,MAAQ,GACfzF,EAAO2B,MAAQC,EAAEiC,MACF,MAAN9C,EACTf,EAAOyF,OAAS,KAEhBzF,EAAOyF,OAAS,KAAO1E,EACvBf,EAAO2B,MAAQC,EAAE4D,OAGnB,SAEF,KAAK5D,EAAEoD,UACK,MAANjE,EACFf,EAAO2B,MAAQC,EAAE4E,iBACRvC,EAAalD,GACtBf,EAAO2B,MAAQC,EAAE6E,eAEjBzG,EAAOiF,cAAgBlE,EAGzB,SAEF,KAAKa,EAAE6E,eACL,IAAKzG,EAAOkF,cAAgBjB,EAAalD,GACvC,SACe,MAANA,EACTf,EAAO2B,MAAQC,EAAE4E,iBAEjBxG,EAAOkF,cAAgBnE,EAGzB,SAEF,KAAKa,EAAE4E,iBACK,MAANzF,GACFwE,EAASvF,EAAQ,0BAA2B,CAC1C0G,KAAM1G,EAAOiF,aACb0B,KAAM3G,EAAOkF,eAEflF,EAAOiF,aAAejF,EAAOkF,aAAe,GAC5ClF,EAAO2B,MAAQC,EAAEiC,OAEjB7D,EAAOkF,cAAgB,IAAMnE,EAC7Bf,EAAO2B,MAAQC,EAAE6E,gBAGnB,SAEF,KAAK7E,EAAEkD,SACDF,EAAQgC,EAAU7F,GACpBf,EAAO+E,SAAWhE,GAElB8F,EAAO7G,GAEG,MAANe,EACF+F,EAAQ9G,GACO,MAANe,EACTf,EAAO2B,MAAQC,EAAEmF,gBAEZ9C,EAAalD,IAChBmD,EAAWlE,EAAQ,iCAGrBA,EAAO2B,MAAQC,EAAEoF,SAIrB,SAEF,KAAKpF,EAAEmF,eACK,MAANhG,GACF+F,EAAQ9G,GAAQ,GAChBiH,EAASjH,KAETkE,EAAWlE,EAAQ,kDACnBA,EAAO2B,MAAQC,EAAEoF,QAGnB,SAEF,KAAKpF,EAAEoF,OAEL,GAAI/C,EAAalD,GACf,SACe,MAANA,EACT+F,EAAQ9G,GACO,MAANe,EACTf,EAAO2B,MAAQC,EAAEmF,eACRnC,EAAQC,EAAW9D,IAC5Bf,EAAOkH,WAAanG,EACpBf,EAAOmH,YAAc,GACrBnH,EAAO2B,MAAQC,EAAEwF,aAEjBlD,EAAWlE,EAAQ,0BAGrB,SAEF,KAAK4B,EAAEwF,YACK,MAANrG,EACFf,EAAO2B,MAAQC,EAAEyF,aACF,MAANtG,GACTmD,EAAWlE,EAAQ,2BACnBA,EAAOmH,YAAcnH,EAAOkH,WAC5BI,EAAOtH,GACP8G,EAAQ9G,IACCiE,EAAalD,GACtBf,EAAO2B,MAAQC,EAAE2F,sBACR3C,EAAQgC,EAAU7F,GAC3Bf,EAAOkH,YAAcnG,EAErBmD,EAAWlE,EAAQ,0BAGrB,SAEF,KAAK4B,EAAE2F,sBACL,GAAU,MAANxG,EACFf,EAAO2B,MAAQC,EAAEyF,iBACZ,IAAIpD,EAAalD,GACtB,SAEAmD,EAAWlE,EAAQ,2BACnBA,EAAOwB,IAAIgG,WAAWxH,EAAOkH,YAAc,GAC3ClH,EAAOmH,YAAc,GACrB5B,EAASvF,EAAQ,cAAe,CAC9B0G,KAAM1G,EAAOkH,WACbO,MAAO,KAETzH,EAAOkH,WAAa,GAEV,MAANnG,EACF+F,EAAQ9G,GACC4E,EAAQC,EAAW9D,IAC5Bf,EAAOkH,WAAanG,EACpBf,EAAO2B,MAAQC,EAAEwF,cAEjBlD,EAAWlE,EAAQ,0BACnBA,EAAO2B,MAAQC,EAAEoF,QAIrB,SAEF,KAAKpF,EAAEyF,aACL,GAAIpD,EAAalD,GACf,SACS+E,EAAQ/E,IACjBf,EAAOc,EAAIC,EACXf,EAAO2B,MAAQC,EAAE8F,sBAEjBxD,EAAWlE,EAAQ,4BACnBA,EAAO2B,MAAQC,EAAE+F,sBACjB3H,EAAOmH,YAAcpG,GAGvB,SAEF,KAAKa,EAAE8F,oBACL,GAAI3G,IAAMf,EAAOc,EAAG,CACR,MAANC,EACFf,EAAO2B,MAAQC,EAAEgG,sBAEjB5H,EAAOmH,aAAepG,EAGxB,SAGFuG,EAAOtH,GACPA,EAAOc,EAAI,GACXd,EAAO2B,MAAQC,EAAEiG,oBACjB,SAEF,KAAKjG,EAAEiG,oBACD5D,EAAalD,GACff,EAAO2B,MAAQC,EAAEoF,OACF,MAANjG,EACT+F,EAAQ9G,GACO,MAANe,EACTf,EAAO2B,MAAQC,EAAEmF,eACRnC,EAAQC,EAAW9D,IAC5BmD,EAAWlE,EAAQ,oCACnBA,EAAOkH,WAAanG,EACpBf,EAAOmH,YAAc,GACrBnH,EAAO2B,MAAQC,EAAEwF,aAEjBlD,EAAWlE,EAAQ,0BAGrB,SAEF,KAAK4B,EAAE+F,sBACL,IAAKG,EAAY/G,GAAI,CACT,MAANA,EACFf,EAAO2B,MAAQC,EAAEmG,sBAEjB/H,EAAOmH,aAAepG,EAGxB,SAGFuG,EAAOtH,GAEG,MAANe,EACF+F,EAAQ9G,GAERA,EAAO2B,MAAQC,EAAEoF,OAGnB,SAEF,KAAKpF,EAAE6C,UACL,GAAKzE,EAAO+E,QAaK,MAANhE,EACTkG,EAASjH,GACA4E,EAAQgC,EAAU7F,GAC3Bf,EAAO+E,SAAWhE,EACTf,EAAOwE,QAChBxE,EAAOwE,QAAU,KAAOxE,EAAO+E,QAC/B/E,EAAO+E,QAAU,GACjB/E,EAAO2B,MAAQC,EAAE0C,SAEZL,EAAalD,IAChBmD,EAAWlE,EAAQ,kCAGrBA,EAAO2B,MAAQC,EAAEoG,yBA1BE,CACnB,GAAI/D,EAAalD,GACf,SACSkH,EAASpD,EAAW9D,GACzBf,EAAOwE,QACTxE,EAAOwE,QAAU,KAAOzD,EACxBf,EAAO2B,MAAQC,EAAE0C,QAEjBJ,EAAWlE,EAAQ,mCAGrBA,EAAO+E,QAAUhE,EAkBrB,SAEF,KAAKa,EAAEoG,oBACL,GAAI/D,EAAalD,GACf,SAGQ,MAANA,EACFkG,EAASjH,GAETkE,EAAWlE,EAAQ,qCAGrB,SAEF,KAAK4B,EAAEuC,YACP,KAAKvC,EAAEgG,sBACP,KAAKhG,EAAEmG,sBACL,IAAIG,EACAC,EAEJ,OAAQnI,EAAO2B,OACb,KAAKC,EAAEuC,YACL+D,EAActG,EAAEiC,KAChBsE,EAAS,WACT,MAEF,KAAKvG,EAAEgG,sBACLM,EAActG,EAAE8F,oBAChBS,EAAS,cACT,MAEF,KAAKvG,EAAEmG,sBACLG,EAActG,EAAE+F,sBAChBQ,EAAS,cAIH,MAANpH,GACFf,EAAOmI,IAAWC,EAAYpI,GAC9BA,EAAOqI,OAAS,GAChBrI,EAAO2B,MAAQuG,GACNtD,EAAQ5E,EAAOqI,OAAOzH,OAAS0H,EAAaC,EAAaxH,GAClEf,EAAOqI,QAAUtH,GAEjBmD,EAAWlE,EAAQ,oCACnBA,EAAOmI,IAAW,IAAMnI,EAAOqI,OAAStH,EACxCf,EAAOqI,OAAS,GAChBrI,EAAO2B,MAAQuG,GAGjB,SAEF,QACE,MAAM,IAAI5I,MAAMU,EAAQ,kBAAoBA,EAAO2B,OAKrD3B,EAAOwC,UAAYxC,EAAOgB,qBAlgDhC,SAA2BhB,GAIzB,IAHA,IAAIwI,EAAaC,KAAKC,IAAI3I,EAAIO,kBAAmB,IAC7CqI,EAAY,EAEPjI,EAAI,EAAGC,EAAIH,EAAQI,OAAQF,EAAIC,EAAGD,IAAK,CAC9C,IAAIkI,EAAM5I,EAAOQ,EAAQE,IAAIE,OAE7B,GAAIgI,EAAMJ,EAKR,OAAQhI,EAAQE,IACd,IAAK,WACHmI,EAAU7I,GACV,MAEF,IAAK,QACHuF,EAASvF,EAAQ,UAAWA,EAAOyF,OACnCzF,EAAOyF,MAAQ,GACf,MAEF,IAAK,SACHF,EAASvF,EAAQ,WAAYA,EAAOwE,QACpCxE,EAAOwE,OAAS,GAChB,MAEF,QACE/C,EAAMzB,EAAQ,+BAAiCQ,EAAQE,IAI7DiI,EAAYF,KAAKC,IAAIC,EAAWC,GAIlC,IAAIE,EAAI/I,EAAIO,kBAAoBqI,EAChC3I,EAAOgB,oBAAsB8H,EAAI9I,EAAOwC,SA89CtCuG,CAAkB/I,GAGpB,OAAOA,GAr8CPgJ,OAAQ,WAEN,OADAvI,KAAKgB,MAAQ,KACNhB,MAETwI,MAAO,WACL,OAAOxI,KAAK6C,MAAM,OAEpB4F,MAAO,WA1BT,IAAsBlJ,EACpB6I,EADoB7I,EA2BLS,MAxBM,KAAjBT,EAAOyF,QACTF,EAASvF,EAAQ,UAAWA,EAAOyF,OACnCzF,EAAOyF,MAAQ,IAGK,KAAlBzF,EAAOwE,SACTe,EAASvF,EAAQ,WAAYA,EAAOwE,QACpCxE,EAAOwE,OAAS,MAsBpB,IACEjE,EAAS4I,IAAO5I,OAChB,MAAO6I,GACP7I,EAAS,aAGX,IAAI8I,EAActJ,EAAI6C,OAAO0G,QAAO,SAAUC,GAC5C,MAAc,UAAPA,GAAyB,QAAPA,KAO3B,SAASnJ,EAAUH,EAAQC,GACzB,KAAMO,gBAAgBL,GACpB,OAAO,IAAIA,EAAUH,EAAQC,GAG/BK,EAAOiJ,MAAM/I,MACbA,KAAKgJ,QAAU,IAAItJ,EAAUF,EAAQC,GACrCO,KAAKiJ,UAAW,EAChBjJ,KAAKkJ,UAAW,EAChB,IAAIC,EAAKnJ,KAETA,KAAKgJ,QAAQI,MAAQ,WACnBD,EAAGjH,KAAK,QAGVlC,KAAKgJ,QAAQK,QAAU,SAAUC,GAC/BH,EAAGjH,KAAK,QAASoH,GAGjBH,EAAGH,QAAQhI,MAAQ,MAGrBhB,KAAKuJ,SAAW,KAChBX,EAAYY,SAAQ,SAAUV,GAC5BvH,OAAOkI,eAAeN,EAAI,KAAOL,EAAI,CACnCY,IAAK,WACH,OAAOP,EAAGH,QAAQ,KAAOF,IAE3Ba,IAAK,SAAaC,GAChB,IAAKA,EAGH,OAFAT,EAAGU,mBAAmBf,GACtBK,EAAGH,QAAQ,KAAOF,GAAMc,EACjBA,EAGTT,EAAGW,GAAGhB,EAAIc,IAEZG,YAAY,EACZC,cAAc,OAKpBrK,EAAU2C,UAAYf,OAAOC,OAAO1B,EAAOwC,UAAW,CACpD2H,YAAa,CACXjD,MAAOrH,KAIXA,EAAU2C,UAAUO,MAAQ,SAAUqH,GACpC,GAAsB,oBAAXC,GAAoD,oBAApBA,EAAOC,UAA2BD,EAAOC,SAASF,GAAO,CAClG,IAAKlK,KAAKuJ,SAAU,CAClB,IAAIc,EAAKC,IAAeC,cACxBvK,KAAKuJ,SAAW,IAAIc,EAAG,QAGzBH,EAAOlK,KAAKuJ,SAAS1G,MAAMqH,GAM7B,OAHAlK,KAAKgJ,QAAQnG,MAAMqH,EAAKlH,YAExBhD,KAAKkC,KAAK,OAAQgI,IACX,GAGTvK,EAAU2C,UAAUK,IAAM,SAAUG,GAOlC,OANIA,GAASA,EAAM3C,QACjBH,KAAK6C,MAAMC,GAGb9C,KAAKgJ,QAAQrG,OAEN,GAGThD,EAAU2C,UAAUwH,GAAK,SAAUhB,EAAI0B,GACrC,IAAIrB,EAAKnJ,KAUT,OARKmJ,EAAGH,QAAQ,KAAOF,KAAoC,IAA7BF,EAAY6B,QAAQ3B,KAChDK,EAAGH,QAAQ,KAAOF,GAAM,WACtB,IAAI4B,EAA4B,IAArBC,UAAUxK,OAAe,CAACwK,UAAU,IAAMhG,MAAMoE,MAAM,KAAM4B,WACvED,EAAKE,OAAO,EAAG,EAAG9B,GAClBK,EAAGjH,KAAK6G,MAAMI,EAAIuB,KAIf5K,EAAOwC,UAAUwH,GAAGe,KAAK1B,EAAIL,EAAI0B,IAK1C,IAEIM,EAAgB,uCAChBC,EAAkB,gCAClBlJ,EAAS,CACXmJ,IAAKF,EACLnJ,MAAOoJ,GAQL3G,EAAY,4JACZ+B,EAAW,gMACX2B,EAAc,6JACdD,EAAa,iMAEjB,SAASrE,EAAalD,GACpB,MAAa,MAANA,GAAmB,OAANA,GAAoB,OAANA,GAAoB,OAANA,EAGlD,SAAS+E,EAAQ/E,GACf,MAAa,MAANA,GAAmB,MAANA,EAGtB,SAAS+G,EAAY/G,GACnB,MAAa,MAANA,GAAakD,EAAalD,GAGnC,SAAS6D,EAAQ8G,EAAO3K,GACtB,OAAO2K,EAAMC,KAAK5K,GAGpB,SAASkH,EAASyD,EAAO3K,GACvB,OAAQ6D,EAAQ8G,EAAO3K,GAGzB,IAAIa,EAAI,EAuVR,IAAK,IAAIgK,KAtVT7L,EAAI8L,MAAQ,CACVhK,MAAOD,IAEP+B,iBAAkB/B,IAElBiC,KAAMjC,IAENuC,YAAavC,IAEbwC,UAAWxC,IAEX8C,UAAW9C,IAEXmE,iBAAkBnE,IAElBgE,QAAShE,IAETqE,eAAgBrE,IAEhBoE,YAAapE,IAEbsE,mBAAoBtE,IAEpBkK,iBAAkBlK,IAElB8D,QAAS9D,IAETuE,eAAgBvE,IAEhBwE,cAAexE,IAEf4D,MAAO5D,IAEP0E,aAAc1E,IAEd2E,eAAgB3E,IAEhBoD,UAAWpD,IAEX6E,eAAgB7E,IAEhB4E,iBAAkB5E,IAElBkD,SAAUlD,IAEVmF,eAAgBnF,IAEhBoF,OAAQpF,IAERwF,YAAaxF,IAEb2F,sBAAuB3F,IAEvByF,aAAczF,IAEd8F,oBAAqB9F,IAErBiG,oBAAqBjG,IAErB+F,sBAAuB/F,IAEvBgG,sBAAuBhG,IAEvBmG,sBAAuBnG,IAEvB6C,UAAW7C,IAEXoG,oBAAqBpG,IAErB0C,OAAQ1C,IAER2C,cAAe3C,KAGjB7B,EAAImC,aAAe,CACjB,IAAO,IACP,GAAM,IACN,GAAM,IACN,KAAQ,IACR,KAAQ,KAEVnC,EAAIgC,SAAW,CACb,IAAO,IACP,GAAM,IACN,GAAM,IACN,KAAQ,IACR,KAAQ,IACR,MAAS,IACT,OAAU,IACV,MAAS,IACT,OAAU,IACV,MAAS,IACT,OAAU,IACV,KAAQ,IACR,OAAU,IACV,IAAO,IACP,OAAU,IACV,MAAS,IACT,OAAU,IACV,KAAQ,IACR,OAAU,IACV,MAAS,IACT,OAAU,IACV,KAAQ,IACR,OAAU,IACV,OAAU,IACV,MAAS,IACT,OAAU,IACV,OAAU,IACV,OAAU,IACV,KAAQ,IACR,MAAS,IACT,OAAU,IACV,MAAS,IACT,OAAU,IACV,KAAQ,IACR,OAAU,IACV,OAAU,IACV,MAAS,IACT,MAAS,IACT,OAAU,IACV,MAAS,IACT,OAAU,IACV,KAAQ,IACR,OAAU,IACV,OAAU,IACV,MAAS,IACT,OAAU,IACV,IAAO,IACP,KAAQ,IACR,OAAU,IACV,MAAS,IACT,OAAU,IACV,KAAQ,IACR,OAAU,IACV,OAAU,IACV,MAAS,IACT,OAAU,IACV,OAAU,IACV,OAAU,IACV,KAAQ,IACR,MAAS,IACT,MAAS,IACT,OAAU,IACV,MAAS,IACT,OAAU,IACV,KAAQ,IACR,OAAU,IACV,KAAQ,IACR,KAAQ,IACR,IAAO,IACP,KAAQ,IACR,MAAS,IACT,KAAQ,IACR,MAAS,IACT,OAAU,IACV,IAAO,IACP,OAAU,IACV,KAAQ,IACR,IAAO,IACP,KAAQ,IACR,MAAS,IACT,IAAO,IACP,IAAO,IACP,KAAQ,IACR,IAAO,IACP,OAAU,IACV,KAAQ,IACR,KAAQ,IACR,KAAQ,IACR,MAAS,IACT,MAAS,IACT,KAAQ,IACR,OAAU,IACV,MAAS,IACT,KAAQ,IACR,MAAS,IACT,OAAU,IACV,OAAU,IACV,OAAU,IACV,OAAU,IACV,MAAS,IACT,OAAU,IACV,MAAS,IACT,MAAS,IACT,OAAU,IACV,OAAU,IACV,KAAQ,IACR,KAAQ,IACR,KAAQ,IACR,MAAS,IACT,MAAS,IACT,KAAQ,IACR,MAAS,IACT,MAAS,IACT,QAAW,IACX,KAAQ,IACR,IAAO,IACP,MAAS,IACT,KAAQ,IACR,MAAS,IACT,OAAU,IACV,GAAM,IACN,GAAM,IACN,GAAM,IACN,QAAW,IACX,GAAM,IACN,IAAO,IACP,MAAS,IACT,IAAO,IACP,QAAW,IACX,IAAO,IACP,IAAO,IACP,IAAO,IACP,MAAS,IACT,MAAS,IACT,KAAQ,IACR,MAAS,IACT,MAAS,IACT,QAAW,IACX,KAAQ,IACR,IAAO,IACP,MAAS,IACT,KAAQ,IACR,MAAS,IACT,OAAU,IACV,GAAM,IACN,GAAM,IACN,GAAM,IACN,QAAW,IACX,GAAM,IACN,IAAO,IACP,OAAU,IACV,MAAS,IACT,IAAO,IACP,QAAW,IACX,IAAO,IACP,IAAO,IACP,IAAO,IACP,MAAS,IACT,SAAY,IACZ,MAAS,IACT,IAAO,IACP,KAAQ,KACR,KAAQ,KACR,OAAU,KACV,KAAQ,KACR,IAAO,KACP,IAAO,KACP,IAAO,KACP,MAAS,KACT,MAAS,KACT,MAAS,KACT,MAAS,KACT,MAAS,KACT,MAAS,KACT,MAAS,KACT,MAAS,KACT,OAAU,KACV,OAAU,KACV,KAAQ,KACR,OAAU,KACV,OAAU,KACV,MAAS,KACT,MAAS,KACT,OAAU,KACV,OAAU,KACV,MAAS,KACT,MAAS,KACT,KAAQ,KACR,MAAS,KACT,OAAU,KACV,KAAQ,KACR,MAAS,KACT,QAAW,KACX,KAAQ,KACR,KAAQ,KACR,KAAQ,KACR,KAAQ,KACR,KAAQ,KACR,MAAS,KACT,KAAQ,KACR,KAAQ,KACR,KAAQ,KACR,KAAQ,KACR,KAAQ,KACR,OAAU,KACV,KAAQ,KACR,MAAS,KACT,MAAS,KACT,MAAS,KACT,KAAQ,KACR,MAAS,KACT,GAAM,KACN,KAAQ,KACR,IAAO,KACP,MAAS,KACT,OAAU,KACV,MAAS,KACT,KAAQ,KACR,MAAS,KACT,IAAO,KACP,IAAO,KACP,GAAM,KACN,IAAO,KACP,IAAO,KACP,IAAO,KACP,OAAU,KACV,IAAO,KACP,KAAQ,KACR,MAAS,KACT,GAAM,KACN,MAAS,KACT,GAAM,KACN,GAAM,KACN,IAAO,KACP,IAAO,KACP,KAAQ,KACR,KAAQ,KACR,KAAQ,KACR,MAAS,KACT,OAAU,KACV,KAAQ,KACR,KAAQ,KACR,MAAS,KACT,MAAS,KACT,OAAU,KACV,OAAU,KACV,KAAQ,KACR,KAAQ,KACR,IAAO,KACP,OAAU,KACV,MAAS,KACT,OAAU,KACV,MAAS,MAEXC,OAAOgB,KAAKjD,EAAIgC,UAAUkI,SAAQ,SAAU8B,GAC1C,IAAIC,EAAIjM,EAAIgC,SAASgK,GACjBH,EAAiB,kBAANI,EAAiBC,OAAOC,aAAaF,GAAKA,EACzDjM,EAAIgC,SAASgK,GAAOH,KAGR7L,EAAI8L,MAChB9L,EAAI8L,MAAM9L,EAAI8L,MAAMD,IAAMA,EAM5B,SAASjJ,EAAK3C,EAAQmM,EAAOxB,GAC3B3K,EAAOmM,IAAUnM,EAAOmM,GAAOxB,GAGjC,SAASpF,EAASvF,EAAQoM,EAAUzB,GAC9B3K,EAAO+D,UAAU8E,EAAU7I,GAC/B2C,EAAK3C,EAAQoM,EAAUzB,GAGzB,SAAS9B,EAAU7I,GACjBA,EAAO+D,SAAWsC,EAASrG,EAAOE,IAAKF,EAAO+D,UAC1C/D,EAAO+D,UAAUpB,EAAK3C,EAAQ,SAAUA,EAAO+D,UACnD/D,EAAO+D,SAAW,GAGpB,SAASsC,EAASnG,EAAKmM,GAGrB,OAFInM,EAAIoM,OAAMD,EAAOA,EAAKC,QACtBpM,EAAIqM,YAAWF,EAAOA,EAAKG,QAAQ,OAAQ,MACxCH,EAGT,SAAS5K,EAAMzB,EAAQ+J,GAUrB,OATAlB,EAAU7I,GAENA,EAAOuC,gBACTwH,GAAM,WAAa/J,EAAOyC,KAAO,aAAezC,EAAO0C,OAAS,WAAa1C,EAAOe,GAGtFgJ,EAAK,IAAIzK,MAAMyK,GACf/J,EAAOyB,MAAQsI,EACfpH,EAAK3C,EAAQ,UAAW+J,GACjB/J,EAGT,SAASqD,EAAKrD,GAYZ,OAXIA,EAAOuB,UAAYvB,EAAOsB,YAAY4C,EAAWlE,EAAQ,qBAEzDA,EAAO2B,QAAUC,EAAEC,OAAS7B,EAAO2B,QAAUC,EAAE+B,kBAAoB3D,EAAO2B,QAAUC,EAAEiC,MACxFpC,EAAMzB,EAAQ,kBAGhB6I,EAAU7I,GACVA,EAAOe,EAAI,GACXf,EAAOqB,QAAS,EAChBsB,EAAK3C,EAAQ,SACbG,EAAUmL,KAAKtL,EAAQA,EAAOC,OAAQD,EAAOE,KACtCF,EAGT,SAASkE,EAAWlE,EAAQyM,GAC1B,GAAwB,WAApBjJ,YAAQxD,MAA0BA,aAAkBG,GACtD,MAAM,IAAIb,MAAM,0BAGdU,EAAOC,QACTwB,EAAMzB,EAAQyM,GAIlB,SAAS5F,EAAO7G,GACTA,EAAOC,SAAQD,EAAO+E,QAAU/E,EAAO+E,QAAQ/E,EAAOmB,cAC3D,IAAIuL,EAAS1M,EAAOoB,KAAKpB,EAAOoB,KAAKR,OAAS,IAAMZ,EAChDwB,EAAMxB,EAAOwB,IAAM,CACrBkF,KAAM1G,EAAO+E,QACbyC,WAAY,IAGVxH,EAAOE,IAAIkC,QACbZ,EAAIa,GAAKqK,EAAOrK,IAGlBrC,EAAOmC,WAAWvB,OAAS,EAC3B2E,EAASvF,EAAQ,iBAAkBwB,GAGrC,SAASmL,EAAMjG,EAAMkG,GACnB,IACIC,EADInG,EAAKwE,QAAQ,KACF,EAAI,CAAC,GAAIxE,GAAQA,EAAKoG,MAAM,KAC3CC,EAASF,EAAS,GAClBG,EAAQH,EAAS,GAOrB,OALID,GAAsB,UAATlG,IACfqG,EAAS,QACTC,EAAQ,IAGH,CACLD,OAAQA,EACRC,MAAOA,GAIX,SAAS1F,EAAOtH,GAKd,GAJKA,EAAOC,SACVD,EAAOkH,WAAalH,EAAOkH,WAAWlH,EAAOmB,eAGO,IAAlDnB,EAAOmC,WAAW+I,QAAQlL,EAAOkH,aAAsBlH,EAAOwB,IAAIgG,WAAWtE,eAAelD,EAAOkH,YACrGlH,EAAOkH,WAAalH,EAAOmH,YAAc,OAD3C,CAKA,GAAInH,EAAOE,IAAIkC,MAAO,CACpB,IAAI6K,EAAKN,EAAM3M,EAAOkH,YAAY,GAC9B6F,EAASE,EAAGF,OACZC,EAAQC,EAAGD,MAEf,GAAe,UAAXD,EAEF,GAAc,QAAVC,GAAmBhN,EAAOmH,cAAgBoE,EAC5CrH,EAAWlE,EAAQ,gCAAkCuL,EAAlC,aAAsEvL,EAAOmH,kBAC3F,GAAc,UAAV6F,GAAqBhN,EAAOmH,cAAgBqE,EACrDtH,EAAWlE,EAAQ,kCAAoCwL,EAApC,aAA0ExL,EAAOmH,iBAC/F,CACL,IAAI3F,EAAMxB,EAAOwB,IACbkL,EAAS1M,EAAOoB,KAAKpB,EAAOoB,KAAKR,OAAS,IAAMZ,EAEhDwB,EAAIa,KAAOqK,EAAOrK,KACpBb,EAAIa,GAAKL,OAAOC,OAAOyK,EAAOrK,KAGhCb,EAAIa,GAAG2K,GAAShN,EAAOmH,YAO3BnH,EAAOmC,WAAWgB,KAAK,CAACnD,EAAOkH,WAAYlH,EAAOmH,mBAGlDnH,EAAOwB,IAAIgG,WAAWxH,EAAOkH,YAAclH,EAAOmH,YAClD5B,EAASvF,EAAQ,cAAe,CAC9B0G,KAAM1G,EAAOkH,WACbO,MAAOzH,EAAOmH,cAIlBnH,EAAOkH,WAAalH,EAAOmH,YAAc,IAG3C,SAASL,EAAQ9G,EAAQkN,GACvB,GAAIlN,EAAOE,IAAIkC,MAAO,CAEpB,IAAIZ,EAAMxB,EAAOwB,IAEbyL,EAAKN,EAAM3M,EAAO+E,SACtBvD,EAAIuL,OAASE,EAAGF,OAChBvL,EAAIwL,MAAQC,EAAGD,MACfxL,EAAI2L,IAAM3L,EAAIa,GAAG4K,EAAGF,SAAW,GAE3BvL,EAAIuL,SAAWvL,EAAI2L,MACrBjJ,EAAWlE,EAAQ,6BAA+BoN,KAAKC,UAAUrN,EAAO+E,UACxEvD,EAAI2L,IAAMF,EAAGF,QAGf,IAAIL,EAAS1M,EAAOoB,KAAKpB,EAAOoB,KAAKR,OAAS,IAAMZ,EAEhDwB,EAAIa,IAAMqK,EAAOrK,KAAOb,EAAIa,IAC9BL,OAAOgB,KAAKxB,EAAIa,IAAI4H,SAAQ,SAAUqD,GACpC/H,EAASvF,EAAQ,kBAAmB,CAClC+M,OAAQO,EACRH,IAAK3L,EAAIa,GAAGiL,QAQlB,IAAK,IAAI5M,EAAI,EAAGC,EAAIX,EAAOmC,WAAWvB,OAAQF,EAAIC,EAAGD,IAAK,CACxD,IAAI6M,EAAKvN,EAAOmC,WAAWzB,GACvBgG,EAAO6G,EAAG,GACV9F,EAAQ8F,EAAG,GACXV,EAAWF,EAAMjG,GAAM,GACvBqG,EAASF,EAASE,OAClBC,EAAQH,EAASG,MACjBG,EAAiB,KAAXJ,EAAgB,GAAKvL,EAAIa,GAAG0K,IAAW,GAC7C9J,EAAI,CACNyD,KAAMA,EACNe,MAAOA,EACPsF,OAAQA,EACRC,MAAOA,EACPG,IAAKA,GAIHJ,GAAqB,UAAXA,IAAuBI,IACnCjJ,EAAWlE,EAAQ,6BAA+BoN,KAAKC,UAAUN,IACjE9J,EAAEkK,IAAMJ,GAGV/M,EAAOwB,IAAIgG,WAAWd,GAAQzD,EAC9BsC,EAASvF,EAAQ,cAAeiD,GAGlCjD,EAAOmC,WAAWvB,OAAS,EAG7BZ,EAAOwB,IAAIgM,gBAAkBN,EAE7BlN,EAAOuB,SAAU,EACjBvB,EAAOoB,KAAK+B,KAAKnD,EAAOwB,KACxB+D,EAASvF,EAAQ,YAAaA,EAAOwB,KAEhC0L,IAEElN,EAAO0B,UAA6C,WAAjC1B,EAAO+E,QAAQ0I,cAGrCzN,EAAO2B,MAAQC,EAAEiC,KAFjB7D,EAAO2B,MAAQC,EAAE0C,OAKnBtE,EAAOwB,IAAM,KACbxB,EAAO+E,QAAU,IAGnB/E,EAAOkH,WAAalH,EAAOmH,YAAc,GACzCnH,EAAOmC,WAAWvB,OAAS,EAG7B,SAASqG,EAASjH,GAChB,IAAKA,EAAO+E,QAIV,OAHAb,EAAWlE,EAAQ,0BACnBA,EAAO+D,UAAY,WACnB/D,EAAO2B,MAAQC,EAAEiC,MAInB,GAAI7D,EAAOwE,OAAQ,CACjB,GAAuB,WAAnBxE,EAAO+E,QAIT,OAHA/E,EAAOwE,QAAU,KAAOxE,EAAO+E,QAAU,IACzC/E,EAAO+E,QAAU,QACjB/E,EAAO2B,MAAQC,EAAE0C,QAInBiB,EAASvF,EAAQ,WAAYA,EAAOwE,QACpCxE,EAAOwE,OAAS,GAKlB,IAAIkJ,EAAI1N,EAAOoB,KAAKR,OAChBmE,EAAU/E,EAAO+E,QAEhB/E,EAAOC,SACV8E,EAAUA,EAAQ/E,EAAOmB,cAK3B,IAFA,IAAIwM,EAAU5I,EAEP2I,KAAK,CAGV,GAFY1N,EAAOoB,KAAKsM,GAEdhH,OAASiH,EAIjB,MAFAzJ,EAAWlE,EAAQ,wBAOvB,GAAI0N,EAAI,EAIN,OAHAxJ,EAAWlE,EAAQ,0BAA4BA,EAAO+E,SACtD/E,EAAO+D,UAAY,KAAO/D,EAAO+E,QAAU,SAC3C/E,EAAO2B,MAAQC,EAAEiC,MAInB7D,EAAO+E,QAAUA,EAGjB,IAFA,IAAI6G,EAAI5L,EAAOoB,KAAKR,OAEbgL,KAAM8B,GAAG,CACd,IAAIlM,EAAMxB,EAAOwB,IAAMxB,EAAOoB,KAAKwM,MACnC5N,EAAO+E,QAAU/E,EAAOwB,IAAIkF,KAC5BnB,EAASvF,EAAQ,aAAcA,EAAO+E,SACtC,IAAI8I,EAAI,GAER,IAAK,IAAInN,KAAKc,EAAIa,GAChBwL,EAAEnN,GAAKc,EAAIa,GAAG3B,GAGhB,IAAIgM,EAAS1M,EAAOoB,KAAKpB,EAAOoB,KAAKR,OAAS,IAAMZ,EAEhDA,EAAOE,IAAIkC,OAASZ,EAAIa,KAAOqK,EAAOrK,IAExCL,OAAOgB,KAAKxB,EAAIa,IAAI4H,SAAQ,SAAUqD,GACpC,IAAI1N,EAAI4B,EAAIa,GAAGiL,GACf/H,EAASvF,EAAQ,mBAAoB,CACnC+M,OAAQO,EACRH,IAAKvN,OAMH,IAAN8N,IAAS1N,EAAOsB,YAAa,GACjCtB,EAAO+E,QAAU/E,EAAOmH,YAAcnH,EAAOkH,WAAa,GAC1DlH,EAAOmC,WAAWvB,OAAS,EAC3BZ,EAAO2B,MAAQC,EAAEiC,KAGnB,SAASuE,EAAYpI,GACnB,IAEI8N,EAFAzF,EAASrI,EAAOqI,OAChB0F,EAAW1F,EAAOoF,cAElBO,EAAS,GAEb,OAAIhO,EAAO+B,SAASsG,GACXrI,EAAO+B,SAASsG,GAGrBrI,EAAO+B,SAASgM,GACX/N,EAAO+B,SAASgM,IAKA,OAFzB1F,EAAS0F,GAEErK,OAAO,KACS,MAArB2E,EAAO3E,OAAO,IAChB2E,EAASA,EAAO4F,MAAM,GAEtBD,GADAF,EAAMI,SAAS7F,EAAQ,KACV5E,SAAS,MAEtB4E,EAASA,EAAO4F,MAAM,GAEtBD,GADAF,EAAMI,SAAS7F,EAAQ,KACV5E,SAAS,MAI1B4E,EAASA,EAAOmE,QAAQ,MAAO,IAE3B2B,MAAML,IAAQE,EAAOP,gBAAkBpF,GACzCnE,EAAWlE,EAAQ,4BACZ,IAAMA,EAAOqI,OAAS,KAGxB4D,OAAOmC,cAAcN,IAG9B,SAASlK,EAAgB5D,EAAQe,GACrB,MAANA,GACFf,EAAO2B,MAAQC,EAAEwC,UACjBpE,EAAOqE,iBAAmBrE,EAAOwC,UACvByB,EAAalD,KAGvBmD,EAAWlE,EAAQ,oCACnBA,EAAO+D,SAAWhD,EAClBf,EAAO2B,MAAQC,EAAEiC,MAIrB,SAASH,EAAOH,EAAO7C,GACrB,IAAI2N,EAAS,GAMb,OAJI3N,EAAI6C,EAAM3C,SACZyN,EAAS9K,EAAMG,OAAOhD,IAGjB2N,EA5WTzM,EAAI7B,EAAI8L,MAm9BHI,OAAOmC,eACV,WACE,IAAIE,EAAqBrC,OAAOC,aAC5BqC,EAAQ9F,KAAK8F,MAEbH,EAAgB,WAClB,IAEII,EACAC,EAHAC,EAAW,MACXC,EAAY,GAGZC,GAAS,EACThO,EAASwK,UAAUxK,OAEvB,IAAKA,EACH,MAAO,GAKT,IAFA,IAAIyN,EAAS,KAEJO,EAAQhO,GAAQ,CACvB,IAAIiO,EAAYC,OAAO1D,UAAUwD,IAEjC,IAAKG,SAASF,IACdA,EAAY,GACZA,EAAY,SACZN,EAAMM,KAAeA,EAEjB,MAAMG,WAAW,uBAAyBH,GAG1CA,GAAa,MAEfF,EAAUxL,KAAK0L,IAKfL,EAAoC,QADpCK,GAAa,QACiB,IAC9BJ,EAAeI,EAAY,KAAQ,MACnCF,EAAUxL,KAAKqL,EAAeC,KAG5BG,EAAQ,IAAMhO,GAAU+N,EAAU/N,OAAS8N,KAC7CL,GAAUC,EAAmB9E,MAAM,KAAMmF,GACzCA,EAAU/N,OAAS,GAIvB,OAAOyN,GAKLrM,OAAOkI,eACTlI,OAAOkI,eAAe+B,OAAQ,gBAAiB,CAC7CxE,MAAO2G,EACP3D,cAAc,EACdf,UAAU,IAGZuC,OAAOmC,cAAgBA,EA3D3B,GAhmDJ,CA+pDI1O,MAGFuP,EACO,SAAiBxH,GACxB,OAAIrC,MAAM8J,QACD9J,MAAM8J,QAAQzH,GAI0B,mBAA1CzF,OAAOe,UAAUU,SAAS6H,KAAK7D,IAItCyH,EAAUD,EACVE,EACW,SAAqBtP,GAChC,IAAIkM,EACAqD,EAAO,GAEX,IAAKrD,KAAOlM,EACNA,EAAQqD,eAAe6I,KACzBqD,EAAKrD,GAAOlM,EAAQkM,IAIxB,OAAOqD,GAXPD,EAagB,SAA0BE,EAAMxP,GAC1CwP,KAAQxP,GAAqC,mBAAlBA,EAAQwP,KACvCxP,EAAQwP,IAAQ,IAflBF,EAkBkB,SAA4BtP,MACxC,WAAYA,IAAsC,kBAAnBA,EAAQyP,QAAiD,kBAAnBzP,EAAQyP,UACjFzP,EAAQyP,OAAS,IApBnBH,EAuBuB,SAAiCtP,GAClD,gBAAiBA,IAA2C,mBAAxBA,EAAQ0P,aAA8BL,EAAQrP,EAAQ0P,gBAC9F1P,EAAQ0P,aAAc,IAzBxBJ,EA4Be,SAAyBpD,EAAKlM,GACvCkM,EAAM,QAASlM,GAA4C,kBAAzBA,EAAQkM,EAAM,SACpDlM,EAAQkM,EAAM,OAASlM,EAAQ2P,QAAU,IAAMzD,EAAMA,IA9BvDoD,EAiCa,SAAuBpD,EAAKlM,GACzC,OAAOkM,EAAM,OAAQlM,GAIrB4P,EAAYR,EA+ChB,SAASS,EAAWjI,GAClB,IAAIkI,EAASb,OAAOrH,GAEpB,IAAK0G,MAAMwB,GACT,OAAOA,EAGT,IAAIC,EAASnI,EAAMgG,cAEnB,MAAe,SAAXmC,GAEkB,UAAXA,GAIJnI,EAGT,SAASoI,EAASC,EAAMrI,GACtB,IAAIsE,EAEJ,GAAIlM,EAAQ2P,QAAS,CAanB,IAZK1P,EAAeD,EAAQiQ,EAAO,UAAYL,EAAU5P,EAAQ0P,cAAuE,IAAxD1P,EAAQ0P,YAAYrE,QAAQrL,EAAQiQ,EAAO,QAAiBjQ,EAAQ0P,eAClJzP,EAAeD,EAAQiQ,EAAO,QAAU,IAGtChQ,EAAeD,EAAQiQ,EAAO,UAAYL,EAAU3P,EAAeD,EAAQiQ,EAAO,WACpFhQ,EAAeD,EAAQiQ,EAAO,QAAU,CAAChQ,EAAeD,EAAQiQ,EAAO,UAGrEA,EAAO,OAAQjQ,GAA4B,kBAAV4H,IACnCA,EAAQ5H,EAAQiQ,EAAO,MAAMrI,EAAO3H,IAGzB,gBAATgQ,IAA2B,kBAAmBjQ,GAAW,sBAAuBA,GAClF,IAAKkM,KAAOtE,EACV,GAAIA,EAAMvE,eAAe6I,GACvB,GAAI,kBAAmBlM,EACrB4H,EAAMsE,GAAOlM,EAAQkQ,cAActI,EAAMsE,GAAMA,EAAKjM,OAC/C,CACL,IAAIkQ,EAAOvI,EAAMsE,UACVtE,EAAMsE,GACbtE,EAAM5H,EAAQoQ,kBAAkBlE,EAAKiE,EAAMlQ,IAAmBkQ,EAMlEP,EAAU3P,EAAeD,EAAQiQ,EAAO,SAC1ChQ,EAAeD,EAAQiQ,EAAO,QAAQ3M,KAAKsE,GAE3C3H,EAAeD,EAAQiQ,EAAO,QAAUrI,MAErC,CACA3H,EAAeD,EAAQqQ,eAC1BpQ,EAAeD,EAAQqQ,aAAe,IAGxC,IAAIC,EAAU,GAGd,GAFAA,EAAQtQ,EAAQuQ,SAAWN,EAEd,gBAATA,EAAwB,CAC1B,IAAK/D,KAAOtE,EACV,GAAIA,EAAMvE,eAAe6I,GACvB,MAIJoE,EAAQtQ,EAAQwQ,SAAW,sBAAuBxQ,EAAUA,EAAQoQ,kBAAkBlE,EAAKtE,EAAO3H,GAAkBiM,EAEhHlM,EAAQyQ,0BACVH,EAAQtQ,EAAQ0Q,eAAiB9I,EAAMsE,GAAKlM,EAAQ0Q,eAEhD,kBAAmB1Q,IACrBsQ,EAAQtQ,EAAQ0Q,eAAiB1Q,EAAQkQ,cAAcI,EAAQtQ,EAAQ0Q,eAAgBxE,EAAKjM,MAG1F,kBAAmBD,IACrB4H,EAAMsE,GAAOlM,EAAQkQ,cAActI,EAAMsE,GAAMA,EAAKjM,IAGtDqQ,EAAQtQ,EAAQ2Q,gBAAkB/I,EAAMsE,SAGtC+D,EAAO,OAAQjQ,IACjB4H,EAAQ5H,EAAQiQ,EAAO,MAAMrI,EAAO3H,IAGtCqQ,EAAQtQ,EAAQiQ,EAAO,QAAUrI,EAG/B5H,EAAQ4Q,YACVN,EAAQtQ,EAAQ6Q,WAAa5Q,GAG/BA,EAAeD,EAAQqQ,aAAa/M,KAAKgN,IAI7C,SAASQ,EAAqBnJ,GAM1B,IAAIuE,EADN,GAJI,iBAAkBlM,GAAW2H,IAC/BA,EAAa3H,EAAQ+Q,aAAapJ,EAAY1H,KAG3CD,EAAQyM,MAAQ,qBAAsBzM,GAAW,oBAAqBA,GAAWA,EAAQgR,uBAAyBrJ,EAGrH,IAAKuE,KAAOvE,EACV,GAAIA,EAAWtE,eAAe6I,KACxBlM,EAAQyM,OAAM9E,EAAWuE,GAAOvE,EAAWuE,GAAKO,QAEhDzM,EAAQgR,uBACVrJ,EAAWuE,GAAO2D,EAAWlI,EAAWuE,KAGtC,qBAAsBlM,IAAS2H,EAAWuE,GAAOlM,EAAQiR,iBAAiBtJ,EAAWuE,GAAMA,EAAKjM,IAEhG,oBAAqBD,GAAS,CAChC,IAAImQ,EAAOxI,EAAWuE,UACfvE,EAAWuE,GAClBvE,EAAW3H,EAAQkR,gBAAgBhF,EAAKvE,EAAWuE,GAAMjM,IAAmBkQ,EAMpF,OAAOxI,EAGT,SAASwJ,EAAcC,GACrB,IAAIzJ,EAAa,GAEjB,GAAIyJ,EAAYtK,OAA4C,QAAnCsK,EAAYvK,KAAK+G,eAA2B5N,EAAQyQ,0BAA2B,CAItG,IAHA,IACIY,EADAC,EAAc,oDAGsC,QAAhDD,EAAQC,EAAYC,KAAKH,EAAYtK,QAC3Ca,EAAW0J,EAAM,IAAMA,EAAM,IAAMA,EAAM,IAAMA,EAAM,GAGvD1J,EAAamJ,EAAqBnJ,GAGpC,GAAuC,QAAnCyJ,EAAYvK,KAAK+G,cAAyB,CAC5C,GAAI5N,EAAQwR,kBACV,OAGFvR,EAAeD,EAAQyR,gBAAkB,GAErCtP,OAAOgB,KAAKwE,GAAY5G,SAC1Bd,EAAeD,EAAQyR,gBAAgBzR,EAAQ0Q,eAAiB/I,GAG9D3H,EAAQ4Q,YACV3Q,EAAeD,EAAQyR,gBAAgBzR,EAAQ6Q,WAAa5Q,OAEzD,CACL,GAAID,EAAQ0R,kBACV,OAGE1R,EAAQyM,OACV2E,EAAYtK,KAAOsK,EAAYtK,KAAK2F,QAGtC,IAAI7E,EAAQ,GAER5H,EAAQyQ,0BAA4BtO,OAAOgB,KAAKwE,GAAY5G,QAC9D6G,EAAMwJ,EAAYvK,MAAQ,GAC1Be,EAAMwJ,EAAYvK,MAAM7G,EAAQ0Q,eAAiB/I,GAEjDC,EAAMwJ,EAAYvK,MAAQuK,EAAYtK,KAGxCkJ,EAAS,cAAepI,IAI5B,SAAS+J,EAAe9K,EAAMc,GAC5B,IAAI2I,EAaJ,GAXsB,WAAlB3M,YAAQkD,KACVc,EAAad,EAAKc,WAClBd,EAAOA,EAAKA,MAGdc,EAAamJ,EAAqBnJ,GAE9B,kBAAmB3H,IACrB6G,EAAO7G,EAAQ4R,cAAc/K,EAAM5G,IAGjCD,EAAQ2P,QAAS,CAKjB,IAAIzD,EAFN,GAFAoE,EAAU,IAELtQ,EAAQ6R,kBAAoBlK,GAAcxF,OAAOgB,KAAKwE,GAAY5G,OAIrE,IAAKmL,KAHLoE,EAAQtQ,EAAQ0Q,eAAiB,GAGrB/I,EACNA,EAAWtE,eAAe6I,KAC5BoE,EAAQtQ,EAAQ0Q,eAAexE,GAAOvE,EAAWuE,MAKjDrF,KAAQ5G,KAAoB2P,EAAU5P,EAAQ0P,cAAsD,IAAvC1P,EAAQ0P,YAAYrE,QAAQxE,GAAe7G,EAAQ0P,eACpHzP,EAAe4G,GAAQ,IAGrB5G,EAAe4G,KAAU+I,EAAU3P,EAAe4G,MACpD5G,EAAe4G,GAAQ,CAAC5G,EAAe4G,KAGrC+I,EAAU3P,EAAe4G,IAC3B5G,EAAe4G,GAAMvD,KAAKgN,GAE1BrQ,EAAe4G,GAAQyJ,OAGpBrQ,EAAeD,EAAQqQ,eAC1BpQ,EAAeD,EAAQqQ,aAAe,KAGxCC,EAAU,IACFtQ,EAAQuQ,SAAW,UAC3BD,EAAQtQ,EAAQwQ,SAAW3J,GAEtB7G,EAAQ6R,kBAAoBlK,GAAcxF,OAAOgB,KAAKwE,GAAY5G,SACrEuP,EAAQtQ,EAAQ0Q,eAAiB/I,GAG/B3H,EAAQ8R,iBACVxB,EAAQtQ,EAAQqQ,aAAe,IAGjCpQ,EAAeD,EAAQqQ,aAAa/M,KAAKgN,GAG3CA,EAAQtQ,EAAQ6Q,WAAa5Q,EAE7BA,EAAiBqQ,EAGnB,SAASyB,EAAOvF,GACVxM,EAAQgS,aAIPxF,EAAKC,QAAWzM,EAAQiS,gCAIzBjS,EAAQyM,OACVD,EAAOA,EAAKC,QAGVzM,EAAQ6P,aACVrD,EAAOqD,EAAWrD,IAGhBxM,EAAQkS,WACV1F,EAAOA,EAAKG,QAAQ,KAAM,SAASA,QAAQ,KAAM,QAAQA,QAAQ,KAAM,SAGzEqD,EAAS,OAAQxD,IAGnB,SAAS2F,EAAUrM,GACb9F,EAAQoS,gBAIRpS,EAAQyM,OACV3G,EAAUA,EAAQ2G,QAGpBuD,EAAS,UAAWlK,IAGtB,SAASuM,EAAaxL,GACpB,IAAIyL,EAAgBrS,EAAeD,EAAQ6Q,WAEtC7Q,EAAQ4Q,kBACJ3Q,EAAeD,EAAQ6Q,WAGhC5Q,EAAiBqS,EAGnB,SAASC,EAAQ3M,GACX5F,EAAQwS,cAIRxS,EAAQyM,OACV7G,EAAQA,EAAM6G,QAGhBuD,EAAS,QAASpK,IAGpB,SAAS6M,EAAUzM,GACbhG,EAAQ0S,gBAIZ1M,EAAUA,EAAQ2G,QAAQ,KAAM,IAE5B3M,EAAQyM,OACVzG,EAAUA,EAAQyG,QAGpBuD,EAAS,UAAWhK,IAGtB,SAAS2M,EAAQ/Q,GACfA,EAAMgR,KAAOhR,EAGf,IAAIiR,EAAS,SAAgBjH,EAAKkH,GAChC,IAAI3S,EAAUD,EAAIC,QAAO,EAAM,IAC3BqO,EAAS,GAsBb,GArBAvO,EAAiBuO,EACjBxO,EAhXF,SAAyB8S,GAwCvB,OAvCA9S,EAAUsP,EAA0BwD,GACpCxD,EAA+B,oBAAqBtP,GACpDsP,EAA+B,oBAAqBtP,GACpDsP,EAA+B,mBAAoBtP,GACnDsP,EAA+B,aAActP,GAC7CsP,EAA+B,gBAAiBtP,GAChDsP,EAA+B,cAAetP,GAC9CsP,EAA+B,gBAAiBtP,GAChDsP,EAA+B,UAAWtP,GAC1CsP,EAA+B,iBAAkBtP,GACjDsP,EAA+B,YAAatP,GAC5CsP,EAA+B,OAAQtP,GACvCsP,EAA+B,aAActP,GAC7CsP,EAA+B,uBAAwBtP,GACvDsP,EAA+B,WAAYtP,GAC3CsP,EAA+B,2BAA4BtP,GAC3DsP,EAA+B,+BAAgCtP,GAC/DsP,EAAsCtP,GACtCsP,EAA8B,cAAetP,GAC7CsP,EAA8B,cAAetP,GAC7CsP,EAA8B,aAActP,GAC5CsP,EAA8B,OAAQtP,GACtCsP,EAA8B,UAAWtP,GACzCsP,EAA8B,QAAStP,GACvCsP,EAA8B,UAAWtP,GACzCsP,EAA8B,OAAQtP,GACtCsP,EAA8B,OAAQtP,GACtCsP,EAA8B,WAAYtP,GAC1CsP,EAA8B,SAAUtP,GACxCsP,EAA4B,UAAWtP,GACvCsP,EAA4B,cAAetP,GAC3CsP,EAA4B,QAAStP,GACrCsP,EAA4B,UAAWtP,GACvCsP,EAA4B,OAAQtP,GACpCsP,EAA4B,kBAAmBtP,GAC/CsP,EAA4B,cAAetP,GAC3CsP,EAA4B,gBAAiBtP,GAC7CsP,EAA4B,iBAAkBtP,GAC9CsP,EAA4B,aAActP,GACnCA,EAwUG+S,CAAgBD,GAGxB3S,EAAOE,IAAM,CACX4B,gBAAgB,GAElB9B,EAAO6S,UAAYrB,EACnBxR,EAAO8S,OAASlB,EAChB5R,EAAO+S,UAAYf,EACnBhS,EAAOgT,WAAad,EACpBlS,EAAO8J,QAAU0I,EACjBxS,EAAOiT,QAAUb,EACjBpS,EAAOkT,UAAYZ,EACnBtS,EAAOmT,wBAA0BnC,EAIjChR,EAAOsD,MAAMmI,GAAKxC,QAGhBoF,EAAOxO,EAAQqQ,aAAc,CAC/B,IAAIF,EAAO3B,EAAOxO,EAAQqQ,oBACnB7B,EAAOxO,EAAQqQ,aACtB7B,EAAOxO,EAAQqQ,aAAeF,SACvB3B,EAAOhC,KAGhB,OAAOgC,GAST,IAkBI+E,EAAkBC,EADlBC,EAAYrE,EAiDhB,SAASsE,EAAiB1T,EAAS2T,EAAOC,GACxC,QAASA,GAAa5T,EAAQyP,OAAS,KAAO,IAAMlK,MAAMoO,EAAQ,GAAGnO,KAAKxF,EAAQyP,QAGpF,SAASoE,EAAgBlM,EAAY3H,EAAS2T,GAC5C,GAAI3T,EAAQ6R,iBACV,MAAO,GAGL,iBAAkB7R,IACpB2H,EAAa3H,EAAQ+Q,aAAapJ,EAAY6L,EAAoBD,IAGpE,IAAIrH,EACA4H,EACAC,EACAC,EACAxF,EAAS,GAEb,IAAKtC,KAAOvE,EACNA,EAAWtE,eAAe6I,IAA4B,OAApBvE,EAAWuE,SAAqC+H,IAApBtM,EAAWuE,KAC3E8H,EAAQhU,EAAQkU,6BAA0D,kBAApBvM,EAAWuE,GAAoB,GAAK,IAG1F4H,GAFAA,EAAO,GAAKnM,EAAWuE,IAEXS,QAAQ,KAAM,UAC1BoH,EAAW,oBAAqB/T,EAAUA,EAAQkR,gBAAgBhF,EAAK4H,EAAMN,EAAoBD,GAAoBrH,EACrHsC,EAAOlL,KAAKtD,EAAQyP,QAAUzP,EAAQmU,iBAAmBT,EAAiB1T,EAAS2T,EAAQ,GAAG,GAAS,KACvGnF,EAAOlL,KAAKyQ,EAAW,IAAMC,GAAS,qBAAsBhU,EAAUA,EAAQiR,iBAAiB6C,EAAM5H,EAAKsH,EAAoBD,GAAoBO,GAAQE,IAQ9J,OAJIrM,GAAcxF,OAAOgB,KAAKwE,GAAY5G,QAAUf,EAAQyP,QAAUzP,EAAQmU,kBAC5E3F,EAAOlL,KAAKoQ,EAAiB1T,EAAS2T,GAAO,IAGxCnF,EAAOhJ,KAAK,IAGrB,SAAS4O,EAAiBC,EAAarU,EAAS2T,GAG9C,OAFAJ,EAAmBc,EACnBb,EAAqB,MACdxT,EAAQwR,kBAAoB,GAAK,QAAeqC,EAAgBQ,EAAYrU,EAAQ0Q,eAAgB1Q,EAAS2T,GAAS,KAG/H,SAASW,EAAiBlD,EAAapR,EAAS2T,GAC9C,GAAI3T,EAAQ0R,kBACV,MAAO,GAGT,IAAIxF,EAEJ,IAAKA,KAAOkF,EACV,GAAIA,EAAY/N,eAAe6I,GAC7B,MAIJ,IAAIqI,EAAkB,sBAAuBvU,EAAUA,EAAQoQ,kBAAkBlE,EAAKkF,EAAYlF,GAAMsH,EAAoBD,GAAoBrH,EAEhJ,GAAkC,WAA9BvI,YAAQyN,EAAYlF,IAGtB,OAFAqH,EAAmBnC,EACnBoC,EAAqBe,EACd,KAAOA,EAAkBV,EAAgBzC,EAAYlF,GAAKlM,EAAQ0Q,eAAgB1Q,EAAS2T,GAAS,KAE3G,IAAIa,EAAmBpD,EAAYlF,GAAOkF,EAAYlF,GAAO,GAE7D,MADI,kBAAmBlM,IAASwU,EAAmBxU,EAAQkQ,cAAcsE,EAAkBtI,EAAKsH,EAAoBD,IAC7G,KAAOgB,GAAmBC,EAAmB,IAAMA,EAAmB,IAAM,KAIvF,SAASC,EAAa3O,EAAS9F,GAC7B,OAAOA,EAAQoS,cAAgB,GAAK,WAAU,cAAepS,EAAUA,EAAQ0U,UAAU5O,EAAS0N,EAAoBD,GAAoBzN,GAAW,SAGvJ,SAAS6O,EAAW/O,EAAO5F,GACzB,OAAOA,EAAQwS,YAAc,GAAK,aAAe,YAAaxS,EAAUA,EAAQ4U,QAAQhP,EAAO4N,EAAoBD,GAAoB3N,EAAM+G,QAAQ,MAAO,oBAAsB,MAGpL,SAASkI,EAAa7O,EAAShG,GAC7B,OAAOA,EAAQ0S,cAAgB,GAAK,cAAgB,cAAe1S,EAAUA,EAAQ8U,UAAU9O,EAASwN,EAAoBD,GAAoBvN,GAAW,IAG7J,SAAS+O,EAAUvI,EAAMxM,GACvB,OAAIA,EAAQgS,WAAmB,IAK/BxF,GAFAA,GAFAA,EAAO,GAAKA,GAEAG,QAAQ,SAAU,MAElBA,QAAQ,KAAM,SAASA,QAAQ,KAAM,QAAQA,QAAQ,KAAM,QAChE,WAAY3M,EAAUA,EAAQgV,OAAOxI,EAAMgH,EAAoBD,GAAoB/G,GAsF5F,SAASyI,EAAcC,EAAUlV,EAAS2T,EAAOC,GAC/C,OAAOsB,EAASC,QAAO,SAAUvJ,EAAK0E,GACpC,IAAI8E,EAAS1B,EAAiB1T,EAAS2T,EAAOC,IAAchI,GAE5D,OAAQ0E,EAAQL,MACd,IAAK,UACH,OAAOrE,EAAMwJ,EA7CrB,SAAsB9E,EAAStQ,EAAS2T,GACtCJ,EAAmBjD,EACnBkD,EAAqBlD,EAAQzJ,KAC7B,IAAI+E,EAAM,GACNyJ,EAAc,kBAAmBrV,EAAUA,EAAQ4R,cAActB,EAAQzJ,KAAMyJ,GAAWA,EAAQzJ,KACtG+E,EAAItI,KAAK,IAAM+R,GAEX/E,EAAQtQ,EAAQ0Q,gBAClB9E,EAAItI,KAAKuQ,EAAgBvD,EAAQtQ,EAAQ0Q,eAAgB1Q,EAAS2T,IAGpE,IAAI2B,EAAiBhF,EAAQtQ,EAAQqQ,cAAgBC,EAAQtQ,EAAQqQ,aAAatP,QAAUuP,EAAQtQ,EAAQ0Q,gBAAkE,aAAhDJ,EAAQtQ,EAAQ0Q,eAAe,aAyB7J,OAvBK4E,IAEDA,EADE,0BAA2BtV,EACZA,EAAQuV,sBAAsBjF,EAAQzJ,KAAMyJ,GAE5CtQ,EAAQwV,qBAIzBF,GACF1J,EAAItI,KAAK,KAELgN,EAAQtQ,EAAQqQ,cAAgBC,EAAQtQ,EAAQqQ,aAAatP,SAC/D6K,EAAItI,KAAK2R,EAAc3E,EAAQtQ,EAAQqQ,aAAcrQ,EAAS2T,EAAQ,IACtEJ,EAAmBjD,EACnBkD,EAAqBlD,EAAQzJ,MAG/B+E,EAAItI,KAAKtD,EAAQyP,QA1ErB,SAAoBa,EAAStQ,GAC3B,IAAIa,EAEJ,GAAIyP,EAAQ4E,UAAY5E,EAAQ4E,SAASnU,OACvC,IAAKF,EAAI,EAAGA,EAAIyP,EAAQ4E,SAASnU,SAAUF,EACzC,OAAQyP,EAAQ4E,SAASrU,GAAGb,EAAQuQ,UAClC,IAAK,OACH,GAAIvQ,EAAQyV,WACV,OAAO,EAGT,MAGF,IAAK,QACH,GAAIzV,EAAQ0V,YACV,OAAO,EAGT,MAGF,IAAK,cACH,GAAI1V,EAAQ2V,kBACV,OAAO,EAGT,MAGF,IAAK,UACL,IAAK,UACL,IAAK,UAGL,QACE,OAAO,EAKf,OAAO,EAiCsBC,CAAWtF,EAAStQ,GAAW,KAAOuF,MAAMoO,EAAQ,GAAGnO,KAAKxF,EAAQyP,QAAU,IACzG7D,EAAItI,KAAK,KAAO+R,EAAc,MAE9BzJ,EAAItI,KAAK,MAGJsI,EAAIpG,KAAK,IASYqQ,CAAavF,EAAStQ,EAAS2T,GAEvD,IAAK,UACH,OAAO/H,EAAMwJ,EAASX,EAAanE,EAAQtQ,EAAQ8V,YAAa9V,GAElE,IAAK,UACH,OAAO4L,EAAMwJ,EAASP,EAAavE,EAAQtQ,EAAQ+V,YAAa/V,GAElE,IAAK,QACH,OAAO4L,GAAO5L,EAAQ0V,YAAcN,EAAS,IAAMT,EAAWrE,EAAQtQ,EAAQgW,UAAWhW,GAE3F,IAAK,OACH,OAAO4L,GAAO5L,EAAQyV,WAAaL,EAAS,IAAML,EAAUzE,EAAQtQ,EAAQiW,SAAUjW,GAExF,IAAK,cACH,IAAIoR,EAAc,GAElB,OADAA,EAAYd,EAAQtQ,EAAQwQ,UAAYF,EAAQtQ,EAAQ0Q,eAAiBJ,EAAUA,EAAQtQ,EAAQ2Q,gBAC5F/E,GAAO5L,EAAQ2V,kBAAoBP,EAAS,IAAMd,EAAiBlD,EAAapR,EAAS2T,MAEnG,IAGL,SAASuC,EAAkB5F,EAAStQ,EAASmW,GAC3C,IAAIjK,EAEJ,IAAKA,KAAOoE,EACV,GAAIA,EAAQjN,eAAe6I,GACzB,OAAQA,GACN,KAAKlM,EAAQ6Q,UACb,KAAK7Q,EAAQ0Q,cACX,MAGF,KAAK1Q,EAAQiW,QACX,GAAIjW,EAAQyV,YAAcU,EACxB,OAAO,EAGT,MAGF,KAAKnW,EAAQgW,SACX,GAAIhW,EAAQ0V,aAAeS,EACzB,OAAO,EAGT,MAGF,KAAKnW,EAAQ2Q,eACX,GAAI3Q,EAAQ2V,mBAAqBQ,EAC/B,OAAO,EAGT,MAGF,KAAKnW,EAAQ+V,WACb,KAAK/V,EAAQ8V,WAGb,QACE,OAAO,EAKf,OAAO,EAGT,SAASM,EAAoB9F,EAASzJ,EAAM7G,EAAS2T,EAAOyB,GAC1D7B,EAAmBjD,EACnBkD,EAAqB3M,EACrB,IAAIwO,EAAc,kBAAmBrV,EAAUA,EAAQ4R,cAAc/K,EAAMyJ,GAAWzJ,EAEtF,GAAuB,qBAAZyJ,GAAuC,OAAZA,GAAgC,KAAZA,EACxD,MAAO,0BAA2BtQ,GAAWA,EAAQuV,sBAAsB1O,EAAMyJ,IAAYtQ,EAAQwV,oBAAsB,IAAMH,EAAc,MAAQA,EAAc,IAAM,IAAMA,EAAc,KAGjM,IAAIzJ,EAAM,GAEV,GAAI/E,EAAM,CAGR,GAFA+E,EAAItI,KAAK,IAAM+R,GAEU,WAArB1R,YAAQ2M,GAEV,OADA1E,EAAItI,KAAK,IAAMyR,EAAUzE,EAAStQ,GAAW,KAAOqV,EAAc,KAC3DzJ,EAAIpG,KAAK,IAGd8K,EAAQtQ,EAAQ0Q,gBAClB9E,EAAItI,KAAKuQ,EAAgBvD,EAAQtQ,EAAQ0Q,eAAgB1Q,EAAS2T,IAGpE,IAAI2B,EAAiBY,EAAkB5F,EAAStQ,GAAS,IAASsQ,EAAQtQ,EAAQ0Q,gBAAkE,aAAhDJ,EAAQtQ,EAAQ0Q,eAAe,aAUnI,GARK4E,IAEDA,EADE,0BAA2BtV,EACZA,EAAQuV,sBAAsB1O,EAAMyJ,GAEpCtQ,EAAQwV,sBAIzBF,EAIF,OADA1J,EAAItI,KAAK,MACFsI,EAAIpG,KAAK,IAHhBoG,EAAItI,KAAK,KAeb,OARAsI,EAAItI,KAAK+S,EAAqB/F,EAAStQ,EAAS2T,EAAQ,GAAG,IAC3DJ,EAAmBjD,EACnBkD,EAAqB3M,EAEjBA,GACF+E,EAAItI,MAAM8R,EAAS1B,EAAiB1T,EAAS2T,GAAO,GAAS,IAAM,KAAO0B,EAAc,KAGnFzJ,EAAIpG,KAAK,IAGlB,SAAS6Q,EAAqB/F,EAAStQ,EAAS2T,EAAOC,GACrD,IAAI/S,EACAqL,EACAoK,EACA1K,EAAM,GAEV,IAAKM,KAAOoE,EACV,GAAIA,EAAQjN,eAAe6I,GAGzB,IAFAoK,EAAQ7C,EAAUnD,EAAQpE,IAAQoE,EAAQpE,GAAO,CAACoE,EAAQpE,IAErDrL,EAAI,EAAGA,EAAIyV,EAAMvV,SAAUF,EAAG,CACjC,OAAQqL,GACN,KAAKlM,EAAQyR,eACX7F,EAAItI,KAAK8Q,EAAiBkC,EAAMzV,GAAIb,EAAS2T,IAC7C,MAEF,KAAK3T,EAAQ2Q,eACX/E,EAAItI,MAAMtD,EAAQ2V,kBAAoBjC,EAAiB1T,EAAS2T,EAAOC,GAAa,IAAMU,EAAiBgC,EAAMzV,GAAIb,EAAS2T,IAC9H,MAEF,KAAK3T,EAAQ0Q,cACb,KAAK1Q,EAAQ6Q,UACX,MAGF,KAAK7Q,EAAQiW,QACXrK,EAAItI,MAAMtD,EAAQyV,WAAa/B,EAAiB1T,EAAS2T,EAAOC,GAAa,IAAMmB,EAAUuB,EAAMzV,GAAIb,IACvG,MAEF,KAAKA,EAAQgW,SACXpK,EAAItI,MAAMtD,EAAQ0V,YAAchC,EAAiB1T,EAAS2T,EAAOC,GAAa,IAAMe,EAAW2B,EAAMzV,GAAIb,IACzG,MAEF,KAAKA,EAAQ+V,WACXnK,EAAItI,KAAKoQ,EAAiB1T,EAAS2T,EAAOC,GAAaiB,EAAayB,EAAMzV,GAAIb,IAC9E,MAEF,KAAKA,EAAQ8V,WACXlK,EAAItI,KAAKoQ,EAAiB1T,EAAS2T,EAAOC,GAAaa,EAAa6B,EAAMzV,GAAIb,IAC9E,MAEF,QACE4L,EAAItI,KAAKoQ,EAAiB1T,EAAS2T,EAAOC,GAAawC,EAAoBE,EAAMzV,GAAIqL,EAAKlM,EAAS2T,EAAOuC,EAAkBI,EAAMzV,GAAIb,KAG1I4T,EAAYA,IAAchI,EAAI7K,OAKpC,OAAO6K,EAAIpG,KAAK,IAGlB,IAAI+Q,EAAS,SAAgBC,EAAIxW,GAC/BA,EAnZF,SAA2B8S,GACzB,IAAI9S,EAAUsP,EAA0BwD,GA0CxC,OAzCAxD,EAA+B,oBAAqBtP,GACpDsP,EAA+B,oBAAqBtP,GACpDsP,EAA+B,mBAAoBtP,GACnDsP,EAA+B,aAActP,GAC7CsP,EAA+B,gBAAiBtP,GAChDsP,EAA+B,cAAetP,GAC9CsP,EAA+B,gBAAiBtP,GAChDsP,EAA+B,UAAWtP,GAC1CsP,EAA+B,aAActP,GAC7CsP,EAA+B,cAAetP,GAC9CsP,EAA+B,mBAAoBtP,GACnDsP,EAA+B,oBAAqBtP,GACpDsP,EAA+B,sBAAuBtP,GACtDsP,EAA+B,8BAA+BtP,GAC9DsP,EAAiCtP,GAEH,kBAAnBA,EAAQyP,SACjBzP,EAAQyP,OAASlK,MAAMvF,EAAQyP,OAAS,GAAGjK,KAAK,MAGlD8J,EAA8B,cAAetP,GAC7CsP,EAA8B,cAAetP,GAC7CsP,EAA8B,aAActP,GAC5CsP,EAA8B,OAAQtP,GACtCsP,EAA8B,UAAWtP,GACzCsP,EAA8B,QAAStP,GACvCsP,EAA8B,UAAWtP,GACzCsP,EAA8B,OAAQtP,GACtCsP,EAA8B,OAAQtP,GACtCsP,EAA8B,WAAYtP,GAC1CsP,EAA4B,UAAWtP,GACvCsP,EAA4B,cAAetP,GAC3CsP,EAA4B,QAAStP,GACrCsP,EAA4B,UAAWtP,GACvCsP,EAA4B,OAAQtP,GACpCsP,EAA4B,kBAAmBtP,GAC/CsP,EAA4B,cAAetP,GAC3CsP,EAA4B,gBAAiBtP,GAC7CsP,EAA4B,iBAAkBtP,GAC9CsP,EAA4B,aAActP,GAC1CsP,EAA4B,sBAAuBtP,GAC5CA,EAwWGyW,CAAkBzW,GAC5B,IAAI4L,EAAM,GAgBV,OAfA2H,EAAmBiD,EACnBhD,EAAqB,SAEjBxT,EAAQ2P,QACV/D,EAAItI,KAAK+S,EAAqBG,EAAIxW,EAAS,GAAG,KAE1CwW,EAAGxW,EAAQyR,iBACb7F,EAAItI,KAAK8Q,EAAiBoC,EAAGxW,EAAQyR,gBAAiBzR,EAAS,IAG7DwW,EAAGxW,EAAQqQ,cAAgBmG,EAAGxW,EAAQqQ,aAAatP,QACrD6K,EAAItI,KAAK2R,EAAcuB,EAAGxW,EAAQqQ,aAAcrQ,EAAS,GAAI4L,EAAI7K,UAI9D6K,EAAIpG,KAAK,KAyBdkR,EAAM,CACR7D,OAAQA,EACR8D,SAnda,SAAkB/K,EAAKkH,GACpC,IAAI9S,EAASwW,EAAU3F,EAavB,OAZA7Q,EARF,SAA2B8S,GACzB,IAAI9S,EAAUsP,EAA0BwD,GAExC,OADAxD,EAAiCtP,GAC1BA,EAKG4W,CAAkB9D,GAC5B0D,EAAK3D,EAAOjH,EAAK5L,GACjB6Q,EAAY,YAAa7Q,GAAWA,EAAQ2P,QAAU,UAAY,UAE9D,cAAe3P,GAAWA,EAAQ4Q,UAC7BrD,KAAKC,UAAUgJ,GAAI,SAAUK,EAAGC,GACrC,OAAOD,IAAMhG,EAAY,IAAMiG,IAC9B9W,EAAQyP,QAEJlC,KAAKC,UAAUgJ,EAAI,KAAMxW,EAAQyP,SAG9B9C,QAAQ,UAAW,WAAWA,QAAQ,UAAW,YAsc7D4J,OAAQA,EACRQ,SA1Ba,SAAkBC,EAAMhX,GACjCgX,aAAgBjM,IAClBiM,EAAOA,EAAKpT,YAGd,IAAI4S,EAAK,KAET,GAAoB,kBAATQ,EACT,IACER,EAAKjJ,KAAK0J,MAAMD,GAChB,MAAO7K,GACP,MAAM,IAAI1M,MAAM,sCAGlB+W,EAAKQ,EAGP,OAAOT,EAAOC,EAAIxW,O","file":"static/js/7.78a65444.chunk.js","sourcesContent":["import { _ as _typeof } from './index-a41a710f.js';\nimport stream from 'stream';\nimport string_decoder from 'string_decoder';\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction commonjsRequire () {\n\tthrow new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');\n}\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nfunction getCjsExportFromNamespace (n) {\n\treturn n && n['default'] || n;\n}\n\nvar sax = createCommonjsModule(function (module, exports) {\n\n  (function (sax) {\n    // wrapper for non-node envs\n    sax.parser = function (strict, opt) {\n      return new SAXParser(strict, opt);\n    };\n\n    sax.SAXParser = SAXParser;\n    sax.SAXStream = SAXStream;\n    sax.createStream = createStream; // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.\n    // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),\n    // since that's the earliest that a buffer overrun could occur.  This way, checks are\n    // as rare as required, but as often as necessary to ensure never crossing this bound.\n    // Furthermore, buffers are only tested at most once per write(), so passing a very\n    // large string into write() might have undesirable effects, but this is manageable by\n    // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme\n    // edge case, result in creating at most one complete copy of the string passed in.\n    // Set to Infinity to have unlimited buffers.\n\n    sax.MAX_BUFFER_LENGTH = 64 * 1024;\n    var buffers = ['comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype', 'procInstName', 'procInstBody', 'entity', 'attribName', 'attribValue', 'cdata', 'script'];\n    sax.EVENTS = ['text', 'processinginstruction', 'sgmldeclaration', 'doctype', 'comment', 'opentagstart', 'attribute', 'opentag', 'closetag', 'opencdata', 'cdata', 'closecdata', 'error', 'end', 'ready', 'script', 'opennamespace', 'closenamespace'];\n\n    function SAXParser(strict, opt) {\n      if (!(this instanceof SAXParser)) {\n        return new SAXParser(strict, opt);\n      }\n\n      var parser = this;\n      clearBuffers(parser);\n      parser.q = parser.c = '';\n      parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;\n      parser.opt = opt || {};\n      parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;\n      parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase';\n      parser.tags = [];\n      parser.closed = parser.closedRoot = parser.sawRoot = false;\n      parser.tag = parser.error = null;\n      parser.strict = !!strict;\n      parser.noscript = !!(strict || parser.opt.noscript);\n      parser.state = S.BEGIN;\n      parser.strictEntities = parser.opt.strictEntities;\n      parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);\n      parser.attribList = []; // namespaces form a prototype chain.\n      // it always points at the current tag,\n      // which protos to its parent tag.\n\n      if (parser.opt.xmlns) {\n        parser.ns = Object.create(rootNS);\n      } // mostly just for error reporting\n\n\n      parser.trackPosition = parser.opt.position !== false;\n\n      if (parser.trackPosition) {\n        parser.position = parser.line = parser.column = 0;\n      }\n\n      emit(parser, 'onready');\n    }\n\n    if (!Object.create) {\n      Object.create = function (o) {\n        function F() {}\n\n        F.prototype = o;\n        var newf = new F();\n        return newf;\n      };\n    }\n\n    if (!Object.keys) {\n      Object.keys = function (o) {\n        var a = [];\n\n        for (var i in o) {\n          if (o.hasOwnProperty(i)) a.push(i);\n        }\n\n        return a;\n      };\n    }\n\n    function checkBufferLength(parser) {\n      var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);\n      var maxActual = 0;\n\n      for (var i = 0, l = buffers.length; i < l; i++) {\n        var len = parser[buffers[i]].length;\n\n        if (len > maxAllowed) {\n          // Text/cdata nodes can get big, and since they're buffered,\n          // we can get here under normal conditions.\n          // Avoid issues by emitting the text node now,\n          // so at least it won't get any bigger.\n          switch (buffers[i]) {\n            case 'textNode':\n              closeText(parser);\n              break;\n\n            case 'cdata':\n              emitNode(parser, 'oncdata', parser.cdata);\n              parser.cdata = '';\n              break;\n\n            case 'script':\n              emitNode(parser, 'onscript', parser.script);\n              parser.script = '';\n              break;\n\n            default:\n              error(parser, 'Max buffer length exceeded: ' + buffers[i]);\n          }\n        }\n\n        maxActual = Math.max(maxActual, len);\n      } // schedule the next check for the earliest possible buffer overrun.\n\n\n      var m = sax.MAX_BUFFER_LENGTH - maxActual;\n      parser.bufferCheckPosition = m + parser.position;\n    }\n\n    function clearBuffers(parser) {\n      for (var i = 0, l = buffers.length; i < l; i++) {\n        parser[buffers[i]] = '';\n      }\n    }\n\n    function flushBuffers(parser) {\n      closeText(parser);\n\n      if (parser.cdata !== '') {\n        emitNode(parser, 'oncdata', parser.cdata);\n        parser.cdata = '';\n      }\n\n      if (parser.script !== '') {\n        emitNode(parser, 'onscript', parser.script);\n        parser.script = '';\n      }\n    }\n\n    SAXParser.prototype = {\n      end: function end() {\n        _end(this);\n      },\n      write: write,\n      resume: function resume() {\n        this.error = null;\n        return this;\n      },\n      close: function close() {\n        return this.write(null);\n      },\n      flush: function flush() {\n        flushBuffers(this);\n      }\n    };\n    var Stream;\n\n    try {\n      Stream = stream.Stream;\n    } catch (ex) {\n      Stream = function Stream() {};\n    }\n\n    var streamWraps = sax.EVENTS.filter(function (ev) {\n      return ev !== 'error' && ev !== 'end';\n    });\n\n    function createStream(strict, opt) {\n      return new SAXStream(strict, opt);\n    }\n\n    function SAXStream(strict, opt) {\n      if (!(this instanceof SAXStream)) {\n        return new SAXStream(strict, opt);\n      }\n\n      Stream.apply(this);\n      this._parser = new SAXParser(strict, opt);\n      this.writable = true;\n      this.readable = true;\n      var me = this;\n\n      this._parser.onend = function () {\n        me.emit('end');\n      };\n\n      this._parser.onerror = function (er) {\n        me.emit('error', er); // if didn't throw, then means error was handled.\n        // go ahead and clear error, so we can write again.\n\n        me._parser.error = null;\n      };\n\n      this._decoder = null;\n      streamWraps.forEach(function (ev) {\n        Object.defineProperty(me, 'on' + ev, {\n          get: function get() {\n            return me._parser['on' + ev];\n          },\n          set: function set(h) {\n            if (!h) {\n              me.removeAllListeners(ev);\n              me._parser['on' + ev] = h;\n              return h;\n            }\n\n            me.on(ev, h);\n          },\n          enumerable: true,\n          configurable: false\n        });\n      });\n    }\n\n    SAXStream.prototype = Object.create(Stream.prototype, {\n      constructor: {\n        value: SAXStream\n      }\n    });\n\n    SAXStream.prototype.write = function (data) {\n      if (typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function' && Buffer.isBuffer(data)) {\n        if (!this._decoder) {\n          var SD = string_decoder.StringDecoder;\n          this._decoder = new SD('utf8');\n        }\n\n        data = this._decoder.write(data);\n      }\n\n      this._parser.write(data.toString());\n\n      this.emit('data', data);\n      return true;\n    };\n\n    SAXStream.prototype.end = function (chunk) {\n      if (chunk && chunk.length) {\n        this.write(chunk);\n      }\n\n      this._parser.end();\n\n      return true;\n    };\n\n    SAXStream.prototype.on = function (ev, handler) {\n      var me = this;\n\n      if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {\n        me._parser['on' + ev] = function () {\n          var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);\n          args.splice(0, 0, ev);\n          me.emit.apply(me, args);\n        };\n      }\n\n      return Stream.prototype.on.call(me, ev, handler);\n    }; // this really needs to be replaced with character classes.\n    // XML allows all manner of ridiculous numbers and digits.\n\n\n    var CDATA = '[CDATA[';\n    var DOCTYPE = 'DOCTYPE';\n    var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';\n    var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';\n    var rootNS = {\n      xml: XML_NAMESPACE,\n      xmlns: XMLNS_NAMESPACE\n    }; // http://www.w3.org/TR/REC-xml/#NT-NameStartChar\n    // This implementation works on strings, a single character at a time\n    // as such, it cannot ever support astral-plane characters (10000-EFFFF)\n    // without a significant breaking change to either this  parser, or the\n    // JavaScript language.  Implementation of an emoji-capable xml parser\n    // is left as an exercise for the reader.\n\n    var nameStart = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/;\n    var nameBody = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/;\n    var entityStart = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/;\n    var entityBody = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/;\n\n    function isWhitespace(c) {\n      return c === ' ' || c === '\\n' || c === '\\r' || c === '\\t';\n    }\n\n    function isQuote(c) {\n      return c === '\"' || c === '\\'';\n    }\n\n    function isAttribEnd(c) {\n      return c === '>' || isWhitespace(c);\n    }\n\n    function isMatch(regex, c) {\n      return regex.test(c);\n    }\n\n    function notMatch(regex, c) {\n      return !isMatch(regex, c);\n    }\n\n    var S = 0;\n    sax.STATE = {\n      BEGIN: S++,\n      // leading byte order mark or whitespace\n      BEGIN_WHITESPACE: S++,\n      // leading whitespace\n      TEXT: S++,\n      // general stuff\n      TEXT_ENTITY: S++,\n      // &amp and such.\n      OPEN_WAKA: S++,\n      // <\n      SGML_DECL: S++,\n      // <!BLARG\n      SGML_DECL_QUOTED: S++,\n      // <!BLARG foo \"bar\n      DOCTYPE: S++,\n      // <!DOCTYPE\n      DOCTYPE_QUOTED: S++,\n      // <!DOCTYPE \"//blah\n      DOCTYPE_DTD: S++,\n      // <!DOCTYPE \"//blah\" [ ...\n      DOCTYPE_DTD_QUOTED: S++,\n      // <!DOCTYPE \"//blah\" [ \"foo\n      COMMENT_STARTING: S++,\n      // <!-\n      COMMENT: S++,\n      // <!--\n      COMMENT_ENDING: S++,\n      // <!-- blah -\n      COMMENT_ENDED: S++,\n      // <!-- blah --\n      CDATA: S++,\n      // <![CDATA[ something\n      CDATA_ENDING: S++,\n      // ]\n      CDATA_ENDING_2: S++,\n      // ]]\n      PROC_INST: S++,\n      // <?hi\n      PROC_INST_BODY: S++,\n      // <?hi there\n      PROC_INST_ENDING: S++,\n      // <?hi \"there\" ?\n      OPEN_TAG: S++,\n      // <strong\n      OPEN_TAG_SLASH: S++,\n      // <strong /\n      ATTRIB: S++,\n      // <a\n      ATTRIB_NAME: S++,\n      // <a foo\n      ATTRIB_NAME_SAW_WHITE: S++,\n      // <a foo _\n      ATTRIB_VALUE: S++,\n      // <a foo=\n      ATTRIB_VALUE_QUOTED: S++,\n      // <a foo=\"bar\n      ATTRIB_VALUE_CLOSED: S++,\n      // <a foo=\"bar\"\n      ATTRIB_VALUE_UNQUOTED: S++,\n      // <a foo=bar\n      ATTRIB_VALUE_ENTITY_Q: S++,\n      // <foo bar=\"&quot;\"\n      ATTRIB_VALUE_ENTITY_U: S++,\n      // <foo bar=&quot\n      CLOSE_TAG: S++,\n      // </a\n      CLOSE_TAG_SAW_WHITE: S++,\n      // </a   >\n      SCRIPT: S++,\n      // <script> ...\n      SCRIPT_ENDING: S++ // <script> ... <\n\n    };\n    sax.XML_ENTITIES = {\n      'amp': '&',\n      'gt': '>',\n      'lt': '<',\n      'quot': '\"',\n      'apos': \"'\"\n    };\n    sax.ENTITIES = {\n      'amp': '&',\n      'gt': '>',\n      'lt': '<',\n      'quot': '\"',\n      'apos': \"'\",\n      'AElig': 198,\n      'Aacute': 193,\n      'Acirc': 194,\n      'Agrave': 192,\n      'Aring': 197,\n      'Atilde': 195,\n      'Auml': 196,\n      'Ccedil': 199,\n      'ETH': 208,\n      'Eacute': 201,\n      'Ecirc': 202,\n      'Egrave': 200,\n      'Euml': 203,\n      'Iacute': 205,\n      'Icirc': 206,\n      'Igrave': 204,\n      'Iuml': 207,\n      'Ntilde': 209,\n      'Oacute': 211,\n      'Ocirc': 212,\n      'Ograve': 210,\n      'Oslash': 216,\n      'Otilde': 213,\n      'Ouml': 214,\n      'THORN': 222,\n      'Uacute': 218,\n      'Ucirc': 219,\n      'Ugrave': 217,\n      'Uuml': 220,\n      'Yacute': 221,\n      'aacute': 225,\n      'acirc': 226,\n      'aelig': 230,\n      'agrave': 224,\n      'aring': 229,\n      'atilde': 227,\n      'auml': 228,\n      'ccedil': 231,\n      'eacute': 233,\n      'ecirc': 234,\n      'egrave': 232,\n      'eth': 240,\n      'euml': 235,\n      'iacute': 237,\n      'icirc': 238,\n      'igrave': 236,\n      'iuml': 239,\n      'ntilde': 241,\n      'oacute': 243,\n      'ocirc': 244,\n      'ograve': 242,\n      'oslash': 248,\n      'otilde': 245,\n      'ouml': 246,\n      'szlig': 223,\n      'thorn': 254,\n      'uacute': 250,\n      'ucirc': 251,\n      'ugrave': 249,\n      'uuml': 252,\n      'yacute': 253,\n      'yuml': 255,\n      'copy': 169,\n      'reg': 174,\n      'nbsp': 160,\n      'iexcl': 161,\n      'cent': 162,\n      'pound': 163,\n      'curren': 164,\n      'yen': 165,\n      'brvbar': 166,\n      'sect': 167,\n      'uml': 168,\n      'ordf': 170,\n      'laquo': 171,\n      'not': 172,\n      'shy': 173,\n      'macr': 175,\n      'deg': 176,\n      'plusmn': 177,\n      'sup1': 185,\n      'sup2': 178,\n      'sup3': 179,\n      'acute': 180,\n      'micro': 181,\n      'para': 182,\n      'middot': 183,\n      'cedil': 184,\n      'ordm': 186,\n      'raquo': 187,\n      'frac14': 188,\n      'frac12': 189,\n      'frac34': 190,\n      'iquest': 191,\n      'times': 215,\n      'divide': 247,\n      'OElig': 338,\n      'oelig': 339,\n      'Scaron': 352,\n      'scaron': 353,\n      'Yuml': 376,\n      'fnof': 402,\n      'circ': 710,\n      'tilde': 732,\n      'Alpha': 913,\n      'Beta': 914,\n      'Gamma': 915,\n      'Delta': 916,\n      'Epsilon': 917,\n      'Zeta': 918,\n      'Eta': 919,\n      'Theta': 920,\n      'Iota': 921,\n      'Kappa': 922,\n      'Lambda': 923,\n      'Mu': 924,\n      'Nu': 925,\n      'Xi': 926,\n      'Omicron': 927,\n      'Pi': 928,\n      'Rho': 929,\n      'Sigma': 931,\n      'Tau': 932,\n      'Upsilon': 933,\n      'Phi': 934,\n      'Chi': 935,\n      'Psi': 936,\n      'Omega': 937,\n      'alpha': 945,\n      'beta': 946,\n      'gamma': 947,\n      'delta': 948,\n      'epsilon': 949,\n      'zeta': 950,\n      'eta': 951,\n      'theta': 952,\n      'iota': 953,\n      'kappa': 954,\n      'lambda': 955,\n      'mu': 956,\n      'nu': 957,\n      'xi': 958,\n      'omicron': 959,\n      'pi': 960,\n      'rho': 961,\n      'sigmaf': 962,\n      'sigma': 963,\n      'tau': 964,\n      'upsilon': 965,\n      'phi': 966,\n      'chi': 967,\n      'psi': 968,\n      'omega': 969,\n      'thetasym': 977,\n      'upsih': 978,\n      'piv': 982,\n      'ensp': 8194,\n      'emsp': 8195,\n      'thinsp': 8201,\n      'zwnj': 8204,\n      'zwj': 8205,\n      'lrm': 8206,\n      'rlm': 8207,\n      'ndash': 8211,\n      'mdash': 8212,\n      'lsquo': 8216,\n      'rsquo': 8217,\n      'sbquo': 8218,\n      'ldquo': 8220,\n      'rdquo': 8221,\n      'bdquo': 8222,\n      'dagger': 8224,\n      'Dagger': 8225,\n      'bull': 8226,\n      'hellip': 8230,\n      'permil': 8240,\n      'prime': 8242,\n      'Prime': 8243,\n      'lsaquo': 8249,\n      'rsaquo': 8250,\n      'oline': 8254,\n      'frasl': 8260,\n      'euro': 8364,\n      'image': 8465,\n      'weierp': 8472,\n      'real': 8476,\n      'trade': 8482,\n      'alefsym': 8501,\n      'larr': 8592,\n      'uarr': 8593,\n      'rarr': 8594,\n      'darr': 8595,\n      'harr': 8596,\n      'crarr': 8629,\n      'lArr': 8656,\n      'uArr': 8657,\n      'rArr': 8658,\n      'dArr': 8659,\n      'hArr': 8660,\n      'forall': 8704,\n      'part': 8706,\n      'exist': 8707,\n      'empty': 8709,\n      'nabla': 8711,\n      'isin': 8712,\n      'notin': 8713,\n      'ni': 8715,\n      'prod': 8719,\n      'sum': 8721,\n      'minus': 8722,\n      'lowast': 8727,\n      'radic': 8730,\n      'prop': 8733,\n      'infin': 8734,\n      'ang': 8736,\n      'and': 8743,\n      'or': 8744,\n      'cap': 8745,\n      'cup': 8746,\n      'int': 8747,\n      'there4': 8756,\n      'sim': 8764,\n      'cong': 8773,\n      'asymp': 8776,\n      'ne': 8800,\n      'equiv': 8801,\n      'le': 8804,\n      'ge': 8805,\n      'sub': 8834,\n      'sup': 8835,\n      'nsub': 8836,\n      'sube': 8838,\n      'supe': 8839,\n      'oplus': 8853,\n      'otimes': 8855,\n      'perp': 8869,\n      'sdot': 8901,\n      'lceil': 8968,\n      'rceil': 8969,\n      'lfloor': 8970,\n      'rfloor': 8971,\n      'lang': 9001,\n      'rang': 9002,\n      'loz': 9674,\n      'spades': 9824,\n      'clubs': 9827,\n      'hearts': 9829,\n      'diams': 9830\n    };\n    Object.keys(sax.ENTITIES).forEach(function (key) {\n      var e = sax.ENTITIES[key];\n      var s = typeof e === 'number' ? String.fromCharCode(e) : e;\n      sax.ENTITIES[key] = s;\n    });\n\n    for (var s in sax.STATE) {\n      sax.STATE[sax.STATE[s]] = s;\n    } // shorthand\n\n\n    S = sax.STATE;\n\n    function emit(parser, event, data) {\n      parser[event] && parser[event](data);\n    }\n\n    function emitNode(parser, nodeType, data) {\n      if (parser.textNode) closeText(parser);\n      emit(parser, nodeType, data);\n    }\n\n    function closeText(parser) {\n      parser.textNode = textopts(parser.opt, parser.textNode);\n      if (parser.textNode) emit(parser, 'ontext', parser.textNode);\n      parser.textNode = '';\n    }\n\n    function textopts(opt, text) {\n      if (opt.trim) text = text.trim();\n      if (opt.normalize) text = text.replace(/\\s+/g, ' ');\n      return text;\n    }\n\n    function error(parser, er) {\n      closeText(parser);\n\n      if (parser.trackPosition) {\n        er += '\\nLine: ' + parser.line + '\\nColumn: ' + parser.column + '\\nChar: ' + parser.c;\n      }\n\n      er = new Error(er);\n      parser.error = er;\n      emit(parser, 'onerror', er);\n      return parser;\n    }\n\n    function _end(parser) {\n      if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag');\n\n      if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {\n        error(parser, 'Unexpected end');\n      }\n\n      closeText(parser);\n      parser.c = '';\n      parser.closed = true;\n      emit(parser, 'onend');\n      SAXParser.call(parser, parser.strict, parser.opt);\n      return parser;\n    }\n\n    function strictFail(parser, message) {\n      if (_typeof(parser) !== 'object' || !(parser instanceof SAXParser)) {\n        throw new Error('bad call to strictFail');\n      }\n\n      if (parser.strict) {\n        error(parser, message);\n      }\n    }\n\n    function newTag(parser) {\n      if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();\n      var parent = parser.tags[parser.tags.length - 1] || parser;\n      var tag = parser.tag = {\n        name: parser.tagName,\n        attributes: {}\n      }; // will be overridden if tag contails an xmlns=\"foo\" or xmlns:foo=\"bar\"\n\n      if (parser.opt.xmlns) {\n        tag.ns = parent.ns;\n      }\n\n      parser.attribList.length = 0;\n      emitNode(parser, 'onopentagstart', tag);\n    }\n\n    function qname(name, attribute) {\n      var i = name.indexOf(':');\n      var qualName = i < 0 ? ['', name] : name.split(':');\n      var prefix = qualName[0];\n      var local = qualName[1]; // <x \"xmlns\"=\"http://foo\">\n\n      if (attribute && name === 'xmlns') {\n        prefix = 'xmlns';\n        local = '';\n      }\n\n      return {\n        prefix: prefix,\n        local: local\n      };\n    }\n\n    function attrib(parser) {\n      if (!parser.strict) {\n        parser.attribName = parser.attribName[parser.looseCase]();\n      }\n\n      if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {\n        parser.attribName = parser.attribValue = '';\n        return;\n      }\n\n      if (parser.opt.xmlns) {\n        var qn = qname(parser.attribName, true);\n        var prefix = qn.prefix;\n        var local = qn.local;\n\n        if (prefix === 'xmlns') {\n          // namespace binding attribute. push the binding into scope\n          if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {\n            strictFail(parser, 'xml: prefix must be bound to ' + XML_NAMESPACE + '\\n' + 'Actual: ' + parser.attribValue);\n          } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {\n            strictFail(parser, 'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\\n' + 'Actual: ' + parser.attribValue);\n          } else {\n            var tag = parser.tag;\n            var parent = parser.tags[parser.tags.length - 1] || parser;\n\n            if (tag.ns === parent.ns) {\n              tag.ns = Object.create(parent.ns);\n            }\n\n            tag.ns[local] = parser.attribValue;\n          }\n        } // defer onattribute events until all attributes have been seen\n        // so any new bindings can take effect. preserve attribute order\n        // so deferred events can be emitted in document order\n\n\n        parser.attribList.push([parser.attribName, parser.attribValue]);\n      } else {\n        // in non-xmlns mode, we can emit the event right away\n        parser.tag.attributes[parser.attribName] = parser.attribValue;\n        emitNode(parser, 'onattribute', {\n          name: parser.attribName,\n          value: parser.attribValue\n        });\n      }\n\n      parser.attribName = parser.attribValue = '';\n    }\n\n    function openTag(parser, selfClosing) {\n      if (parser.opt.xmlns) {\n        // emit namespace binding events\n        var tag = parser.tag; // add namespace info to tag\n\n        var qn = qname(parser.tagName);\n        tag.prefix = qn.prefix;\n        tag.local = qn.local;\n        tag.uri = tag.ns[qn.prefix] || '';\n\n        if (tag.prefix && !tag.uri) {\n          strictFail(parser, 'Unbound namespace prefix: ' + JSON.stringify(parser.tagName));\n          tag.uri = qn.prefix;\n        }\n\n        var parent = parser.tags[parser.tags.length - 1] || parser;\n\n        if (tag.ns && parent.ns !== tag.ns) {\n          Object.keys(tag.ns).forEach(function (p) {\n            emitNode(parser, 'onopennamespace', {\n              prefix: p,\n              uri: tag.ns[p]\n            });\n          });\n        } // handle deferred onattribute events\n        // Note: do not apply default ns to attributes:\n        //   http://www.w3.org/TR/REC-xml-names/#defaulting\n\n\n        for (var i = 0, l = parser.attribList.length; i < l; i++) {\n          var nv = parser.attribList[i];\n          var name = nv[0];\n          var value = nv[1];\n          var qualName = qname(name, true);\n          var prefix = qualName.prefix;\n          var local = qualName.local;\n          var uri = prefix === '' ? '' : tag.ns[prefix] || '';\n          var a = {\n            name: name,\n            value: value,\n            prefix: prefix,\n            local: local,\n            uri: uri\n          }; // if there's any attributes with an undefined namespace,\n          // then fail on them now.\n\n          if (prefix && prefix !== 'xmlns' && !uri) {\n            strictFail(parser, 'Unbound namespace prefix: ' + JSON.stringify(prefix));\n            a.uri = prefix;\n          }\n\n          parser.tag.attributes[name] = a;\n          emitNode(parser, 'onattribute', a);\n        }\n\n        parser.attribList.length = 0;\n      }\n\n      parser.tag.isSelfClosing = !!selfClosing; // process the tag\n\n      parser.sawRoot = true;\n      parser.tags.push(parser.tag);\n      emitNode(parser, 'onopentag', parser.tag);\n\n      if (!selfClosing) {\n        // special case for <script> in non-strict mode.\n        if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {\n          parser.state = S.SCRIPT;\n        } else {\n          parser.state = S.TEXT;\n        }\n\n        parser.tag = null;\n        parser.tagName = '';\n      }\n\n      parser.attribName = parser.attribValue = '';\n      parser.attribList.length = 0;\n    }\n\n    function closeTag(parser) {\n      if (!parser.tagName) {\n        strictFail(parser, 'Weird empty close tag.');\n        parser.textNode += '</>';\n        parser.state = S.TEXT;\n        return;\n      }\n\n      if (parser.script) {\n        if (parser.tagName !== 'script') {\n          parser.script += '</' + parser.tagName + '>';\n          parser.tagName = '';\n          parser.state = S.SCRIPT;\n          return;\n        }\n\n        emitNode(parser, 'onscript', parser.script);\n        parser.script = '';\n      } // first make sure that the closing tag actually exists.\n      // <a><b></c></b></a> will close everything, otherwise.\n\n\n      var t = parser.tags.length;\n      var tagName = parser.tagName;\n\n      if (!parser.strict) {\n        tagName = tagName[parser.looseCase]();\n      }\n\n      var closeTo = tagName;\n\n      while (t--) {\n        var close = parser.tags[t];\n\n        if (close.name !== closeTo) {\n          // fail the first time in strict mode\n          strictFail(parser, 'Unexpected close tag');\n        } else {\n          break;\n        }\n      } // didn't find it.  we already failed for strict, so just abort.\n\n\n      if (t < 0) {\n        strictFail(parser, 'Unmatched closing tag: ' + parser.tagName);\n        parser.textNode += '</' + parser.tagName + '>';\n        parser.state = S.TEXT;\n        return;\n      }\n\n      parser.tagName = tagName;\n      var s = parser.tags.length;\n\n      while (s-- > t) {\n        var tag = parser.tag = parser.tags.pop();\n        parser.tagName = parser.tag.name;\n        emitNode(parser, 'onclosetag', parser.tagName);\n        var x = {};\n\n        for (var i in tag.ns) {\n          x[i] = tag.ns[i];\n        }\n\n        var parent = parser.tags[parser.tags.length - 1] || parser;\n\n        if (parser.opt.xmlns && tag.ns !== parent.ns) {\n          // remove namespace bindings introduced by tag\n          Object.keys(tag.ns).forEach(function (p) {\n            var n = tag.ns[p];\n            emitNode(parser, 'onclosenamespace', {\n              prefix: p,\n              uri: n\n            });\n          });\n        }\n      }\n\n      if (t === 0) parser.closedRoot = true;\n      parser.tagName = parser.attribValue = parser.attribName = '';\n      parser.attribList.length = 0;\n      parser.state = S.TEXT;\n    }\n\n    function parseEntity(parser) {\n      var entity = parser.entity;\n      var entityLC = entity.toLowerCase();\n      var num;\n      var numStr = '';\n\n      if (parser.ENTITIES[entity]) {\n        return parser.ENTITIES[entity];\n      }\n\n      if (parser.ENTITIES[entityLC]) {\n        return parser.ENTITIES[entityLC];\n      }\n\n      entity = entityLC;\n\n      if (entity.charAt(0) === '#') {\n        if (entity.charAt(1) === 'x') {\n          entity = entity.slice(2);\n          num = parseInt(entity, 16);\n          numStr = num.toString(16);\n        } else {\n          entity = entity.slice(1);\n          num = parseInt(entity, 10);\n          numStr = num.toString(10);\n        }\n      }\n\n      entity = entity.replace(/^0+/, '');\n\n      if (isNaN(num) || numStr.toLowerCase() !== entity) {\n        strictFail(parser, 'Invalid character entity');\n        return '&' + parser.entity + ';';\n      }\n\n      return String.fromCodePoint(num);\n    }\n\n    function beginWhiteSpace(parser, c) {\n      if (c === '<') {\n        parser.state = S.OPEN_WAKA;\n        parser.startTagPosition = parser.position;\n      } else if (!isWhitespace(c)) {\n        // have to process this as a text node.\n        // weird, but happens.\n        strictFail(parser, 'Non-whitespace before first tag.');\n        parser.textNode = c;\n        parser.state = S.TEXT;\n      }\n    }\n\n    function charAt(chunk, i) {\n      var result = '';\n\n      if (i < chunk.length) {\n        result = chunk.charAt(i);\n      }\n\n      return result;\n    }\n\n    function write(chunk) {\n      var parser = this;\n\n      if (this.error) {\n        throw this.error;\n      }\n\n      if (parser.closed) {\n        return error(parser, 'Cannot write after close. Assign an onready handler.');\n      }\n\n      if (chunk === null) {\n        return _end(parser);\n      }\n\n      if (_typeof(chunk) === 'object') {\n        chunk = chunk.toString();\n      }\n\n      var i = 0;\n      var c = '';\n\n      while (true) {\n        c = charAt(chunk, i++);\n        parser.c = c;\n\n        if (!c) {\n          break;\n        }\n\n        if (parser.trackPosition) {\n          parser.position++;\n\n          if (c === '\\n') {\n            parser.line++;\n            parser.column = 0;\n          } else {\n            parser.column++;\n          }\n        }\n\n        switch (parser.state) {\n          case S.BEGIN:\n            parser.state = S.BEGIN_WHITESPACE;\n\n            if (c === \"\\uFEFF\") {\n              continue;\n            }\n\n            beginWhiteSpace(parser, c);\n            continue;\n\n          case S.BEGIN_WHITESPACE:\n            beginWhiteSpace(parser, c);\n            continue;\n\n          case S.TEXT:\n            if (parser.sawRoot && !parser.closedRoot) {\n              var starti = i - 1;\n\n              while (c && c !== '<' && c !== '&') {\n                c = charAt(chunk, i++);\n\n                if (c && parser.trackPosition) {\n                  parser.position++;\n\n                  if (c === '\\n') {\n                    parser.line++;\n                    parser.column = 0;\n                  } else {\n                    parser.column++;\n                  }\n                }\n              }\n\n              parser.textNode += chunk.substring(starti, i - 1);\n            }\n\n            if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {\n              parser.state = S.OPEN_WAKA;\n              parser.startTagPosition = parser.position;\n            } else {\n              if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {\n                strictFail(parser, 'Text data outside of root node.');\n              }\n\n              if (c === '&') {\n                parser.state = S.TEXT_ENTITY;\n              } else {\n                parser.textNode += c;\n              }\n            }\n\n            continue;\n\n          case S.SCRIPT:\n            // only non-strict\n            if (c === '<') {\n              parser.state = S.SCRIPT_ENDING;\n            } else {\n              parser.script += c;\n            }\n\n            continue;\n\n          case S.SCRIPT_ENDING:\n            if (c === '/') {\n              parser.state = S.CLOSE_TAG;\n            } else {\n              parser.script += '<' + c;\n              parser.state = S.SCRIPT;\n            }\n\n            continue;\n\n          case S.OPEN_WAKA:\n            // either a /, ?, !, or text is coming next.\n            if (c === '!') {\n              parser.state = S.SGML_DECL;\n              parser.sgmlDecl = '';\n            } else if (isWhitespace(c)) ; else if (isMatch(nameStart, c)) {\n              parser.state = S.OPEN_TAG;\n              parser.tagName = c;\n            } else if (c === '/') {\n              parser.state = S.CLOSE_TAG;\n              parser.tagName = '';\n            } else if (c === '?') {\n              parser.state = S.PROC_INST;\n              parser.procInstName = parser.procInstBody = '';\n            } else {\n              strictFail(parser, 'Unencoded <'); // if there was some whitespace, then add that in.\n\n              if (parser.startTagPosition + 1 < parser.position) {\n                var pad = parser.position - parser.startTagPosition;\n                c = new Array(pad).join(' ') + c;\n              }\n\n              parser.textNode += '<' + c;\n              parser.state = S.TEXT;\n            }\n\n            continue;\n\n          case S.SGML_DECL:\n            if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {\n              emitNode(parser, 'onopencdata');\n              parser.state = S.CDATA;\n              parser.sgmlDecl = '';\n              parser.cdata = '';\n            } else if (parser.sgmlDecl + c === '--') {\n              parser.state = S.COMMENT;\n              parser.comment = '';\n              parser.sgmlDecl = '';\n            } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {\n              parser.state = S.DOCTYPE;\n\n              if (parser.doctype || parser.sawRoot) {\n                strictFail(parser, 'Inappropriately located doctype declaration');\n              }\n\n              parser.doctype = '';\n              parser.sgmlDecl = '';\n            } else if (c === '>') {\n              emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl);\n              parser.sgmlDecl = '';\n              parser.state = S.TEXT;\n            } else if (isQuote(c)) {\n              parser.state = S.SGML_DECL_QUOTED;\n              parser.sgmlDecl += c;\n            } else {\n              parser.sgmlDecl += c;\n            }\n\n            continue;\n\n          case S.SGML_DECL_QUOTED:\n            if (c === parser.q) {\n              parser.state = S.SGML_DECL;\n              parser.q = '';\n            }\n\n            parser.sgmlDecl += c;\n            continue;\n\n          case S.DOCTYPE:\n            if (c === '>') {\n              parser.state = S.TEXT;\n              emitNode(parser, 'ondoctype', parser.doctype);\n              parser.doctype = true; // just remember that we saw it.\n            } else {\n              parser.doctype += c;\n\n              if (c === '[') {\n                parser.state = S.DOCTYPE_DTD;\n              } else if (isQuote(c)) {\n                parser.state = S.DOCTYPE_QUOTED;\n                parser.q = c;\n              }\n            }\n\n            continue;\n\n          case S.DOCTYPE_QUOTED:\n            parser.doctype += c;\n\n            if (c === parser.q) {\n              parser.q = '';\n              parser.state = S.DOCTYPE;\n            }\n\n            continue;\n\n          case S.DOCTYPE_DTD:\n            parser.doctype += c;\n\n            if (c === ']') {\n              parser.state = S.DOCTYPE;\n            } else if (isQuote(c)) {\n              parser.state = S.DOCTYPE_DTD_QUOTED;\n              parser.q = c;\n            }\n\n            continue;\n\n          case S.DOCTYPE_DTD_QUOTED:\n            parser.doctype += c;\n\n            if (c === parser.q) {\n              parser.state = S.DOCTYPE_DTD;\n              parser.q = '';\n            }\n\n            continue;\n\n          case S.COMMENT:\n            if (c === '-') {\n              parser.state = S.COMMENT_ENDING;\n            } else {\n              parser.comment += c;\n            }\n\n            continue;\n\n          case S.COMMENT_ENDING:\n            if (c === '-') {\n              parser.state = S.COMMENT_ENDED;\n              parser.comment = textopts(parser.opt, parser.comment);\n\n              if (parser.comment) {\n                emitNode(parser, 'oncomment', parser.comment);\n              }\n\n              parser.comment = '';\n            } else {\n              parser.comment += '-' + c;\n              parser.state = S.COMMENT;\n            }\n\n            continue;\n\n          case S.COMMENT_ENDED:\n            if (c !== '>') {\n              strictFail(parser, 'Malformed comment'); // allow <!-- blah -- bloo --> in non-strict mode,\n              // which is a comment of \" blah -- bloo \"\n\n              parser.comment += '--' + c;\n              parser.state = S.COMMENT;\n            } else {\n              parser.state = S.TEXT;\n            }\n\n            continue;\n\n          case S.CDATA:\n            if (c === ']') {\n              parser.state = S.CDATA_ENDING;\n            } else {\n              parser.cdata += c;\n            }\n\n            continue;\n\n          case S.CDATA_ENDING:\n            if (c === ']') {\n              parser.state = S.CDATA_ENDING_2;\n            } else {\n              parser.cdata += ']' + c;\n              parser.state = S.CDATA;\n            }\n\n            continue;\n\n          case S.CDATA_ENDING_2:\n            if (c === '>') {\n              if (parser.cdata) {\n                emitNode(parser, 'oncdata', parser.cdata);\n              }\n\n              emitNode(parser, 'onclosecdata');\n              parser.cdata = '';\n              parser.state = S.TEXT;\n            } else if (c === ']') {\n              parser.cdata += ']';\n            } else {\n              parser.cdata += ']]' + c;\n              parser.state = S.CDATA;\n            }\n\n            continue;\n\n          case S.PROC_INST:\n            if (c === '?') {\n              parser.state = S.PROC_INST_ENDING;\n            } else if (isWhitespace(c)) {\n              parser.state = S.PROC_INST_BODY;\n            } else {\n              parser.procInstName += c;\n            }\n\n            continue;\n\n          case S.PROC_INST_BODY:\n            if (!parser.procInstBody && isWhitespace(c)) {\n              continue;\n            } else if (c === '?') {\n              parser.state = S.PROC_INST_ENDING;\n            } else {\n              parser.procInstBody += c;\n            }\n\n            continue;\n\n          case S.PROC_INST_ENDING:\n            if (c === '>') {\n              emitNode(parser, 'onprocessinginstruction', {\n                name: parser.procInstName,\n                body: parser.procInstBody\n              });\n              parser.procInstName = parser.procInstBody = '';\n              parser.state = S.TEXT;\n            } else {\n              parser.procInstBody += '?' + c;\n              parser.state = S.PROC_INST_BODY;\n            }\n\n            continue;\n\n          case S.OPEN_TAG:\n            if (isMatch(nameBody, c)) {\n              parser.tagName += c;\n            } else {\n              newTag(parser);\n\n              if (c === '>') {\n                openTag(parser);\n              } else if (c === '/') {\n                parser.state = S.OPEN_TAG_SLASH;\n              } else {\n                if (!isWhitespace(c)) {\n                  strictFail(parser, 'Invalid character in tag name');\n                }\n\n                parser.state = S.ATTRIB;\n              }\n            }\n\n            continue;\n\n          case S.OPEN_TAG_SLASH:\n            if (c === '>') {\n              openTag(parser, true);\n              closeTag(parser);\n            } else {\n              strictFail(parser, 'Forward-slash in opening tag not followed by >');\n              parser.state = S.ATTRIB;\n            }\n\n            continue;\n\n          case S.ATTRIB:\n            // haven't read the attribute name yet.\n            if (isWhitespace(c)) {\n              continue;\n            } else if (c === '>') {\n              openTag(parser);\n            } else if (c === '/') {\n              parser.state = S.OPEN_TAG_SLASH;\n            } else if (isMatch(nameStart, c)) {\n              parser.attribName = c;\n              parser.attribValue = '';\n              parser.state = S.ATTRIB_NAME;\n            } else {\n              strictFail(parser, 'Invalid attribute name');\n            }\n\n            continue;\n\n          case S.ATTRIB_NAME:\n            if (c === '=') {\n              parser.state = S.ATTRIB_VALUE;\n            } else if (c === '>') {\n              strictFail(parser, 'Attribute without value');\n              parser.attribValue = parser.attribName;\n              attrib(parser);\n              openTag(parser);\n            } else if (isWhitespace(c)) {\n              parser.state = S.ATTRIB_NAME_SAW_WHITE;\n            } else if (isMatch(nameBody, c)) {\n              parser.attribName += c;\n            } else {\n              strictFail(parser, 'Invalid attribute name');\n            }\n\n            continue;\n\n          case S.ATTRIB_NAME_SAW_WHITE:\n            if (c === '=') {\n              parser.state = S.ATTRIB_VALUE;\n            } else if (isWhitespace(c)) {\n              continue;\n            } else {\n              strictFail(parser, 'Attribute without value');\n              parser.tag.attributes[parser.attribName] = '';\n              parser.attribValue = '';\n              emitNode(parser, 'onattribute', {\n                name: parser.attribName,\n                value: ''\n              });\n              parser.attribName = '';\n\n              if (c === '>') {\n                openTag(parser);\n              } else if (isMatch(nameStart, c)) {\n                parser.attribName = c;\n                parser.state = S.ATTRIB_NAME;\n              } else {\n                strictFail(parser, 'Invalid attribute name');\n                parser.state = S.ATTRIB;\n              }\n            }\n\n            continue;\n\n          case S.ATTRIB_VALUE:\n            if (isWhitespace(c)) {\n              continue;\n            } else if (isQuote(c)) {\n              parser.q = c;\n              parser.state = S.ATTRIB_VALUE_QUOTED;\n            } else {\n              strictFail(parser, 'Unquoted attribute value');\n              parser.state = S.ATTRIB_VALUE_UNQUOTED;\n              parser.attribValue = c;\n            }\n\n            continue;\n\n          case S.ATTRIB_VALUE_QUOTED:\n            if (c !== parser.q) {\n              if (c === '&') {\n                parser.state = S.ATTRIB_VALUE_ENTITY_Q;\n              } else {\n                parser.attribValue += c;\n              }\n\n              continue;\n            }\n\n            attrib(parser);\n            parser.q = '';\n            parser.state = S.ATTRIB_VALUE_CLOSED;\n            continue;\n\n          case S.ATTRIB_VALUE_CLOSED:\n            if (isWhitespace(c)) {\n              parser.state = S.ATTRIB;\n            } else if (c === '>') {\n              openTag(parser);\n            } else if (c === '/') {\n              parser.state = S.OPEN_TAG_SLASH;\n            } else if (isMatch(nameStart, c)) {\n              strictFail(parser, 'No whitespace between attributes');\n              parser.attribName = c;\n              parser.attribValue = '';\n              parser.state = S.ATTRIB_NAME;\n            } else {\n              strictFail(parser, 'Invalid attribute name');\n            }\n\n            continue;\n\n          case S.ATTRIB_VALUE_UNQUOTED:\n            if (!isAttribEnd(c)) {\n              if (c === '&') {\n                parser.state = S.ATTRIB_VALUE_ENTITY_U;\n              } else {\n                parser.attribValue += c;\n              }\n\n              continue;\n            }\n\n            attrib(parser);\n\n            if (c === '>') {\n              openTag(parser);\n            } else {\n              parser.state = S.ATTRIB;\n            }\n\n            continue;\n\n          case S.CLOSE_TAG:\n            if (!parser.tagName) {\n              if (isWhitespace(c)) {\n                continue;\n              } else if (notMatch(nameStart, c)) {\n                if (parser.script) {\n                  parser.script += '</' + c;\n                  parser.state = S.SCRIPT;\n                } else {\n                  strictFail(parser, 'Invalid tagname in closing tag.');\n                }\n              } else {\n                parser.tagName = c;\n              }\n            } else if (c === '>') {\n              closeTag(parser);\n            } else if (isMatch(nameBody, c)) {\n              parser.tagName += c;\n            } else if (parser.script) {\n              parser.script += '</' + parser.tagName;\n              parser.tagName = '';\n              parser.state = S.SCRIPT;\n            } else {\n              if (!isWhitespace(c)) {\n                strictFail(parser, 'Invalid tagname in closing tag');\n              }\n\n              parser.state = S.CLOSE_TAG_SAW_WHITE;\n            }\n\n            continue;\n\n          case S.CLOSE_TAG_SAW_WHITE:\n            if (isWhitespace(c)) {\n              continue;\n            }\n\n            if (c === '>') {\n              closeTag(parser);\n            } else {\n              strictFail(parser, 'Invalid characters in closing tag');\n            }\n\n            continue;\n\n          case S.TEXT_ENTITY:\n          case S.ATTRIB_VALUE_ENTITY_Q:\n          case S.ATTRIB_VALUE_ENTITY_U:\n            var returnState;\n            var buffer;\n\n            switch (parser.state) {\n              case S.TEXT_ENTITY:\n                returnState = S.TEXT;\n                buffer = 'textNode';\n                break;\n\n              case S.ATTRIB_VALUE_ENTITY_Q:\n                returnState = S.ATTRIB_VALUE_QUOTED;\n                buffer = 'attribValue';\n                break;\n\n              case S.ATTRIB_VALUE_ENTITY_U:\n                returnState = S.ATTRIB_VALUE_UNQUOTED;\n                buffer = 'attribValue';\n                break;\n            }\n\n            if (c === ';') {\n              parser[buffer] += parseEntity(parser);\n              parser.entity = '';\n              parser.state = returnState;\n            } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {\n              parser.entity += c;\n            } else {\n              strictFail(parser, 'Invalid character in entity name');\n              parser[buffer] += '&' + parser.entity + c;\n              parser.entity = '';\n              parser.state = returnState;\n            }\n\n            continue;\n\n          default:\n            throw new Error(parser, 'Unknown state: ' + parser.state);\n        }\n      } // while\n\n\n      if (parser.position >= parser.bufferCheckPosition) {\n        checkBufferLength(parser);\n      }\n\n      return parser;\n    }\n    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */\n\n    /* istanbul ignore next */\n\n\n    if (!String.fromCodePoint) {\n      (function () {\n        var stringFromCharCode = String.fromCharCode;\n        var floor = Math.floor;\n\n        var fromCodePoint = function fromCodePoint() {\n          var MAX_SIZE = 0x4000;\n          var codeUnits = [];\n          var highSurrogate;\n          var lowSurrogate;\n          var index = -1;\n          var length = arguments.length;\n\n          if (!length) {\n            return '';\n          }\n\n          var result = '';\n\n          while (++index < length) {\n            var codePoint = Number(arguments[index]);\n\n            if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n            codePoint < 0 || // not a valid Unicode code point\n            codePoint > 0x10FFFF || // not a valid Unicode code point\n            floor(codePoint) !== codePoint // not an integer\n            ) {\n                throw RangeError('Invalid code point: ' + codePoint);\n              }\n\n            if (codePoint <= 0xFFFF) {\n              // BMP code point\n              codeUnits.push(codePoint);\n            } else {\n              // Astral code point; split in surrogate halves\n              // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n              codePoint -= 0x10000;\n              highSurrogate = (codePoint >> 10) + 0xD800;\n              lowSurrogate = codePoint % 0x400 + 0xDC00;\n              codeUnits.push(highSurrogate, lowSurrogate);\n            }\n\n            if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n              result += stringFromCharCode.apply(null, codeUnits);\n              codeUnits.length = 0;\n            }\n          }\n\n          return result;\n        };\n        /* istanbul ignore next */\n\n\n        if (Object.defineProperty) {\n          Object.defineProperty(String, 'fromCodePoint', {\n            value: fromCodePoint,\n            configurable: true,\n            writable: true\n          });\n        } else {\n          String.fromCodePoint = fromCodePoint;\n        }\n      })();\n    }\n  })( exports);\n});\n\nvar arrayHelper = {\n  isArray: function isArray(value) {\n    if (Array.isArray) {\n      return Array.isArray(value);\n    } // fallback for older browsers like  IE 8\n\n\n    return Object.prototype.toString.call(value) === '[object Array]';\n  }\n};\n\nvar isArray = arrayHelper.isArray;\nvar optionsHelper = {\n  copyOptions: function copyOptions(options) {\n    var key,\n        copy = {};\n\n    for (key in options) {\n      if (options.hasOwnProperty(key)) {\n        copy[key] = options[key];\n      }\n    }\n\n    return copy;\n  },\n  ensureFlagExists: function ensureFlagExists(item, options) {\n    if (!(item in options) || typeof options[item] !== 'boolean') {\n      options[item] = false;\n    }\n  },\n  ensureSpacesExists: function ensureSpacesExists(options) {\n    if (!('spaces' in options) || typeof options.spaces !== 'number' && typeof options.spaces !== 'string') {\n      options.spaces = 0;\n    }\n  },\n  ensureAlwaysArrayExists: function ensureAlwaysArrayExists(options) {\n    if (!('alwaysArray' in options) || typeof options.alwaysArray !== 'boolean' && !isArray(options.alwaysArray)) {\n      options.alwaysArray = false;\n    }\n  },\n  ensureKeyExists: function ensureKeyExists(key, options) {\n    if (!(key + 'Key' in options) || typeof options[key + 'Key'] !== 'string') {\n      options[key + 'Key'] = options.compact ? '_' + key : key;\n    }\n  },\n  checkFnExists: function checkFnExists(key, options) {\n    return key + 'Fn' in options;\n  }\n};\n\nvar isArray$1 = arrayHelper.isArray;\nvar options;\nvar currentElement;\n\nfunction validateOptions(userOptions) {\n  options = optionsHelper.copyOptions(userOptions);\n  optionsHelper.ensureFlagExists('ignoreDeclaration', options);\n  optionsHelper.ensureFlagExists('ignoreInstruction', options);\n  optionsHelper.ensureFlagExists('ignoreAttributes', options);\n  optionsHelper.ensureFlagExists('ignoreText', options);\n  optionsHelper.ensureFlagExists('ignoreComment', options);\n  optionsHelper.ensureFlagExists('ignoreCdata', options);\n  optionsHelper.ensureFlagExists('ignoreDoctype', options);\n  optionsHelper.ensureFlagExists('compact', options);\n  optionsHelper.ensureFlagExists('alwaysChildren', options);\n  optionsHelper.ensureFlagExists('addParent', options);\n  optionsHelper.ensureFlagExists('trim', options);\n  optionsHelper.ensureFlagExists('nativeType', options);\n  optionsHelper.ensureFlagExists('nativeTypeAttributes', options);\n  optionsHelper.ensureFlagExists('sanitize', options);\n  optionsHelper.ensureFlagExists('instructionHasAttributes', options);\n  optionsHelper.ensureFlagExists('captureSpacesBetweenElements', options);\n  optionsHelper.ensureAlwaysArrayExists(options);\n  optionsHelper.ensureKeyExists('declaration', options);\n  optionsHelper.ensureKeyExists('instruction', options);\n  optionsHelper.ensureKeyExists('attributes', options);\n  optionsHelper.ensureKeyExists('text', options);\n  optionsHelper.ensureKeyExists('comment', options);\n  optionsHelper.ensureKeyExists('cdata', options);\n  optionsHelper.ensureKeyExists('doctype', options);\n  optionsHelper.ensureKeyExists('type', options);\n  optionsHelper.ensureKeyExists('name', options);\n  optionsHelper.ensureKeyExists('elements', options);\n  optionsHelper.ensureKeyExists('parent', options);\n  optionsHelper.checkFnExists('doctype', options);\n  optionsHelper.checkFnExists('instruction', options);\n  optionsHelper.checkFnExists('cdata', options);\n  optionsHelper.checkFnExists('comment', options);\n  optionsHelper.checkFnExists('text', options);\n  optionsHelper.checkFnExists('instructionName', options);\n  optionsHelper.checkFnExists('elementName', options);\n  optionsHelper.checkFnExists('attributeName', options);\n  optionsHelper.checkFnExists('attributeValue', options);\n  optionsHelper.checkFnExists('attributes', options);\n  return options;\n}\n\nfunction nativeType(value) {\n  var nValue = Number(value);\n\n  if (!isNaN(nValue)) {\n    return nValue;\n  }\n\n  var bValue = value.toLowerCase();\n\n  if (bValue === 'true') {\n    return true;\n  } else if (bValue === 'false') {\n    return false;\n  }\n\n  return value;\n}\n\nfunction addField(type, value) {\n  var key;\n\n  if (options.compact) {\n    if (!currentElement[options[type + 'Key']] && (isArray$1(options.alwaysArray) ? options.alwaysArray.indexOf(options[type + 'Key']) !== -1 : options.alwaysArray)) {\n      currentElement[options[type + 'Key']] = [];\n    }\n\n    if (currentElement[options[type + 'Key']] && !isArray$1(currentElement[options[type + 'Key']])) {\n      currentElement[options[type + 'Key']] = [currentElement[options[type + 'Key']]];\n    }\n\n    if (type + 'Fn' in options && typeof value === 'string') {\n      value = options[type + 'Fn'](value, currentElement);\n    }\n\n    if (type === 'instruction' && ('instructionFn' in options || 'instructionNameFn' in options)) {\n      for (key in value) {\n        if (value.hasOwnProperty(key)) {\n          if ('instructionFn' in options) {\n            value[key] = options.instructionFn(value[key], key, currentElement);\n          } else {\n            var temp = value[key];\n            delete value[key];\n            value[options.instructionNameFn(key, temp, currentElement)] = temp;\n          }\n        }\n      }\n    }\n\n    if (isArray$1(currentElement[options[type + 'Key']])) {\n      currentElement[options[type + 'Key']].push(value);\n    } else {\n      currentElement[options[type + 'Key']] = value;\n    }\n  } else {\n    if (!currentElement[options.elementsKey]) {\n      currentElement[options.elementsKey] = [];\n    }\n\n    var element = {};\n    element[options.typeKey] = type;\n\n    if (type === 'instruction') {\n      for (key in value) {\n        if (value.hasOwnProperty(key)) {\n          break;\n        }\n      }\n\n      element[options.nameKey] = 'instructionNameFn' in options ? options.instructionNameFn(key, value, currentElement) : key;\n\n      if (options.instructionHasAttributes) {\n        element[options.attributesKey] = value[key][options.attributesKey];\n\n        if ('instructionFn' in options) {\n          element[options.attributesKey] = options.instructionFn(element[options.attributesKey], key, currentElement);\n        }\n      } else {\n        if ('instructionFn' in options) {\n          value[key] = options.instructionFn(value[key], key, currentElement);\n        }\n\n        element[options.instructionKey] = value[key];\n      }\n    } else {\n      if (type + 'Fn' in options) {\n        value = options[type + 'Fn'](value, currentElement);\n      }\n\n      element[options[type + 'Key']] = value;\n    }\n\n    if (options.addParent) {\n      element[options.parentKey] = currentElement;\n    }\n\n    currentElement[options.elementsKey].push(element);\n  }\n}\n\nfunction manipulateAttributes(attributes) {\n  if ('attributesFn' in options && attributes) {\n    attributes = options.attributesFn(attributes, currentElement);\n  }\n\n  if ((options.trim || 'attributeValueFn' in options || 'attributeNameFn' in options || options.nativeTypeAttributes) && attributes) {\n    var key;\n\n    for (key in attributes) {\n      if (attributes.hasOwnProperty(key)) {\n        if (options.trim) attributes[key] = attributes[key].trim();\n\n        if (options.nativeTypeAttributes) {\n          attributes[key] = nativeType(attributes[key]);\n        }\n\n        if ('attributeValueFn' in options) attributes[key] = options.attributeValueFn(attributes[key], key, currentElement);\n\n        if ('attributeNameFn' in options) {\n          var temp = attributes[key];\n          delete attributes[key];\n          attributes[options.attributeNameFn(key, attributes[key], currentElement)] = temp;\n        }\n      }\n    }\n  }\n\n  return attributes;\n}\n\nfunction onInstruction(instruction) {\n  var attributes = {};\n\n  if (instruction.body && (instruction.name.toLowerCase() === 'xml' || options.instructionHasAttributes)) {\n    var attrsRegExp = /([\\w:-]+)\\s*=\\s*(?:\"([^\"]*)\"|'([^']*)'|(\\w+))\\s*/g;\n    var match;\n\n    while ((match = attrsRegExp.exec(instruction.body)) !== null) {\n      attributes[match[1]] = match[2] || match[3] || match[4];\n    }\n\n    attributes = manipulateAttributes(attributes);\n  }\n\n  if (instruction.name.toLowerCase() === 'xml') {\n    if (options.ignoreDeclaration) {\n      return;\n    }\n\n    currentElement[options.declarationKey] = {};\n\n    if (Object.keys(attributes).length) {\n      currentElement[options.declarationKey][options.attributesKey] = attributes;\n    }\n\n    if (options.addParent) {\n      currentElement[options.declarationKey][options.parentKey] = currentElement;\n    }\n  } else {\n    if (options.ignoreInstruction) {\n      return;\n    }\n\n    if (options.trim) {\n      instruction.body = instruction.body.trim();\n    }\n\n    var value = {};\n\n    if (options.instructionHasAttributes && Object.keys(attributes).length) {\n      value[instruction.name] = {};\n      value[instruction.name][options.attributesKey] = attributes;\n    } else {\n      value[instruction.name] = instruction.body;\n    }\n\n    addField('instruction', value);\n  }\n}\n\nfunction onStartElement(name, attributes) {\n  var element;\n\n  if (_typeof(name) === 'object') {\n    attributes = name.attributes;\n    name = name.name;\n  }\n\n  attributes = manipulateAttributes(attributes);\n\n  if ('elementNameFn' in options) {\n    name = options.elementNameFn(name, currentElement);\n  }\n\n  if (options.compact) {\n    element = {};\n\n    if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {\n      element[options.attributesKey] = {};\n      var key;\n\n      for (key in attributes) {\n        if (attributes.hasOwnProperty(key)) {\n          element[options.attributesKey][key] = attributes[key];\n        }\n      }\n    }\n\n    if (!(name in currentElement) && (isArray$1(options.alwaysArray) ? options.alwaysArray.indexOf(name) !== -1 : options.alwaysArray)) {\n      currentElement[name] = [];\n    }\n\n    if (currentElement[name] && !isArray$1(currentElement[name])) {\n      currentElement[name] = [currentElement[name]];\n    }\n\n    if (isArray$1(currentElement[name])) {\n      currentElement[name].push(element);\n    } else {\n      currentElement[name] = element;\n    }\n  } else {\n    if (!currentElement[options.elementsKey]) {\n      currentElement[options.elementsKey] = [];\n    }\n\n    element = {};\n    element[options.typeKey] = 'element';\n    element[options.nameKey] = name;\n\n    if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {\n      element[options.attributesKey] = attributes;\n    }\n\n    if (options.alwaysChildren) {\n      element[options.elementsKey] = [];\n    }\n\n    currentElement[options.elementsKey].push(element);\n  }\n\n  element[options.parentKey] = currentElement; // will be deleted in onEndElement() if !options.addParent\n\n  currentElement = element;\n}\n\nfunction onText(text) {\n  if (options.ignoreText) {\n    return;\n  }\n\n  if (!text.trim() && !options.captureSpacesBetweenElements) {\n    return;\n  }\n\n  if (options.trim) {\n    text = text.trim();\n  }\n\n  if (options.nativeType) {\n    text = nativeType(text);\n  }\n\n  if (options.sanitize) {\n    text = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n  }\n\n  addField('text', text);\n}\n\nfunction onComment(comment) {\n  if (options.ignoreComment) {\n    return;\n  }\n\n  if (options.trim) {\n    comment = comment.trim();\n  }\n\n  addField('comment', comment);\n}\n\nfunction onEndElement(name) {\n  var parentElement = currentElement[options.parentKey];\n\n  if (!options.addParent) {\n    delete currentElement[options.parentKey];\n  }\n\n  currentElement = parentElement;\n}\n\nfunction onCdata(cdata) {\n  if (options.ignoreCdata) {\n    return;\n  }\n\n  if (options.trim) {\n    cdata = cdata.trim();\n  }\n\n  addField('cdata', cdata);\n}\n\nfunction onDoctype(doctype) {\n  if (options.ignoreDoctype) {\n    return;\n  }\n\n  doctype = doctype.replace(/^ /, '');\n\n  if (options.trim) {\n    doctype = doctype.trim();\n  }\n\n  addField('doctype', doctype);\n}\n\nfunction onError(error) {\n  error.note = error; //console.error(error);\n}\n\nvar xml2js = function xml2js(xml, userOptions) {\n  var parser =  sax.parser(true, {}) ;\n  var result = {};\n  currentElement = result;\n  options = validateOptions(userOptions);\n\n  {\n    parser.opt = {\n      strictEntities: true\n    };\n    parser.onopentag = onStartElement;\n    parser.ontext = onText;\n    parser.oncomment = onComment;\n    parser.onclosetag = onEndElement;\n    parser.onerror = onError;\n    parser.oncdata = onCdata;\n    parser.ondoctype = onDoctype;\n    parser.onprocessinginstruction = onInstruction;\n  }\n\n  {\n    parser.write(xml).close();\n  }\n\n  if (result[options.elementsKey]) {\n    var temp = result[options.elementsKey];\n    delete result[options.elementsKey];\n    result[options.elementsKey] = temp;\n    delete result.text;\n  }\n\n  return result;\n};\n\nfunction validateOptions$1(userOptions) {\n  var options = optionsHelper.copyOptions(userOptions);\n  optionsHelper.ensureSpacesExists(options);\n  return options;\n}\n\nvar xml2json = function xml2json(xml, userOptions) {\n  var options, js, json, parentKey;\n  options = validateOptions$1(userOptions);\n  js = xml2js(xml, options);\n  parentKey = 'compact' in options && options.compact ? '_parent' : 'parent'; // parentKey = ptions.compact ? '_parent' : 'parent'; // consider this\n\n  if ('addParent' in options && options.addParent) {\n    json = JSON.stringify(js, function (k, v) {\n      return k === parentKey ? '_' : v;\n    }, options.spaces);\n  } else {\n    json = JSON.stringify(js, null, options.spaces);\n  }\n\n  return json.replace(/\\u2028/g, \"\\\\u2028\").replace(/\\u2029/g, \"\\\\u2029\");\n};\n\nvar isArray$2 = arrayHelper.isArray;\nvar currentElement$1, currentElementName;\n\nfunction validateOptions$2(userOptions) {\n  var options = optionsHelper.copyOptions(userOptions);\n  optionsHelper.ensureFlagExists('ignoreDeclaration', options);\n  optionsHelper.ensureFlagExists('ignoreInstruction', options);\n  optionsHelper.ensureFlagExists('ignoreAttributes', options);\n  optionsHelper.ensureFlagExists('ignoreText', options);\n  optionsHelper.ensureFlagExists('ignoreComment', options);\n  optionsHelper.ensureFlagExists('ignoreCdata', options);\n  optionsHelper.ensureFlagExists('ignoreDoctype', options);\n  optionsHelper.ensureFlagExists('compact', options);\n  optionsHelper.ensureFlagExists('indentText', options);\n  optionsHelper.ensureFlagExists('indentCdata', options);\n  optionsHelper.ensureFlagExists('indentAttributes', options);\n  optionsHelper.ensureFlagExists('indentInstruction', options);\n  optionsHelper.ensureFlagExists('fullTagEmptyElement', options);\n  optionsHelper.ensureFlagExists('noQuotesForNativeAttributes', options);\n  optionsHelper.ensureSpacesExists(options);\n\n  if (typeof options.spaces === 'number') {\n    options.spaces = Array(options.spaces + 1).join(' ');\n  }\n\n  optionsHelper.ensureKeyExists('declaration', options);\n  optionsHelper.ensureKeyExists('instruction', options);\n  optionsHelper.ensureKeyExists('attributes', options);\n  optionsHelper.ensureKeyExists('text', options);\n  optionsHelper.ensureKeyExists('comment', options);\n  optionsHelper.ensureKeyExists('cdata', options);\n  optionsHelper.ensureKeyExists('doctype', options);\n  optionsHelper.ensureKeyExists('type', options);\n  optionsHelper.ensureKeyExists('name', options);\n  optionsHelper.ensureKeyExists('elements', options);\n  optionsHelper.checkFnExists('doctype', options);\n  optionsHelper.checkFnExists('instruction', options);\n  optionsHelper.checkFnExists('cdata', options);\n  optionsHelper.checkFnExists('comment', options);\n  optionsHelper.checkFnExists('text', options);\n  optionsHelper.checkFnExists('instructionName', options);\n  optionsHelper.checkFnExists('elementName', options);\n  optionsHelper.checkFnExists('attributeName', options);\n  optionsHelper.checkFnExists('attributeValue', options);\n  optionsHelper.checkFnExists('attributes', options);\n  optionsHelper.checkFnExists('fullTagEmptyElement', options);\n  return options;\n}\n\nfunction writeIndentation(options, depth, firstLine) {\n  return (!firstLine && options.spaces ? '\\n' : '') + Array(depth + 1).join(options.spaces);\n}\n\nfunction writeAttributes(attributes, options, depth) {\n  if (options.ignoreAttributes) {\n    return '';\n  }\n\n  if ('attributesFn' in options) {\n    attributes = options.attributesFn(attributes, currentElementName, currentElement$1);\n  }\n\n  var key,\n      attr,\n      attrName,\n      quote,\n      result = [];\n\n  for (key in attributes) {\n    if (attributes.hasOwnProperty(key) && attributes[key] !== null && attributes[key] !== undefined) {\n      quote = options.noQuotesForNativeAttributes && typeof attributes[key] !== 'string' ? '' : '\"';\n      attr = '' + attributes[key]; // ensure number and boolean are converted to String\n\n      attr = attr.replace(/\"/g, '&quot;');\n      attrName = 'attributeNameFn' in options ? options.attributeNameFn(key, attr, currentElementName, currentElement$1) : key;\n      result.push(options.spaces && options.indentAttributes ? writeIndentation(options, depth + 1, false) : ' ');\n      result.push(attrName + '=' + quote + ('attributeValueFn' in options ? options.attributeValueFn(attr, key, currentElementName, currentElement$1) : attr) + quote);\n    }\n  }\n\n  if (attributes && Object.keys(attributes).length && options.spaces && options.indentAttributes) {\n    result.push(writeIndentation(options, depth, false));\n  }\n\n  return result.join('');\n}\n\nfunction writeDeclaration(declaration, options, depth) {\n  currentElement$1 = declaration;\n  currentElementName = 'xml';\n  return options.ignoreDeclaration ? '' : '<?' + 'xml' + writeAttributes(declaration[options.attributesKey], options, depth) + '?>';\n}\n\nfunction writeInstruction(instruction, options, depth) {\n  if (options.ignoreInstruction) {\n    return '';\n  }\n\n  var key;\n\n  for (key in instruction) {\n    if (instruction.hasOwnProperty(key)) {\n      break;\n    }\n  }\n\n  var instructionName = 'instructionNameFn' in options ? options.instructionNameFn(key, instruction[key], currentElementName, currentElement$1) : key;\n\n  if (_typeof(instruction[key]) === 'object') {\n    currentElement$1 = instruction;\n    currentElementName = instructionName;\n    return '<?' + instructionName + writeAttributes(instruction[key][options.attributesKey], options, depth) + '?>';\n  } else {\n    var instructionValue = instruction[key] ? instruction[key] : '';\n    if ('instructionFn' in options) instructionValue = options.instructionFn(instructionValue, key, currentElementName, currentElement$1);\n    return '<?' + instructionName + (instructionValue ? ' ' + instructionValue : '') + '?>';\n  }\n}\n\nfunction writeComment(comment, options) {\n  return options.ignoreComment ? '' : '<!--' + ('commentFn' in options ? options.commentFn(comment, currentElementName, currentElement$1) : comment) + '-->';\n}\n\nfunction writeCdata(cdata, options) {\n  return options.ignoreCdata ? '' : '<![CDATA[' + ('cdataFn' in options ? options.cdataFn(cdata, currentElementName, currentElement$1) : cdata.replace(']]>', ']]]]><![CDATA[>')) + ']]>';\n}\n\nfunction writeDoctype(doctype, options) {\n  return options.ignoreDoctype ? '' : '<!DOCTYPE ' + ('doctypeFn' in options ? options.doctypeFn(doctype, currentElementName, currentElement$1) : doctype) + '>';\n}\n\nfunction writeText(text, options) {\n  if (options.ignoreText) return '';\n  text = '' + text; // ensure Number and Boolean are converted to String\n\n  text = text.replace(/&amp;/g, '&'); // desanitize to avoid double sanitization\n\n  text = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n  return 'textFn' in options ? options.textFn(text, currentElementName, currentElement$1) : text;\n}\n\nfunction hasContent(element, options) {\n  var i;\n\n  if (element.elements && element.elements.length) {\n    for (i = 0; i < element.elements.length; ++i) {\n      switch (element.elements[i][options.typeKey]) {\n        case 'text':\n          if (options.indentText) {\n            return true;\n          }\n\n          break;\n        // skip to next key\n\n        case 'cdata':\n          if (options.indentCdata) {\n            return true;\n          }\n\n          break;\n        // skip to next key\n\n        case 'instruction':\n          if (options.indentInstruction) {\n            return true;\n          }\n\n          break;\n        // skip to next key\n\n        case 'doctype':\n        case 'comment':\n        case 'element':\n          return true;\n\n        default:\n          return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction writeElement(element, options, depth) {\n  currentElement$1 = element;\n  currentElementName = element.name;\n  var xml = [],\n      elementName = 'elementNameFn' in options ? options.elementNameFn(element.name, element) : element.name;\n  xml.push('<' + elementName);\n\n  if (element[options.attributesKey]) {\n    xml.push(writeAttributes(element[options.attributesKey], options, depth));\n  }\n\n  var withClosingTag = element[options.elementsKey] && element[options.elementsKey].length || element[options.attributesKey] && element[options.attributesKey]['xml:space'] === 'preserve';\n\n  if (!withClosingTag) {\n    if ('fullTagEmptyElementFn' in options) {\n      withClosingTag = options.fullTagEmptyElementFn(element.name, element);\n    } else {\n      withClosingTag = options.fullTagEmptyElement;\n    }\n  }\n\n  if (withClosingTag) {\n    xml.push('>');\n\n    if (element[options.elementsKey] && element[options.elementsKey].length) {\n      xml.push(writeElements(element[options.elementsKey], options, depth + 1));\n      currentElement$1 = element;\n      currentElementName = element.name;\n    }\n\n    xml.push(options.spaces && hasContent(element, options) ? '\\n' + Array(depth + 1).join(options.spaces) : '');\n    xml.push('</' + elementName + '>');\n  } else {\n    xml.push('/>');\n  }\n\n  return xml.join('');\n}\n\nfunction writeElements(elements, options, depth, firstLine) {\n  return elements.reduce(function (xml, element) {\n    var indent = writeIndentation(options, depth, firstLine && !xml);\n\n    switch (element.type) {\n      case 'element':\n        return xml + indent + writeElement(element, options, depth);\n\n      case 'comment':\n        return xml + indent + writeComment(element[options.commentKey], options);\n\n      case 'doctype':\n        return xml + indent + writeDoctype(element[options.doctypeKey], options);\n\n      case 'cdata':\n        return xml + (options.indentCdata ? indent : '') + writeCdata(element[options.cdataKey], options);\n\n      case 'text':\n        return xml + (options.indentText ? indent : '') + writeText(element[options.textKey], options);\n\n      case 'instruction':\n        var instruction = {};\n        instruction[element[options.nameKey]] = element[options.attributesKey] ? element : element[options.instructionKey];\n        return xml + (options.indentInstruction ? indent : '') + writeInstruction(instruction, options, depth);\n    }\n  }, '');\n}\n\nfunction hasContentCompact(element, options, anyContent) {\n  var key;\n\n  for (key in element) {\n    if (element.hasOwnProperty(key)) {\n      switch (key) {\n        case options.parentKey:\n        case options.attributesKey:\n          break;\n        // skip to next key\n\n        case options.textKey:\n          if (options.indentText || anyContent) {\n            return true;\n          }\n\n          break;\n        // skip to next key\n\n        case options.cdataKey:\n          if (options.indentCdata || anyContent) {\n            return true;\n          }\n\n          break;\n        // skip to next key\n\n        case options.instructionKey:\n          if (options.indentInstruction || anyContent) {\n            return true;\n          }\n\n          break;\n        // skip to next key\n\n        case options.doctypeKey:\n        case options.commentKey:\n          return true;\n\n        default:\n          return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction writeElementCompact(element, name, options, depth, indent) {\n  currentElement$1 = element;\n  currentElementName = name;\n  var elementName = 'elementNameFn' in options ? options.elementNameFn(name, element) : name;\n\n  if (typeof element === 'undefined' || element === null || element === '') {\n    return 'fullTagEmptyElementFn' in options && options.fullTagEmptyElementFn(name, element) || options.fullTagEmptyElement ? '<' + elementName + '></' + elementName + '>' : '<' + elementName + '/>';\n  }\n\n  var xml = [];\n\n  if (name) {\n    xml.push('<' + elementName);\n\n    if (_typeof(element) !== 'object') {\n      xml.push('>' + writeText(element, options) + '</' + elementName + '>');\n      return xml.join('');\n    }\n\n    if (element[options.attributesKey]) {\n      xml.push(writeAttributes(element[options.attributesKey], options, depth));\n    }\n\n    var withClosingTag = hasContentCompact(element, options, true) || element[options.attributesKey] && element[options.attributesKey]['xml:space'] === 'preserve';\n\n    if (!withClosingTag) {\n      if ('fullTagEmptyElementFn' in options) {\n        withClosingTag = options.fullTagEmptyElementFn(name, element);\n      } else {\n        withClosingTag = options.fullTagEmptyElement;\n      }\n    }\n\n    if (withClosingTag) {\n      xml.push('>');\n    } else {\n      xml.push('/>');\n      return xml.join('');\n    }\n  }\n\n  xml.push(writeElementsCompact(element, options, depth + 1, false));\n  currentElement$1 = element;\n  currentElementName = name;\n\n  if (name) {\n    xml.push((indent ? writeIndentation(options, depth, false) : '') + '</' + elementName + '>');\n  }\n\n  return xml.join('');\n}\n\nfunction writeElementsCompact(element, options, depth, firstLine) {\n  var i,\n      key,\n      nodes,\n      xml = [];\n\n  for (key in element) {\n    if (element.hasOwnProperty(key)) {\n      nodes = isArray$2(element[key]) ? element[key] : [element[key]];\n\n      for (i = 0; i < nodes.length; ++i) {\n        switch (key) {\n          case options.declarationKey:\n            xml.push(writeDeclaration(nodes[i], options, depth));\n            break;\n\n          case options.instructionKey:\n            xml.push((options.indentInstruction ? writeIndentation(options, depth, firstLine) : '') + writeInstruction(nodes[i], options, depth));\n            break;\n\n          case options.attributesKey:\n          case options.parentKey:\n            break;\n          // skip\n\n          case options.textKey:\n            xml.push((options.indentText ? writeIndentation(options, depth, firstLine) : '') + writeText(nodes[i], options));\n            break;\n\n          case options.cdataKey:\n            xml.push((options.indentCdata ? writeIndentation(options, depth, firstLine) : '') + writeCdata(nodes[i], options));\n            break;\n\n          case options.doctypeKey:\n            xml.push(writeIndentation(options, depth, firstLine) + writeDoctype(nodes[i], options));\n            break;\n\n          case options.commentKey:\n            xml.push(writeIndentation(options, depth, firstLine) + writeComment(nodes[i], options));\n            break;\n\n          default:\n            xml.push(writeIndentation(options, depth, firstLine) + writeElementCompact(nodes[i], key, options, depth, hasContentCompact(nodes[i], options)));\n        }\n\n        firstLine = firstLine && !xml.length;\n      }\n    }\n  }\n\n  return xml.join('');\n}\n\nvar js2xml = function js2xml(js, options) {\n  options = validateOptions$2(options);\n  var xml = [];\n  currentElement$1 = js;\n  currentElementName = '_root_';\n\n  if (options.compact) {\n    xml.push(writeElementsCompact(js, options, 0, true));\n  } else {\n    if (js[options.declarationKey]) {\n      xml.push(writeDeclaration(js[options.declarationKey], options, 0));\n    }\n\n    if (js[options.elementsKey] && js[options.elementsKey].length) {\n      xml.push(writeElements(js[options.elementsKey], options, 0, !xml.length));\n    }\n  }\n\n  return xml.join('');\n};\n\nvar json2xml = function json2xml(json, options) {\n  if (json instanceof Buffer) {\n    json = json.toString();\n  }\n\n  var js = null;\n\n  if (typeof json === 'string') {\n    try {\n      js = JSON.parse(json);\n    } catch (e) {\n      throw new Error('The JSON structure is invalid');\n    }\n  } else {\n    js = json;\n  }\n\n  return js2xml(js, options);\n};\n\n/*jslint node:true */\n\nvar lib = {\n  xml2js: xml2js,\n  xml2json: xml2json,\n  js2xml: js2xml,\n  json2xml: json2xml\n};\n\nexport { commonjsGlobal as a, commonjsRequire as b, createCommonjsModule as c, lib as d, getCjsExportFromNamespace as g };\n"],"sourceRoot":""}