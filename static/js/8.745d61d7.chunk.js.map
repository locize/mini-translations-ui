{"version":3,"sources":["../../../node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js","../../../node_modules/@babel/runtime/helpers/esm/createSuper.js","../../../node_modules/@babel/runtime/helpers/esm/construct.js","../../../node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js","../../../node_modules/@babel/runtime/helpers/esm/isNativeFunction.js","../../file-fluent/dist/es/index-f22bddf0.js"],"names":["_isNativeReflectConstruct","Reflect","construct","sham","Proxy","Boolean","prototype","valueOf","call","e","_createSuper","Derived","hasNativeReflectConstruct","result","Super","NewTarget","this","constructor","arguments","apply","Parent","args","Class","isNativeReflectConstruct","a","push","instance","Function","bind","setPrototypeOf","_cache","Map","undefined","fn","toString","indexOf","TypeError","has","get","set","Wrapper","getPrototypeOf","Object","create","value","enumerable","writable","configurable","BaseNode","type","other","ignoredFields","thisKeys","Set","keys","otherKeys","fieldName","delete","size","thisVal","otherVal","Array","length","i","scalarsEqual","visit","clone","isArray","map","prop","equals","SyntaxNode","start","end","span","Span","Resource","body","Entry","Message","id","attributes","comment","Term","Pattern","elements","PatternElement","TextElement","Placeable","expression","Expression","Literal","StringLiteral","replace","match","codepoint4","codepoint6","codepoint","parseInt","String","fromCodePoint","NumberLiteral","parseFloat","decimalPos","precision","MessageReference","attribute","TermReference","VariableReference","FunctionReference","SelectExpression","selector","variants","CallArguments","positional","named","Attribute","Variant","key","def","default","NamedArgument","name","Identifier","BaseComment","content","Comment","GroupComment","ResourceComment","Junk","annotations","annotation","Annotation","code","message","ParseError","getErrorMessage","Error","token","range","char","sequence","ParserStream","string","index","peekOffset","offset","charAt","EOL","EOF","SPECIAL_LINE_START_CHARS","FluentParserStream","currentPeek","peek","slice","blank","peekBlankInline","skipToPeek","lineStart","resetPeek","peekBlankBlock","peekBlank","ch","currentChar","next","f","cc","charCodeAt","isCharIdStart","isDigit","includes","column1","isCharPatternContinuation","level","currentPeekOffset","junkStart","lastNewline","lastIndexOf","first","ret","takeChar","trailingWSRe","withSpan","ps","withSpans","node","addSpan","FluentParser","getComment","getMessage","getTerm","getAttribute","getIdentifier","getVariant","getNumber","getPattern","getTextElement","getPlaceable","getExpression","getInlineExpression","getCallArgument","getCallArguments","getString","getLiteral","source","skipBlankBlock","entries","lastComment","entry","getEntryOrJunk","blankLines","res","skipped","entryStartPos","getEntry","expectLineEnd","err","errorIndex","skipToNextEntryStart","nextEntryStart","substring","junk","annot","addAnnotation","isIdentifierStart","Comment$1","expectChar","x","isNextLineComment","skipBlankInline","maybeGetPattern","attrs","getAttributes","isAttributeStart","attr","takeIDStart","takeIDChar","hasDefault","defaultIndex","skipBlank","getVariantKey","isVariantStart","variant","num","takeDigit","getDigits","isValueStart","isValueContinuation","isBlock","commonIndentLength","blankStart","firstIndent","getIndent","Infinity","indent","Math","min","dedented","dedent","Indent","commonIndent","trimmed","element","prev","sum","textElement","lastElement","pop","buffer","getUnicodeEscapeSequence","u","digits","takeHexDigit","getVariants","isNumberStart","test","exp","argumentNames","arg","add","getEscapeSequence","parse","opts","getTypeName","item","serializer","serialize","console","warn","getGroupComment","getResourceComment","_this","_this2","concat","getStringLiteral","_this3","placeable","log","join","getCallExpression","_this4","fcName","callee","positionals","nameds","getNamedArgument","getSelectExpression","_this5","getVariantExpression","ref","getVariableReference","plain","getTermReferences","getVariantName","getVariantList","_this6","isDefault","getFunctionReference","forEach","p","n","getTermReference","getJunk","parts","split","shift","trim","ftlToJs","str","cb","params","respectComments","parsed","reduce","mem","segment","inner","val","addValue","k","ftl","js2ftl","resources","addComment","innerK","innerValue","ftl2js"],"mappings":"kHAAe,SAASA,IACtB,GAAuB,qBAAZC,UAA4BA,QAAQC,UAAW,OAAO,EACjE,GAAID,QAAQC,UAAUC,KAAM,OAAO,EACnC,GAAqB,oBAAVC,MAAsB,OAAO,EAExC,IAEE,OADAC,QAAQC,UAAUC,QAAQC,KAAKP,QAAQC,UAAUG,QAAS,IAAI,iBACvD,EACP,MAAOI,GACP,OAAO,GATX,mC,iCCAA,+DAGe,SAASC,EAAaC,GACnC,IAAIC,EAA4B,cAChC,OAAO,WACL,IACIC,EADAC,EAAQ,YAAeH,GAG3B,GAAIC,EAA2B,CAC7B,IAAIG,EAAY,YAAeC,MAAMC,YACrCJ,EAASZ,QAAQC,UAAUY,EAAOI,UAAWH,QAE7CF,EAASC,EAAMK,MAAMH,KAAME,WAG7B,OAAO,YAA0BF,KAAMH,M,oGCd5B,SAAS,EAAWO,EAAQC,EAAMC,GAc/C,OAZE,EADE,OAAAC,EAAA,KACWtB,QAAQC,UAER,SAAoBkB,EAAQC,EAAMC,GAC7C,IAAIE,EAAI,CAAC,MACTA,EAAEC,KAAKN,MAAMK,EAAGH,GAChB,IACIK,EAAW,IADGC,SAASC,KAAKT,MAAMC,EAAQI,IAG9C,OADIF,GAAO,OAAAO,EAAA,GAAeH,EAAUJ,EAAMhB,WACnCoB,GAIJ,EAAWP,MAAM,KAAMD,WCZjB,SAAS,EAAiBI,GACvC,IAAIQ,EAAwB,oBAARC,IAAqB,IAAIA,SAAQC,EA8BrD,OA5BA,EAAmB,SAA0BV,GAC3C,GAAc,OAAVA,ICRkCW,EDQEX,GCPsB,IAAzDK,SAASO,SAAS1B,KAAKyB,GAAIE,QAAQ,kBDOQ,OAAOb,ECR5C,IAA2BW,EDUtC,GAAqB,oBAAVX,EACT,MAAM,IAAIc,UAAU,sDAGtB,GAAsB,qBAAXN,EAAwB,CACjC,GAAIA,EAAOO,IAAIf,GAAQ,OAAOQ,EAAOQ,IAAIhB,GAEzCQ,EAAOS,IAAIjB,EAAOkB,GAGpB,SAASA,IACP,OAAO,EAAUlB,EAAOJ,UAAW,OAAAuB,EAAA,GAAezB,MAAMC,aAW1D,OARAuB,EAAQlC,UAAYoC,OAAOC,OAAOrB,EAAMhB,UAAW,CACjDW,YAAa,CACX2B,MAAOJ,EACPK,YAAY,EACZC,UAAU,EACVC,cAAc,KAGX,OAAAlB,EAAA,GAAeW,EAASlB,IAG1B,EAAiBA,K,sLE5BpB0B,E,WACF,aAAc,oBACVhC,KAAKiC,KAAO,W,0CAEhB,SAAOC,GAAiC,IAA1BC,EAA0B,uDAAV,CAAC,QACrBC,EAAW,IAAIC,IAAIX,OAAOY,KAAKtC,OAC/BuC,EAAY,IAAIF,IAAIX,OAAOY,KAAKJ,IACtC,GAAIC,EAAe,qBACSA,GADT,IACf,IAAK,EAAL,qBAAuC,KAA5BK,EAA4B,QACnCJ,EAASK,OAAOD,GAChBD,EAAUE,OAAOD,IAHN,+BAMnB,GAAIJ,EAASM,OAASH,EAAUG,KAC5B,OAAO,EAVyB,oBAYZN,GAZY,IAYpC,IAAK,EAAL,qBAAkC,KAAvBI,EAAuB,QAC9B,IAAKD,EAAUlB,IAAImB,GACf,OAAO,EAEX,IAAMG,EAAU3C,KAAKwC,GACfI,EAAWV,EAAMM,GACvB,UAAWG,WAAmBC,EAC1B,OAAO,EAEX,GAAID,aAAmBE,OAASD,aAAoBC,MAAO,CACvD,GAAIF,EAAQG,SAAWF,EAASE,OAC5B,OAAO,EAEX,IAAK,IAAIC,EAAI,EAAGA,EAAIJ,EAAQG,SAAUC,EAClC,IAAKC,EAAaL,EAAQI,GAAIH,EAASG,GAAIZ,GACvC,OAAO,OAId,IAAKa,EAAaL,EAASC,EAAUT,GACtC,OAAO,GAhCqB,8BAmCpC,OAAO,I,mBAEX,WACI,SAASc,EAAMrB,GACX,OAAIA,aAAiBI,EACVJ,EAAMsB,QAEbL,MAAMM,QAAQvB,GACPA,EAAMwB,IAAIH,GAEdrB,EAGX,IADA,IAAMsB,EAAQxB,OAAOC,OAAO3B,KAAKC,YAAYX,WAC7C,MAAmBoC,OAAOY,KAAKtC,MAA/B,eAAsC,CAAjC,IAAMqD,EAAI,KACXH,EAAMG,GAAQJ,EAAMjD,KAAKqD,IAE7B,OAAOH,M,KAGf,SAASF,EAAaL,EAASC,EAAUT,GACrC,OAAIQ,aAAmBX,GAAYY,aAAoBZ,EAC5CW,EAAQW,OAAOV,EAAUT,GAE7BQ,IAAYC,E,IAKjBW,E,kDACF,aAAc,kCACV,eAASrD,YACJ+B,KAAO,aAFF,E,2CAId,SAAQuB,EAAOC,GACXzD,KAAK0D,KAAO,IAAIC,EAAKH,EAAOC,O,GANXzB,GASnB4B,E,kDACF,aAAuB,MAAXC,EAAW,uDAAJ,GAAI,4BACnB,gBACK5B,KAAO,WACZ,EAAK4B,KAAOA,EAHO,E,uBADJN,GAUjBO,E,kDACF,aAAc,kCACV,eAAS5D,YACJ+B,KAAO,QAFF,E,uBADEsB,GAMdQ,E,kDACF,WAAYC,GAAmD,MAA/CpC,EAA+C,uDAAvC,KAAMqC,EAAiC,uDAApB,GAAIC,EAAgB,uDAAN,KAAM,4BAC3D,gBACKjC,KAAO,UACZ,EAAK+B,GAAKA,EACV,EAAKpC,MAAQA,EACb,EAAKqC,WAAaA,EAClB,EAAKC,QAAUA,EAN4C,E,uBAD7CJ,GAUhBK,E,kDACF,WAAYH,EAAIpC,GAAwC,MAAjCqC,EAAiC,uDAApB,GAAIC,EAAgB,uDAAN,KAAM,4BACpD,gBACKjC,KAAO,OACZ,EAAK+B,GAAKA,EACV,EAAKpC,MAAQA,EACb,EAAKqC,WAAaA,EAClB,EAAKC,QAAUA,EANqC,E,uBADzCJ,GAUbM,E,kDACF,WAAYC,GAAU,kCAClB,gBACKpC,KAAO,UACZ,EAAKoC,SAAWA,EAHE,E,uBADJd,GAUhBe,E,kDACF,aAAc,kCACV,eAASpE,YACJ+B,KAAO,iBAFF,E,uBADWsB,GAMvBgB,E,kDACF,WAAY3C,GAAO,kCACf,gBACKK,KAAO,cACZ,EAAKL,MAAQA,EAHE,E,uBADG0C,GAOpBE,E,kDACF,WAAYC,GAAY,kCACpB,gBACKxC,KAAO,YACZ,EAAKwC,WAAaA,EAHE,E,uBADJH,GAUlBI,E,kDACF,aAAc,kCACV,eAASxE,YACJ+B,KAAO,aAFF,E,uBADOsB,GAOnBoB,E,kDACF,WAAY/C,GAAO,kCACf,gBACKK,KAAO,UAGZ,EAAKL,MAAQA,EALE,E,uBADD8C,GAShBE,E,kDACF,aAAc,kCACV,eAAS1E,YACJ+B,KAAO,gBAFF,E,yCAId,WAuBI,MAAO,CAAEL,MADG5B,KAAK4B,MAAMiD,QApBD,yDACtB,SAA4BC,EAAOC,EAAYC,GAC3C,OAAQF,GACJ,IAAK,OACD,MAAO,KACX,IAAK,MACD,MAAO,IACX,QACI,IAAIG,EAAYC,SAASH,GAAcC,EAAY,IACnD,OAAIC,GAAa,OAAU,OAAUA,EAE1BE,OAAOC,cAAcH,GAKzB,kB,GAvBCN,GA+BtBU,E,kDACF,aAAc,kCACV,eAASnF,YACJ+B,KAAO,gBAFF,E,yCAId,WACI,IAAIL,EAAQ0D,WAAWtF,KAAK4B,OACxB2D,EAAavF,KAAK4B,MAAMT,QAAQ,KAIpC,MAAO,CAAES,QAAO4D,UAHAD,EAAa,EACvBvF,KAAK4B,MAAMkB,OAASyC,EAAa,EACjC,O,GAVcZ,GActBc,E,kDACF,WAAYzB,GAAsB,MAAlB0B,EAAkB,uDAAN,KAAM,4BAC9B,gBACKzD,KAAO,mBACZ,EAAK+B,GAAKA,EACV,EAAK0B,UAAYA,EAJa,E,uBADPhB,GAQzBiB,E,kDACF,WAAY3B,GAAmC,MAA/B0B,EAA+B,uDAAnB,KAAMrF,EAAa,uDAAN,KAAM,4BAC3C,gBACK4B,KAAO,gBACZ,EAAK+B,GAAKA,EACV,EAAK0B,UAAYA,EACjB,EAAKxF,UAAYG,EAL0B,E,uBADvBqE,GAStBkB,E,kDACF,WAAY5B,GAAI,kCACZ,gBACK/B,KAAO,oBACZ,EAAK+B,GAAKA,EAHE,E,uBADYU,GAO1BmB,E,kDACF,WAAY7B,EAAI3D,GAAM,kCAClB,gBACK4B,KAAO,oBACZ,EAAK+B,GAAKA,EACV,EAAK9D,UAAYG,EAJC,E,uBADMqE,GAQ1BoB,E,kDACF,WAAYC,EAAUC,GAAU,kCAC5B,gBACK/D,KAAO,mBACZ,EAAK8D,SAAWA,EAChB,EAAKC,SAAWA,EAJY,E,uBADLtB,GAQzBuB,E,kDACF,aAAyC,MAA7BC,EAA6B,uDAAhB,GAAIC,EAAY,uDAAJ,GAAI,4BACrC,gBACKlE,KAAO,gBACZ,EAAKiE,WAAaA,EAClB,EAAKC,MAAQA,EAJwB,E,uBADjB5C,GAQtB6C,E,kDACF,WAAYpC,EAAIpC,GAAO,kCACnB,gBACKK,KAAO,YACZ,EAAK+B,GAAKA,EACV,EAAKpC,MAAQA,EAJM,E,uBADH2B,GAQlB8C,E,kDACF,WAAYC,EAAK1E,EAAO2E,GAAK,kCACzB,gBACKtE,KAAO,UACZ,EAAKqE,IAAMA,EACX,EAAK1E,MAAQA,EACb,EAAK4E,QAAUD,EALU,E,uBADXhD,GAShBkD,E,kDACF,WAAYC,EAAM9E,GAAO,kCACrB,gBACKK,KAAO,gBACZ,EAAKyE,KAAOA,EACZ,EAAK9E,MAAQA,EAJQ,E,uBADD2B,GAQtBoD,E,kDACF,WAAYD,GAAM,kCACd,gBACKzE,KAAO,aACZ,EAAKyE,KAAOA,EAHE,E,uBADGnD,GAOnBqD,E,kDACF,WAAYC,GAAS,kCACjB,gBACK5E,KAAO,cACZ,EAAK4E,QAAUA,EAHE,E,uBADC/C,GAOpBgD,E,kDACF,aAAc,kCACV,eAAS5G,YACJ+B,KAAO,UAFF,E,uBADI2E,GAMhBG,E,kDACF,aAAc,kCACV,eAAS7G,YACJ+B,KAAO,eAFF,E,uBADS2E,GAMrBI,E,kDACF,aAAc,kCACV,eAAS9G,YACJ+B,KAAO,kBAFF,E,uBADY2E,GAMxBK,E,kDACF,WAAYJ,GAAS,kCACjB,gBACK5E,KAAO,OACZ,EAAKiF,YAAc,GACnB,EAAKL,QAAUA,EAJE,E,iDAMrB,SAAcM,GACVnH,KAAKkH,YAAYzG,KAAK0G,O,GARX5D,GAWbI,E,kDACF,WAAYH,EAAOC,GAAK,kCACpB,gBACKxB,KAAO,OACZ,EAAKuB,MAAQA,EACb,EAAKC,IAAMA,EAJS,E,uBADTzB,GAQboF,E,kDACF,WAAYC,GAA0B,MAApBhH,EAAoB,uDAAb,GAAIiH,EAAS,mEAClC,gBACKrF,KAAO,aACZ,EAAKoF,KAAOA,EACZ,EAAKnH,UAAYG,EACjB,EAAKiH,QAAUA,EALmB,E,uBADjB/D,GAUnBgE,E,kDACF,WAAYF,GAAe,2BACvB,gBACKA,KAAOA,EAFW,2BAANhH,EAAM,iCAANA,EAAM,yBAGvB,EAAKA,KAAOA,EACZ,EAAKiH,QAAUE,EAAgBH,EAAMhH,GAJd,E,mCADNoH,QASzB,SAASD,EAAgBH,EAAMhH,GAC3B,OAAQgH,GACJ,IAAK,QACD,MAAO,gBACX,IAAK,QACD,MAAO,0BACX,IAAK,QACD,IAAOK,EAAP,YAAgBrH,EAAhB,MACA,MAAO,oBAAP,OAA2BqH,EAA3B,KAEJ,IAAK,QACD,IAAOC,EAAP,YAAgBtH,EAAhB,MACA,MAAO,qCAAP,OAA4CsH,EAA5C,KAEJ,IAAK,QACD,IAAO3D,EAAP,YAAa3D,EAAb,MACA,MAAO,qBAAP,OAA4B2D,EAA5B,mCAEJ,IAAK,QACD,IAAOA,EAAP,YAAa3D,EAAb,MACA,MAAO,mBAAP,OAA0B2D,EAA1B,qBAEJ,IAAK,QACD,MAAO,uCACX,IAAK,QACD,MAAO,0DACX,IAAK,QACD,MAAO,kDACX,IAAK,QACD,MAAO,2DACX,IAAK,QACD,MAAO,2CACX,IAAK,QACD,MAAO,iBACX,IAAK,QACD,MAAO,uBACX,IAAK,QACD,MAAO,mBACX,IAAK,QACD,MAAO,gDACX,IAAK,QACD,MAAO,iDACX,IAAK,QACD,MAAO,oCACX,IAAK,QACD,MAAO,qDACX,IAAK,QACD,MAAO,mDACX,IAAK,QACD,MAAO,iCACX,IAAK,QACD,MAAO,uDACX,IAAK,QACD,MAAO,iCACX,IAAK,QACD,MAAO,uCACX,IAAK,QACD,IAAO4D,EAAP,YAAevH,EAAf,MACA,MAAO,8BAAP,OAAqCuH,EAArC,KAEJ,IAAK,QACD,IAAOC,EAAP,YAAmBxH,EAAnB,MACA,MAAO,oCAAP,OAA2CwH,EAA3C,KAEJ,IAAK,QACD,MAAO,2CACX,IAAK,QACD,MAAO,gCACX,IAAK,QACD,MAAO,yCACX,QACI,OAAOR,G,IAKbS,E,WACF,WAAYC,GAAQ,oBAChB/H,KAAK+H,OAASA,EACd/H,KAAKgI,MAAQ,EACbhI,KAAKiI,WAAa,E,0CAEtB,SAAOC,GAKH,MAA4B,OAAxBlI,KAAK+H,OAAOG,IACmB,OAA5BlI,KAAK+H,OAAOG,EAAS,GACjB,KAEJlI,KAAK+H,OAAOG,K,yBAEvB,WACI,OAAOlI,KAAKmI,OAAOnI,KAAKgI,S,yBAE5B,WACI,OAAOhI,KAAKmI,OAAOnI,KAAKgI,MAAQhI,KAAKiI,c,kBAEzC,WAQI,OAPAjI,KAAKiI,WAAa,EAEc,OAA5BjI,KAAK+H,OAAO/H,KAAKgI,QACkB,OAAhChI,KAAK+H,OAAO/H,KAAKgI,MAAQ,IAC5BhI,KAAKgI,QAEThI,KAAKgI,QACEhI,KAAK+H,OAAO/H,KAAKgI,S,kBAE5B,WAOI,MALkD,OAA9ChI,KAAK+H,OAAO/H,KAAKgI,MAAQhI,KAAKiI,aACuB,OAAlDjI,KAAK+H,OAAO/H,KAAKgI,MAAQhI,KAAKiI,WAAa,IAC9CjI,KAAKiI,aAETjI,KAAKiI,aACEjI,KAAK+H,OAAO/H,KAAKgI,MAAQhI,KAAKiI,c,uBAEzC,WAAsB,IAAZC,EAAY,uDAAH,EACflI,KAAKiI,WAAaC,I,wBAEtB,WACIlI,KAAKgI,OAAShI,KAAKiI,WACnBjI,KAAKiI,WAAa,M,KAGpBG,EAAM,KACNC,OAAMrH,EACNsH,EAA2B,CAAC,IAAK,IAAK,IAAK,KAC3CC,E,qKACF,WAEI,IADA,IAAM/E,EAAQxD,KAAKgI,MAAQhI,KAAKiI,WACF,MAAvBjI,KAAKwI,eACRxI,KAAKyI,OAET,OAAOzI,KAAK+H,OAAOW,MAAMlF,EAAOxD,KAAKgI,MAAQhI,KAAKiI,c,6BAEtD,WACI,IAAMU,EAAQ3I,KAAK4I,kBAEnB,OADA5I,KAAK6I,aACEF,I,4BAEX,WAEI,IADA,IAAIA,EAAQ,KACC,CACT,IAAMG,EAAY9I,KAAKiI,WAEvB,GADAjI,KAAK4I,kBACD5I,KAAKwI,gBAAkBJ,EAK3B,OAAIpI,KAAKwI,gBAAkBH,GAK3BrI,KAAK+I,UAAUD,GAHJH,EANPA,GAASP,EACTpI,KAAKyI,U,4BAYjB,WACI,IAAME,EAAQ3I,KAAKgJ,iBAEnB,OADAhJ,KAAK6I,aACEF,I,uBAEX,WACI,KAA8B,MAAvB3I,KAAKwI,eAAyBxI,KAAKwI,gBAAkBJ,GACxDpI,KAAKyI,S,uBAGb,WACIzI,KAAKiJ,YACLjJ,KAAK6I,e,wBAET,SAAWK,GACP,GAAIlJ,KAAKmJ,gBAAkBD,EAI3B,MAAM,IAAI3B,EAAW,QAAS2B,GAH1BlJ,KAAKoJ,S,2BAKb,WACI,GAAIpJ,KAAKmJ,gBAAkBd,EAA3B,CAIA,GAAIrI,KAAKmJ,gBAAkBf,EAK3B,MAAM,IAAIb,EAAW,QAAS,UAJ1BvH,KAAKoJ,U,sBAMb,SAASC,GACL,IAAMH,EAAKlJ,KAAKmJ,cAChB,OAAID,IAAOb,EACAA,EAEPgB,EAAEH,IACFlJ,KAAKoJ,OACEF,GAEJ,O,2BAEX,SAAcA,GACV,GAAIA,IAAOb,EACP,OAAO,EAEX,IAAMiB,EAAKJ,EAAGK,WAAW,GACzB,OAAQD,GAAM,IAAMA,GAAM,KACrBA,GAAM,IAAMA,GAAM,K,+BAE3B,WACI,OAAOtJ,KAAKwJ,cAAcxJ,KAAKwI,iB,2BAEnC,WACI,IAAMU,EAA4B,MAAvBlJ,KAAKmJ,cACVnJ,KAAKyI,OACLzI,KAAKmJ,cACX,GAAID,IAAOb,EAEP,OADArI,KAAK+I,aACE,EAEX,IAAMO,EAAKJ,EAAGK,WAAW,GACnBE,EAAUH,GAAM,IAAMA,GAAM,GAElC,OADAtJ,KAAK+I,YACEU,I,uCAEX,SAA0BP,GACtB,OAAIA,IAAOb,IAGHC,EAAyBoB,SAASR,K,0BAE9C,WAEI,IAAMA,EAAKlJ,KAAKwI,cAChB,OAAOU,IAAOd,GAAOc,IAAOb,I,iCAEhC,WACI,IAAMsB,EAAU3J,KAAKiI,WAErB,OADAjI,KAAK4I,kBACsB,MAAvB5I,KAAKwI,eACLxI,KAAK+I,UAAUY,IACR,GAEP3J,KAAKiI,WAAa0B,IAAY,MAG9B3J,KAAK4J,0BAA0B5J,KAAKwI,iBACpCxI,KAAK+I,UAAUY,IACR,M,+BAQf,WAA8B,IAAZE,EAAY,wDAAH,EACvB,GAAI7J,KAAKmJ,gBAAkBf,EACvB,OAAO,EAGX,IADA,IAAIrF,EAAI,EACDA,GAAK8G,IAAqB,IAAXA,GAAgB9G,EAAI,GAAI,CAC1C,GAAoB,MAAhB/C,KAAKyI,OAAgB,CACrB,GAAI1F,GAAK8G,IAAoB,IAAXA,EAEd,OADA7J,KAAK+I,aACE,EAEX,MAEJhG,IAGJ,IAAMmG,EAAKlJ,KAAKyI,OAChB,MAAW,MAAPS,GAAcA,IAAOd,GACrBpI,KAAK+I,aACE,IAEX/I,KAAK+I,aACE,K,4BAEX,WACI,IAAMe,EAAoB9J,KAAKiI,WAI/B,MAH2B,MAAvBjI,KAAKwI,eACLxI,KAAKyI,OAEkB,MAAvBzI,KAAKwI,eACLxI,KAAK+I,UAAUe,IACR,IAEX9J,KAAK+I,UAAUe,IACR,K,8BAEX,WACI,MAA8B,MAAvB9J,KAAKwI,gB,kCAEhB,SAAqBuB,GACjB,IAAIC,EAAchK,KAAK+H,OAAOkC,YAAY7B,EAAKpI,KAAKgI,OAMpD,IALI+B,EAAYC,IAGZhK,KAAKgI,MAAQgC,GAEVhK,KAAKmJ,eAER,GAAInJ,KAAKmJ,gBAAkBf,EAA3B,CAKA,IAAM8B,EAAQlK,KAAKoJ,OACnB,GAAIpJ,KAAKwJ,cAAcU,IAAoB,MAAVA,GAA2B,MAAVA,EAC9C,WANAlK,KAAKoJ,S,yBAUjB,WACI,GAAIpJ,KAAKwJ,cAAcxJ,KAAKmJ,eAAgB,CACxC,IAAMgB,EAAMnK,KAAKmJ,cAEjB,OADAnJ,KAAKoJ,OACEe,EAEX,MAAM,IAAI5C,EAAW,QAAS,Y,wBAElC,WAQI,OAAOvH,KAAKoK,UAPI,SAAClB,GACb,IAAMI,EAAKJ,EAAGK,WAAW,GACzB,OAASD,GAAM,IAAMA,GAAM,KACtBA,GAAM,IAAMA,GAAM,IAClBA,GAAM,IAAMA,GAAM,IACZ,KAAPA,GAAoB,KAAPA,O,uBAIzB,WAKI,OAAOtJ,KAAKoK,UAJI,SAAClB,GACb,IAAMI,EAAKJ,EAAGK,WAAW,GACzB,OAAQD,GAAM,IAAMA,GAAM,Q,0BAIlC,WAOI,OAAOtJ,KAAKoK,UANI,SAAClB,GACb,IAAMI,EAAKJ,EAAGK,WAAW,GACzB,OAAQD,GAAM,IAAMA,GAAM,IAClBA,GAAM,IAAMA,GAAM,IAClBA,GAAM,IAAMA,GAAM,W,GA5NLxB,GAmO3BuC,EAAe,cACrB,SAASC,EAASrJ,GACd,OAAO,SAAUsJ,GAAa,2BAANlK,EAAM,iCAANA,EAAM,kBAC1B,IAAKL,KAAKwK,UACN,OAAOvJ,EAAGzB,KAAH,MAAAyB,EAAE,CAAMjB,KAAMuK,GAAZ,OAAmBlK,IAEhC,IAAMmD,EAAQ+G,EAAGvC,MACXyC,EAAOxJ,EAAGzB,KAAH,MAAAyB,EAAE,CAAMjB,KAAMuK,GAAZ,OAAmBlK,IAGlC,GAAIoK,EAAK/G,KACL,OAAO+G,EAEX,IAAMhH,EAAM8G,EAAGvC,MAEf,OADAyC,EAAKC,QAAQlH,EAAOC,GACbgH,G,IAGTE,E,WACF,aAAuC,6DAAJ,GAAI,IAAzBH,iBAAyB,6BACnCxK,KAAKwK,UAAYA,EAGjBxK,KAAK4K,WAAaN,EAAStK,KAAK4K,YAChC5K,KAAK6K,WAAaP,EAAStK,KAAK6K,YAChC7K,KAAK8K,QAAUR,EAAStK,KAAK8K,SAC7B9K,KAAK+K,aAAeT,EAAStK,KAAK+K,cAClC/K,KAAKgL,cAAgBV,EAAStK,KAAKgL,eACnChL,KAAKiL,WAAaX,EAAStK,KAAKiL,YAChCjL,KAAKkL,UAAYZ,EAAStK,KAAKkL,WAC/BlL,KAAKmL,WAAab,EAAStK,KAAKmL,YAChCnL,KAAKoL,eAAiBd,EAAStK,KAAKoL,gBACpCpL,KAAKqL,aAAef,EAAStK,KAAKqL,cAClCrL,KAAKsL,cAAgBhB,EAAStK,KAAKsL,eACnCtL,KAAKuL,oBAAsBjB,EAAStK,KAAKuL,qBACzCvL,KAAKwL,gBAAkBlB,EAAStK,KAAKwL,iBACrCxL,KAAKyL,iBAAmBnB,EAAStK,KAAKyL,kBACtCzL,KAAK0L,UAAYpB,EAAStK,KAAK0L,WAC/B1L,KAAK2L,WAAarB,EAAStK,KAAK2L,YAChC3L,KAAK4K,WAAaN,EAAStK,KAAK4K,Y,yCAGpC,SAAMgB,GACF,IAAMrB,EAAK,IAAIhC,EAAmBqD,GAClCrB,EAAGsB,iBAGH,IAFA,IAAMC,EAAU,GACZC,EAAc,KACXxB,EAAGpB,eAAe,CACrB,IAAM6C,EAAQhM,KAAKiM,eAAe1B,GAC5B2B,EAAa3B,EAAGsB,iBAMlBG,aAAiBlF,GACQ,IAAtBoF,EAAWpJ,QACXyH,EAAGpB,cAEN4C,EAAcC,GAGdD,IACIC,aAAiBjI,GAAWiI,aAAiB7H,GAC7C6H,EAAM9H,QAAU6H,EACZ/L,KAAKwK,YAELwB,EAAMtI,KAAKF,MAAQwI,EAAM9H,QAAQR,KAAKF,QAI1CsI,EAAQrL,KAAKsL,GAGjBA,EAAc,MAGlBD,EAAQrL,KAAKuL,IAEjB,IAAMG,EAAM,IAAIvI,EAASkI,GAIzB,OAHI9L,KAAKwK,WACL2B,EAAIzB,QAAQ,EAAGH,EAAGvC,OAEfmE,I,wBAWX,SAAWP,GACP,IAAMrB,EAAK,IAAIhC,EAAmBqD,GAElC,IADArB,EAAGsB,iBACyB,MAArBtB,EAAGpB,eAAuB,CAC7B,IAAMiD,EAAUpM,KAAKiM,eAAe1B,GACpC,GAAI6B,aAAmBnF,EAEnB,OAAOmF,EAEX7B,EAAGsB,iBAEP,OAAO7L,KAAKiM,eAAe1B,K,4BAE/B,SAAeA,GACX,IAAM8B,EAAgB9B,EAAGvC,MACzB,IACI,IAAMgE,EAAQhM,KAAKsM,SAAS/B,GAE5B,OADAA,EAAGgC,gBACIP,EAEX,MAAOQ,GACH,KAAMA,aAAejF,GACjB,MAAMiF,EAEV,IAAIC,EAAalC,EAAGvC,MACpBuC,EAAGmC,qBAAqBL,GACxB,IAAMM,EAAiBpC,EAAGvC,MACtB2E,EAAiBF,IAEjBA,EAAaE,GAGjB,IAAMjE,EAAQ6B,EAAGxC,OAAO6E,UAAUP,EAAeM,GAC3CE,EAAO,IAAI5F,EAAKyB,GAClB1I,KAAKwK,WACLqC,EAAKnC,QAAQ2B,EAAeM,GAEhC,IAAMG,EAAQ,IAAI1F,EAAWoF,EAAInF,KAAMmF,EAAInM,KAAMmM,EAAIlF,SAGrD,OAFAwF,EAAMpC,QAAQ+B,EAAYA,GAC1BI,EAAKE,cAAcD,GACZD,K,sBAGf,SAAStC,GACL,GAAyB,MAArBA,EAAGpB,cACH,OAAOnJ,KAAK4K,WAAWL,GAE3B,GAAyB,MAArBA,EAAGpB,cACH,OAAOnJ,KAAK8K,QAAQP,GAExB,GAAIA,EAAGyC,oBACH,OAAOhN,KAAK6K,WAAWN,GAE3B,MAAM,IAAIhD,EAAW,W,wBAEzB,SAAWgD,GAMP,IAFA,IA0BI0C,EA1BApD,GAAS,EACThD,EAAU,KACD,CAET,IADA,IAAI9D,GAAK,EACmB,MAArBwH,EAAGpB,eAA0BpG,IAAgB,IAAX8G,EAAe,EAAIA,IACxDU,EAAGnB,OACHrG,IAKJ,IAHe,IAAX8G,IACAA,EAAQ9G,GAERwH,EAAGpB,gBAAkBf,EAAK,CAC1BmC,EAAG2C,WAAW,KAEd,IADA,IAAIhE,OAAE,EACEA,EAAKqB,EAAGH,UAAS,SAAA+C,GAAC,OAAIA,IAAM/E,MAChCvB,GAAWqC,EAGnB,IAAIqB,EAAG6C,kBAAkBvD,GAKrB,MAJAhD,GAAW0D,EAAGpB,cACdoB,EAAGnB,OAOX,OAAQS,GACJ,KAAK,EACDoD,EAAYnG,EACZ,MACJ,KAAK,EACDmG,EAAYlG,EACZ,MACJ,QACIkG,EAAYjG,EAEpB,OAAO,IAAIiG,EAAUpG,K,wBAEzB,SAAW0D,GACP,IAAMvG,EAAKhE,KAAKgL,cAAcT,GAC9BA,EAAG8C,kBACH9C,EAAG2C,WAAW,KACd,IAAMtL,EAAQ5B,KAAKsN,gBAAgB/C,GAC7BgD,EAAQvN,KAAKwN,cAAcjD,GACjC,GAAc,OAAV3I,GAAmC,IAAjB2L,EAAMzK,OACxB,MAAM,IAAIyE,EAAW,QAASvD,EAAG0C,MAErC,OAAO,IAAI3C,EAAQC,EAAIpC,EAAO2L,K,qBAElC,SAAQhD,GACJA,EAAG2C,WAAW,KACd,IAAMlJ,EAAKhE,KAAKgL,cAAcT,GAC9BA,EAAG8C,kBACH9C,EAAG2C,WAAW,KACd,IAAMtL,EAAQ5B,KAAKsN,gBAAgB/C,GACnC,GAAc,OAAV3I,EACA,MAAM,IAAI2F,EAAW,QAASvD,EAAG0C,MAErC,IAAM6G,EAAQvN,KAAKwN,cAAcjD,GACjC,OAAO,IAAIpG,EAAKH,EAAIpC,EAAO2L,K,0BAE/B,SAAahD,GACTA,EAAG2C,WAAW,KACd,IAAM5G,EAAMtG,KAAKgL,cAAcT,GAC/BA,EAAG8C,kBACH9C,EAAG2C,WAAW,KACd,IAAMtL,EAAQ5B,KAAKsN,gBAAgB/C,GACnC,GAAc,OAAV3I,EACA,MAAM,IAAI2F,EAAW,SAEzB,OAAO,IAAInB,EAAUE,EAAK1E,K,2BAE9B,SAAc2I,GACV,IAAMgD,EAAQ,GAEd,IADAhD,EAAGtB,YACIsB,EAAGkD,oBAAoB,CAC1BlD,EAAG1B,aACH,IAAM6E,EAAO1N,KAAK+K,aAAaR,GAC/BgD,EAAM9M,KAAKiN,GACXnD,EAAGtB,YAEP,OAAOsE,I,2BAEX,SAAchD,GAGV,IAFA,IACIrB,EADAxC,EAAO6D,EAAGoD,cAENzE,EAAKqB,EAAGqD,cACZlH,GAAQwC,EAEZ,OAAO,IAAIvC,EAAWD,K,2BAE1B,SAAc6D,GACV,IAAMrB,EAAKqB,EAAGpB,cACd,GAAID,IAAOb,EACP,MAAM,IAAId,EAAW,SAEzB,IAAM+B,EAAKJ,EAAGK,WAAW,GACzB,OAAKD,GAAM,IAAMA,GAAM,IAAc,KAAPA,EACnBtJ,KAAKkL,UAAUX,GAEnBvK,KAAKgL,cAAcT,K,wBAE9B,SAAWA,GAAwB,IAApBsD,EAAoB,wDAC3BC,GAAe,EACnB,GAAyB,MAArBvD,EAAGpB,cAAuB,CAC1B,GAAI0E,EACA,MAAM,IAAItG,EAAW,SAEzBgD,EAAGnB,OACH0E,GAAe,EAEnBvD,EAAG2C,WAAW,KACd3C,EAAGwD,YACH,IAAMzH,EAAMtG,KAAKgO,cAAczD,GAC/BA,EAAGwD,YACHxD,EAAG2C,WAAW,KACd,IAAMtL,EAAQ5B,KAAKsN,gBAAgB/C,GACnC,GAAc,OAAV3I,EACA,MAAM,IAAI2F,EAAW,SAEzB,OAAO,IAAIlB,EAAQC,EAAK1E,EAAOkM,K,yBAEnC,SAAYvD,GACR,IAAMvE,EAAW,GACb6H,GAAa,EAEjB,IADAtD,EAAGwD,YACIxD,EAAG0D,kBAAkB,CACxB,IAAMC,EAAUlO,KAAKiL,WAAWV,EAAIsD,GAChCK,EAAQ1H,UACRqH,GAAa,GAEjB7H,EAASvF,KAAKyN,GACd3D,EAAGgC,gBACHhC,EAAGwD,YAEP,GAAwB,IAApB/H,EAASlD,OACT,MAAM,IAAIyE,EAAW,SAEzB,IAAKsG,EACD,MAAM,IAAItG,EAAW,SAEzB,OAAOvB,I,uBAEX,SAAUuE,GAGN,IAFA,IACIrB,EADAiF,EAAM,GAEFjF,EAAKqB,EAAG6D,aACZD,GAAOjF,EAEX,GAAmB,IAAfiF,EAAIrL,OACJ,MAAM,IAAIyE,EAAW,QAAS,OAElC,OAAO4G,I,uBAEX,SAAU5D,GACN,IAAI3I,EAAQ,GAYZ,MAXyB,MAArB2I,EAAGpB,eACHoB,EAAGnB,OACHxH,GAAS,IAAJ,OAAQ5B,KAAKqO,UAAU9D,KAG5B3I,GAAS5B,KAAKqO,UAAU9D,GAEH,MAArBA,EAAGpB,gBACHoB,EAAGnB,OACHxH,GAAS,IAAJ,OAAQ5B,KAAKqO,UAAU9D,KAEzB,IAAIlF,EAAczD,K,6BAQ7B,SAAgB2I,GAEZ,OADAA,EAAG3B,kBACC2B,EAAG+D,gBACH/D,EAAG1B,aACI7I,KAAKmL,WAAWZ,GAAI,KAE/BA,EAAGvB,iBACCuB,EAAGgE,uBACHhE,EAAG1B,aACI7I,KAAKmL,WAAWZ,GAAI,IAExB,Q,wBAEX,SAAWA,EAAIiE,GACX,IACIC,EAYAvF,EAbE7E,EAAW,GAEjB,GAAImK,EAAS,CAGT,IAAME,EAAanE,EAAGvC,MAChB2G,EAAcpE,EAAG8C,kBACvBhJ,EAAS5D,KAAKT,KAAK4O,UAAUrE,EAAIoE,EAAaD,IAC9CD,EAAqBE,EAAY7L,YAGjC2L,EAAqBI,IAGzBxK,EAAU,KAAQ6E,EAAKqB,EAAGpB,eACtB,OAAQD,GACJ,KAAKd,EACD,IAAMsG,EAAanE,EAAGvC,MAChBkE,EAAa3B,EAAGvB,iBACtB,GAAIuB,EAAGgE,sBAAuB,CAC1BhE,EAAG1B,aACH,IAAMiG,EAASvE,EAAG8C,kBAClBoB,EAAqBM,KAAKC,IAAIP,EAAoBK,EAAOhM,QACzDuB,EAAS5D,KAAKT,KAAK4O,UAAUrE,EAAI2B,EAAa4C,EAAQJ,IACtD,SAASrK,EAIbkG,EAAGxB,YACH,MAAM1E,EAEV,IAAK,IACDA,EAAS5D,KAAKT,KAAKqL,aAAad,IAChC,SAASlG,EACb,IAAK,IACD,MAAM,IAAIkD,EAAW,SACzB,QACIlD,EAAS5D,KAAKT,KAAKoL,eAAeb,IAG9C,IAAM0E,EAAWjP,KAAKkP,OAAO7K,EAAUoK,GACvC,OAAO,IAAIrK,EAAQ6K,K,uBAKvB,SAAU1E,EAAI3I,EAAO4B,GACjB,OAAO,IAAI2L,EAAOvN,EAAO4B,EAAO+G,EAAGvC,S,oBAIvC,SAAO3D,EAAU+K,GACb,IAD2B,EACrBC,EAAU,GADW,cAEPhL,GAFO,IAE3B,IAAK,EAAL,qBAA8B,KAArBiL,EAAqB,QAC1B,GAAIA,aAAmB9K,EACnB6K,EAAQ5O,KAAK6O,QAGjB,KAAIA,aAAmBH,IAEnBG,EAAQ1N,MAAQ0N,EAAQ1N,MAAM8G,MAAM,EAAG4G,EAAQ1N,MAAMkB,OAASsM,GACjC,IAAzBE,EAAQ1N,MAAMkB,SAHtB,CAOA,IAAIyM,EAAOF,EAAQA,EAAQvM,OAAS,GACpC,GAAIyM,GAAQA,aAAgBhL,EAA5B,CAEI,IAAMiL,EAAM,IAAIjL,EAAYgL,EAAK3N,MAAQ0N,EAAQ1N,OAC7C5B,KAAKwK,WAELgF,EAAI9E,QAAQ6E,EAAK7L,KAAKF,MAAO8L,EAAQ5L,KAAKD,KAE9C4L,EAAQA,EAAQvM,OAAS,GAAK0M,MAPlC,CAUA,GAAIF,aAAmBH,EAAQ,CAG3B,IAAMM,EAAc,IAAIlL,EAAY+K,EAAQ1N,OACxC5B,KAAKwK,WACLiF,EAAY/E,QAAQ4E,EAAQ5L,KAAKF,MAAO8L,EAAQ5L,KAAKD,KAEzD6L,EAAUG,EAEdJ,EAAQ5O,KAAK6O,MAlCU,8BAqC3B,IAAMI,EAAcL,EAAQA,EAAQvM,OAAS,GAO7C,OANI4M,aAAuBnL,IACvBmL,EAAY9N,MAAQ8N,EAAY9N,MAAMiD,QAAQwF,EAAc,IAC3B,IAA7BqF,EAAY9N,MAAMkB,QAClBuM,EAAQM,OAGTN,I,4BAEX,SAAe9E,GAGX,IAFA,IACIrB,EADA0G,EAAS,GAEL1G,EAAKqB,EAAGpB,eAAgB,CAC5B,GAAW,MAAPD,GAAqB,MAAPA,EACd,OAAO,IAAI3E,EAAYqL,GAE3B,GAAI1G,IAAOd,EACP,OAAO,IAAI7D,EAAYqL,GAE3BA,GAAU1G,EACVqB,EAAGnB,OAEP,OAAO,IAAI7E,EAAYqL,K,+BAE3B,SAAkBrF,GACd,IAAMnB,EAAOmB,EAAGpB,cAChB,OAAQC,GACJ,IAAK,KACL,IAAK,IAED,OADAmB,EAAGnB,OACI,KAAP,OAAYA,GAChB,IAAK,IACD,OAAOpJ,KAAK6P,yBAAyBtF,EAAInB,EAAM,GACnD,IAAK,IACD,OAAOpJ,KAAK6P,yBAAyBtF,EAAInB,EAAM,GACnD,QACI,MAAM,IAAI7B,EAAW,QAAS6B,M,sCAG1C,SAAyBmB,EAAIuF,EAAGC,GAC5BxF,EAAG2C,WAAW4C,GAEd,IADA,IAAIjI,EAAW,GACN9E,EAAI,EAAGA,EAAIgN,EAAQhN,IAAK,CAC7B,IAAMmG,EAAKqB,EAAGyF,eACd,IAAK9G,EACD,MAAM,IAAI3B,EAAW,QAAf,YAA6BuI,GAA7B,OAAiCjI,GAAjC,OAA4C0C,EAAGpB,gBAEzDtB,GAAYqB,EAEhB,MAAO,KAAP,OAAY4G,GAAZ,OAAgBjI,K,0BAEpB,SAAa0C,GACTA,EAAG2C,WAAW,KACd3C,EAAGwD,YACH,IAAMtJ,EAAazE,KAAKsL,cAAcf,GAEtC,OADAA,EAAG2C,WAAW,KACP,IAAI1I,EAAUC,K,2BAEzB,SAAc8F,GACV,IAAMxE,EAAW/F,KAAKuL,oBAAoBhB,GAE1C,GADAA,EAAGwD,YACsB,MAArBxD,EAAGpB,cAAuB,CAC1B,GAAkB,MAAdoB,EAAG9B,OAEH,OADA8B,EAAGxB,YACIhD,EAIX,GAAIA,aAAoBN,EACpB,MAA2B,OAAvBM,EAASL,UACH,IAAI6B,EAAW,SAGf,IAAIA,EAAW,SAGxB,GAAIxB,aAAoBJ,GACzB,GAA2B,OAAvBI,EAASL,UACT,MAAM,IAAI6B,EAAW,cAGxB,GAAIxB,aAAoBvB,EACzB,MAAM,IAAI+C,EAAW,SAEzBgD,EAAGnB,OACHmB,EAAGnB,OACHmB,EAAG8C,kBACH9C,EAAGgC,gBACH,IAAMvG,EAAWhG,KAAKiQ,YAAY1F,GAClC,OAAO,IAAIzE,EAAiBC,EAAUC,GAE1C,GAAID,aAAoBJ,GAAwC,OAAvBI,EAASL,UAC9C,MAAM,IAAI6B,EAAW,SAEzB,OAAOxB,I,iCAEX,SAAoBwE,GAChB,GAAyB,MAArBA,EAAGpB,cACH,OAAOnJ,KAAKqL,aAAad,GAE7B,GAAIA,EAAG2F,gBACH,OAAOlQ,KAAKkL,UAAUX,GAE1B,GAAyB,MAArBA,EAAGpB,cACH,OAAOnJ,KAAK0L,UAAUnB,GAE1B,GAAyB,MAArBA,EAAGpB,cAAuB,CAC1BoB,EAAGnB,OACH,IAAMpF,EAAKhE,KAAKgL,cAAcT,GAC9B,OAAO,IAAI3E,EAAkB5B,GAEjC,GAAyB,MAArBuG,EAAGpB,cAAuB,CAC1BoB,EAAGnB,OACH,IACIsE,EAKArN,EANE2D,EAAKhE,KAAKgL,cAAcT,GAY9B,MAVyB,MAArBA,EAAGpB,gBACHoB,EAAGnB,OACHsE,EAAO1N,KAAKgL,cAAcT,IAG9BA,EAAGtB,YACsB,MAArBsB,EAAG/B,gBACH+B,EAAG1B,aACHxI,EAAOL,KAAKyL,iBAAiBlB,IAE1B,IAAI5E,EAAc3B,EAAI0J,EAAMrN,GAEvC,GAAIkK,EAAGyC,oBAAqB,CACxB,IAWIU,EAXE1J,EAAKhE,KAAKgL,cAAcT,GAE9B,GADAA,EAAGtB,YACsB,MAArBsB,EAAG/B,cAAuB,CAE1B,IAAK,qBAAqB2H,KAAKnM,EAAG0C,MAC9B,MAAM,IAAIa,EAAW,SAEzBgD,EAAG1B,aACH,IAAIxI,EAAOL,KAAKyL,iBAAiBlB,GACjC,OAAO,IAAI1E,EAAkB7B,EAAI3D,GAOrC,MAJyB,MAArBkK,EAAGpB,gBACHoB,EAAGnB,OACHsE,EAAO1N,KAAKgL,cAAcT,IAEvB,IAAI9E,EAAiBzB,EAAI0J,GAEpC,MAAM,IAAInG,EAAW,W,6BAEzB,SAAgBgD,GACZ,IAAM6F,EAAMpQ,KAAKuL,oBAAoBhB,GAErC,GADAA,EAAGwD,YACsB,MAArBxD,EAAGpB,cACH,OAAOiH,EAEX,GAAIA,aAAe3K,GAAsC,OAAlB2K,EAAI1K,UAAoB,CAC3D6E,EAAGnB,OACHmB,EAAGwD,YACH,IAAMnM,EAAQ5B,KAAK2L,WAAWpB,GAC9B,OAAO,IAAI9D,EAAc2J,EAAIpM,GAAIpC,GAErC,MAAM,IAAI2F,EAAW,W,8BAEzB,SAAiBgD,GACb,IAAMrE,EAAa,GACbC,EAAQ,GACRkK,EAAgB,IAAIhO,IAG1B,IAFAkI,EAAG2C,WAAW,KACd3C,EAAGwD,YAE0B,MAArBxD,EAAGpB,eADE,CAIT,IAAMmH,EAAMtQ,KAAKwL,gBAAgBjB,GACjC,GAAI+F,aAAe7J,EAAe,CAC9B,GAAI4J,EAAchP,IAAIiP,EAAI5J,KAAKA,MAC3B,MAAM,IAAIa,EAAW,SAEzBpB,EAAM1F,KAAK6P,GACXD,EAAcE,IAAID,EAAI5J,KAAKA,UAE1B,IAAI2J,EAAc3N,KAAO,EAC1B,MAAM,IAAI6E,EAAW,SAGrBrB,EAAWzF,KAAK6P,GAGpB,GADA/F,EAAGwD,YACsB,MAArBxD,EAAGpB,cAKP,MAJIoB,EAAGnB,OACHmB,EAAGwD,YAMX,OADAxD,EAAG2C,WAAW,KACP,IAAIjH,EAAcC,EAAYC,K,uBAEzC,SAAUoE,GACNA,EAAG2C,WAAW,KAGd,IAFA,IACIhE,EADAtH,EAAQ,GAEJsH,EAAKqB,EAAGH,UAAS,SAAA+C,GAAC,MAAU,MAANA,GAAaA,IAAM/E,MAEzCxG,GADO,OAAPsH,EACSlJ,KAAKwQ,kBAAkBjG,GAGvBrB,EAGjB,GAAIqB,EAAGpB,gBAAkBf,EACrB,MAAM,IAAIb,EAAW,SAGzB,OADAgD,EAAG2C,WAAW,KACP,IAAItI,EAAchD,K,wBAE7B,SAAW2I,GACP,GAAIA,EAAG2F,gBACH,OAAOlQ,KAAKkL,UAAUX,GAE1B,GAAyB,MAArBA,EAAGpB,cACH,OAAOnJ,KAAK0L,UAAUnB,GAE1B,MAAM,IAAIhD,EAAW,a,KAGvB4H,E,aACF,WAAYvN,EAAO4B,EAAOC,GAAK,oBAC3BzD,KAAKiC,KAAO,SACZjC,KAAK4B,MAAQA,EACb5B,KAAK0D,KAAO,IAAIC,EAAKH,EAAOC,MAIpC,SAASgN,EAAM7E,EAAQ8E,GAEnB,OADe,IAAI/F,EAAa+F,GAClBD,MAAM7E,GAGxB,IAAI+E,GAAc,SAAqBC,GACrC,MAAO,MAAQA,EAAK3O,MAGlB4O,GAAa,CACfC,UAAW,SAAmBF,GAC5B,GAAI5Q,KAAK2Q,GAAYC,IACnB,OAAO5Q,KAAK2Q,GAAYC,IAAOA,GAE/BG,QAAQC,KAAK,gBAAiBJ,EAAK3O,KAAM2O,IAG7ChG,WAAY,SAAoBgG,GAC9B,MAAO,CACLtK,IAAK,UACL1E,MAAOgP,EAAK/J,UAGhBoK,gBAAiB,WACf,OAAO,MAETC,mBAAoB,WAClB,OAAO,MAETrG,WAAY,SAAoB+F,GAC9B,IAAIO,EAAQnR,KAEZ,MAAO,CACLsG,IAAKtG,KAAK2Q,GAAYC,EAAK5M,KAAK4M,EAAK5M,IACrCpC,MAAO5B,KAAK2Q,GAAYC,EAAKhP,QAAQgP,EAAKhP,OAC1CsC,QAAS0M,EAAK1M,SAAWlE,KAAK2Q,GAAYC,EAAK1M,UAAU0M,EAAK1M,SAC9DD,WAAY2M,EAAK3M,YAAc2M,EAAK3M,WAAWb,KAAI,SAAUsK,GAC3D,OAAOyD,EAAML,UAAUpD,QAI7B3C,aAAc,SAAsB6F,GAClC,MAAO,CACLtK,IAAKtG,KAAK2Q,GAAYC,EAAK5M,KAAK4M,EAAK5M,IACrCpC,MAAO5B,KAAK2Q,GAAYC,EAAKhP,QAAQgP,EAAKhP,SAG9CkJ,QAAS,SAAiB8F,GACxB,IAAIQ,EAASpR,KAEb,MAAO,CACLsG,IAAK,IAAI+K,OAAOrR,KAAK2Q,GAAYC,EAAK5M,KAAK4M,EAAK5M,KAChDpC,MAAO5B,KAAK2Q,GAAYC,EAAKhP,QAAQgP,EAAKhP,OAC1CsC,QAAS0M,EAAK1M,SAAWlE,KAAK2Q,GAAYC,EAAK1M,UAAU0M,EAAK1M,SAC9DD,WAAY2M,EAAK3M,YAAc2M,EAAK3M,WAAWb,KAAI,SAAUsK,GAC3D,OAAO0D,EAAON,UAAUpD,QAI9B1C,cAAe,SAAuB4F,GACpC,OAAOA,EAAKlK,MAEd4K,iBAAkB,SAA0BV,GAC1C,OAAOA,EAAKhP,OAEduJ,WAAY,SAAoByF,GAC9B,IAAIW,EAASvR,KAiBb,OAfY4Q,EAAKvM,SAASjB,KAAI,SAAUoO,GACtC,OAAIA,EAAU/M,WACP8M,EAAOZ,GAAYa,EAAU/M,aAI3B8M,EAAOZ,GAAYa,EAAU/M,aAAa+M,EAAU/M,YAHlDsM,QAAQU,IAAI,WAAYd,GAAYa,EAAU/M,YAAa+M,EAAU/M,YAKzE8M,EAAOZ,GAAYa,IAIjBD,EAAOZ,GAAYa,IAAYA,GAH7BT,QAAQU,IAAI,WAAYd,GAAYa,GAAYA,MAMhDE,KAAK,KAEpBC,kBAAmB,SAA2Bf,GAC5C,IAAIgB,EAAS5R,KAET6R,EAASjB,EAAKkB,OAAOpL,KACrBqL,EAAcnB,EAAK1K,WAAW9C,KAAI,SAAU8C,GAC9C,OAAO0L,EAAOjB,GAAYzK,IAAaA,GAAY,MAEjD8L,EAASpB,EAAKzK,MAAM/C,KAAI,SAAU+C,GACpC,OAAOyL,EAAOjB,GAAYxK,IAAQA,MAEpC,MAAO,KAAO0L,EAAS,KAAOE,EAAYL,KAAK,MAAQM,EAAOlP,OAAS,KAAOkP,EAAON,KAAK,MAAQ,IAAM,OAE1GO,iBAAkB,SAA0BrB,GAC1C,OAAO5Q,KAAK2Q,GAAYC,EAAKlK,OAAOkK,EAAKlK,MAAQ,MAAQ1G,KAAK2Q,GAAYC,EAAKhP,QAAQgP,EAAKhP,OAAS,KAEvGwJ,eAAgB,SAAwBwF,GACtC,OAAOA,EAAKhP,OAEdsQ,oBAAqB,SAA6BtB,GAChD,IAAIuB,EAASnS,KAMb,MAAO,MAJEA,KAAK2Q,GAAYC,EAAK7K,WAAW6K,EAAK7K,UAAU,GAIrC,QAHL6K,EAAK5K,SAAS5C,KAAI,SAAU8K,GACzC,OAAOiE,EAAOxB,GAAYzC,IAAUA,MAECwD,KAAK,MAAQ,OAEtDU,qBAAsB,SAA8BxB,GAClD,IAAIyB,EAAMrS,KAAK2Q,GAAYC,EAAKyB,MAAMzB,EAAKyB,KAAK,GAC5C/L,EAAMtG,KAAK2Q,GAAYC,EAAKtK,MAAMsK,EAAKtK,KAC3C,OAAIA,EAAY,KAAO+L,EAAM,IAAM/L,EAAM,MAClC,MAAQ+L,EAAM,OAEvBC,qBAAsB,SAA8B1B,EAAM2B,GACxD,OAAIA,EAAcvS,KAAK2Q,GAAYC,EAAK5M,KAAK4M,EAAK5M,IAC3C,MAAQhE,KAAK2Q,GAAYC,EAAK5M,KAAK4M,EAAK5M,IAAM,MAEvDwO,kBAAmB,SAA2B5B,EAAM2B,GAClD,OAAIA,EAAcvS,KAAK2Q,GAAYC,EAAK5M,KAAK4M,EAAK5M,IAC3C,KAAOhE,KAAK2Q,GAAYC,EAAK5M,KAAK4M,EAAK5M,IAAM,MAEtDyO,eAAgB,SAAwB7B,GACtC,OAAOA,EAAKlK,MAEdgM,eAAgB,SAAwB9B,GACtC,IAAI+B,EAAS3S,KAKb,MAAO,MAHQ4Q,EAAK5K,SAAS5C,KAAI,SAAU8K,GACzC,OAAOyE,EAAOhC,GAAYzC,IAAUA,MAEdwD,KAAK,MAAQ,OAEvCzG,WAAY,SAAoB2F,GAC9B,IAAIlK,EAAOkK,EAAKtK,IAAII,KAAOkK,EAAKtK,IAAII,KAAOkK,EAAKtK,IAAI1E,MAChDgR,EAAYhC,EAAKpK,QAEjB2D,EAAM,IAAMzD,EAAO,KADT1G,KAAK2Q,GAAYC,EAAKhP,QAAQgP,EAAKhP,OAEjD,OAAIgR,EAAkB,KAAOzI,EACtB,KAAOA,GAEhB0I,qBAAsB,SAA8BjC,GAClD,IAAIvQ,EAAO,GASX,OARAuQ,EAAK1Q,UAAUgG,WAAW4M,SAAQ,SAAUC,EAAGhQ,GACzCA,EAAI,IAAG1C,GAAQ,MACnBA,GAAQ,IAAIgR,OAAO0B,EAAE/O,GAAG0C,SAE1BkK,EAAK1Q,UAAUiG,MAAM2M,SAAQ,SAAUE,EAAGjQ,IACpCA,EAAI,GAAc,KAAT1C,KAAaA,GAAQ,MAClCA,GAAQ,GAAGgR,OAAO2B,EAAEtM,KAAKA,KAAM,OAAQ2K,OAAO2B,EAAEpR,MAAMA,MAAO,QAExD,KAAKyP,OAAOT,EAAK5M,GAAG0C,KAAM,KAAK2K,OAAOhR,EAAM,QAErD4S,iBAAkB,SAA0BrC,GAC1C,MAAO,MAAMS,OAAOT,EAAK5M,GAAG0C,KAAM,OAEpCwM,QAAS,SAAiBtC,GACxB,IAAIuC,EAAQvC,EAAK/J,QAAQuM,MAAM,KAG/B,MAAO,CACL9M,IAHQ6M,EAAME,QAAQC,OAItB1R,MAHUuR,EAAMzB,KAAK,KAAK4B,OAAOzO,QAAQ,UAAW,OAAOA,QAAQ,WAAY,UAQrF,SAAS0O,GAAQC,EAAKC,GACpB,IAAIC,EAASxT,UAAU4C,OAAS,QAAsB9B,IAAjBd,UAAU,GAAmBA,UAAU,GAAK,CAC/EyT,iBAAiB,GAGnB,GAAmB,kBAARH,EAAkB,CAC3B,IAAKC,EAAI,MAAM,IAAIhM,MAAM,wCACzB,OAAOgM,EAAG,IAAIhM,MAAM,yCAGtB,IAAImM,EAASnD,EAAM+C,EAAK,CACtBhJ,WAAW,IAET3K,EAAS+T,EAAO/P,KAAKgQ,QAAO,SAAUC,EAAKC,GAC7C,IAAInD,EAAOC,GAAWC,UAAUiD,GAChC,IAAKnD,EAAM,OAAOkD,EAElB,GAAIlD,EAAK3M,YAAc2M,EAAK3M,WAAWnB,QAAU8N,EAAK1M,SAAWwP,EAAOC,gBAAiB,CACvF,IAAIK,EAAQ,GACRpD,EAAK1M,UAAS8P,EAAMpD,EAAK1M,QAAQoC,KAAOsK,EAAK1M,QAAQtC,OAErDgP,EAAK3M,YAAc2M,EAAK3M,WAAWnB,QACrC8N,EAAK3M,WAAW6O,SAAQ,SAAUpF,GAChCsG,EAAMtG,EAAKpH,KAAOoH,EAAK9L,SAI3BoS,EAAMC,IAAMrD,EAAKhP,MACjBkS,EAAIlD,EAAKtK,KAAO0N,OAEhBF,EAAIlD,EAAKtK,KAAOsK,EAAKhP,MAGvB,OAAOkS,IACN,IAEH,OADIL,GAAIA,EAAG,KAAM5T,GACVA,EAGT,SAASqU,GAASC,EAAGvS,GACnB,IAAIwS,EAAM,GAUV,OATAA,EAAMA,EAAMD,EAAI,KAEZvS,GAASA,EAAMT,QAAQ,OAAS,GAClCiT,GAAY,OACZA,GAAYxS,EAAMwR,MAAM,MAAM1B,KAAK,SAEnC0C,EAAMA,EAAM,IAAMxS,EAGbwS,EAUT,SAASC,GAAOC,EAAWb,GACzB,IAAIW,EAAM,GAmBV,OAlBA1S,OAAOY,KAAKgS,GAAWxB,SAAQ,SAAUqB,GACvC,IAAIvS,EAAQ0S,EAAUH,GAED,kBAAVvS,GACTwS,GAAYF,GAASC,EAAGvS,GACxBwS,GAAY,SAERxS,EAAMsC,UAASkQ,GAhBzB,SAAoBlQ,GAClB,IAAIkQ,EAAM,GAGV,OAFAA,EAAMA,EAAM,KAAOlQ,EAAQkP,MAAM,MAAM1B,KAAK,QAC5C0C,EAAY,KAauBG,CAAW3S,EAAMsC,UAChDkQ,GAAYF,GAASC,EAAGvS,EAAMqS,KAC9BvS,OAAOY,KAAKV,GAAOkR,SAAQ,SAAU0B,GACnC,GAAe,YAAXA,GAAmC,QAAXA,EAA5B,CACA,IAAIC,EAAa7S,EAAM4S,GACvBJ,GAAYF,GAAS,QAAUM,EAAQC,OAEzCL,GAAY,WAGZX,GAAIA,EAAG,KAAMW,GACVA,EAGT,IAAIpM,GAAQ,CACV0M,OAAQnB,GACRc,OAAQA,IAGKrM","file":"static/js/8.745d61d7.chunk.js","sourcesContent":["export default function _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}","import getPrototypeOf from \"./getPrototypeOf.js\";\nimport isNativeReflectConstruct from \"./isNativeReflectConstruct.js\";\nimport possibleConstructorReturn from \"./possibleConstructorReturn.js\";\nexport default function _createSuper(Derived) {\n  var hasNativeReflectConstruct = isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}","import setPrototypeOf from \"./setPrototypeOf.js\";\nimport isNativeReflectConstruct from \"./isNativeReflectConstruct.js\";\nexport default function _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}","import getPrototypeOf from \"./getPrototypeOf.js\";\nimport setPrototypeOf from \"./setPrototypeOf.js\";\nimport isNativeFunction from \"./isNativeFunction.js\";\nimport construct from \"./construct.js\";\nexport default function _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}","export default function _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}","/*\n * Base class for all Fluent AST nodes.\n *\n * All productions described in the ASDL subclass BaseNode, including Span and\n * Annotation.\n *\n */\nclass BaseNode {\n    constructor() {\n        this.type = \"BaseNode\";\n    }\n    equals(other, ignoredFields = [\"span\"]) {\n        const thisKeys = new Set(Object.keys(this));\n        const otherKeys = new Set(Object.keys(other));\n        if (ignoredFields) {\n            for (const fieldName of ignoredFields) {\n                thisKeys.delete(fieldName);\n                otherKeys.delete(fieldName);\n            }\n        }\n        if (thisKeys.size !== otherKeys.size) {\n            return false;\n        }\n        for (const fieldName of thisKeys) {\n            if (!otherKeys.has(fieldName)) {\n                return false;\n            }\n            const thisVal = this[fieldName];\n            const otherVal = other[fieldName];\n            if (typeof thisVal !== typeof otherVal) {\n                return false;\n            }\n            if (thisVal instanceof Array && otherVal instanceof Array) {\n                if (thisVal.length !== otherVal.length) {\n                    return false;\n                }\n                for (let i = 0; i < thisVal.length; ++i) {\n                    if (!scalarsEqual(thisVal[i], otherVal[i], ignoredFields)) {\n                        return false;\n                    }\n                }\n            }\n            else if (!scalarsEqual(thisVal, otherVal, ignoredFields)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    clone() {\n        function visit(value) {\n            if (value instanceof BaseNode) {\n                return value.clone();\n            }\n            if (Array.isArray(value)) {\n                return value.map(visit);\n            }\n            return value;\n        }\n        const clone = Object.create(this.constructor.prototype);\n        for (const prop of Object.keys(this)) {\n            clone[prop] = visit(this[prop]);\n        }\n        return clone;\n    }\n}\nfunction scalarsEqual(thisVal, otherVal, ignoredFields) {\n    if (thisVal instanceof BaseNode && otherVal instanceof BaseNode) {\n        return thisVal.equals(otherVal, ignoredFields);\n    }\n    return thisVal === otherVal;\n}\n/*\n * Base class for AST nodes which can have Spans.\n */\nclass SyntaxNode extends BaseNode {\n    constructor() {\n        super(...arguments);\n        this.type = \"SyntaxNode\";\n    }\n    addSpan(start, end) {\n        this.span = new Span(start, end);\n    }\n}\nclass Resource extends SyntaxNode {\n    constructor(body = []) {\n        super();\n        this.type = \"Resource\";\n        this.body = body;\n    }\n}\n/*\n * An abstract base class for useful elements of Resource.body.\n */\nclass Entry extends SyntaxNode {\n    constructor() {\n        super(...arguments);\n        this.type = \"Entry\";\n    }\n}\nclass Message extends Entry {\n    constructor(id, value = null, attributes = [], comment = null) {\n        super();\n        this.type = \"Message\";\n        this.id = id;\n        this.value = value;\n        this.attributes = attributes;\n        this.comment = comment;\n    }\n}\nclass Term extends Entry {\n    constructor(id, value, attributes = [], comment = null) {\n        super();\n        this.type = \"Term\";\n        this.id = id;\n        this.value = value;\n        this.attributes = attributes;\n        this.comment = comment;\n    }\n}\nclass Pattern extends SyntaxNode {\n    constructor(elements) {\n        super();\n        this.type = \"Pattern\";\n        this.elements = elements;\n    }\n}\n/*\n * An abstract base class for elements of Patterns.\n */\nclass PatternElement extends SyntaxNode {\n    constructor() {\n        super(...arguments);\n        this.type = \"PatternElement\";\n    }\n}\nclass TextElement extends PatternElement {\n    constructor(value) {\n        super();\n        this.type = \"TextElement\";\n        this.value = value;\n    }\n}\nclass Placeable extends PatternElement {\n    constructor(expression) {\n        super();\n        this.type = \"Placeable\";\n        this.expression = expression;\n    }\n}\n/*\n * An abstract base class for expressions.\n */\nclass Expression extends SyntaxNode {\n    constructor() {\n        super(...arguments);\n        this.type = \"Expression\";\n    }\n}\n// An abstract base class for Literals.\nclass Literal extends Expression {\n    constructor(value) {\n        super();\n        this.type = \"Literal\";\n        // The \"value\" field contains the exact contents of the literal,\n        // character-for-character.\n        this.value = value;\n    }\n}\nclass StringLiteral extends Literal {\n    constructor() {\n        super(...arguments);\n        this.type = \"StringLiteral\";\n    }\n    parse() {\n        // Backslash backslash, backslash double quote, uHHHH, UHHHHHH.\n        const KNOWN_ESCAPES = /(?:\\\\\\\\|\\\\\"|\\\\u([0-9a-fA-F]{4})|\\\\U([0-9a-fA-F]{6}))/g;\n        function fromEscapeSequence(match, codepoint4, codepoint6) {\n            switch (match) {\n                case \"\\\\\\\\\":\n                    return \"\\\\\";\n                case \"\\\\\\\"\":\n                    return \"\\\"\";\n                default: {\n                    let codepoint = parseInt(codepoint4 || codepoint6, 16);\n                    if (codepoint <= 0xD7FF || 0xE000 <= codepoint) {\n                        // It's a Unicode scalar value.\n                        return String.fromCodePoint(codepoint);\n                    }\n                    // Escape sequences reresenting surrogate code points are\n                    // well-formed but invalid in Fluent. Replace them with U+FFFD\n                    // REPLACEMENT CHARACTER.\n                    return \"ï¿½\";\n                }\n            }\n        }\n        let value = this.value.replace(KNOWN_ESCAPES, fromEscapeSequence);\n        return { value };\n    }\n}\nclass NumberLiteral extends Literal {\n    constructor() {\n        super(...arguments);\n        this.type = \"NumberLiteral\";\n    }\n    parse() {\n        let value = parseFloat(this.value);\n        let decimalPos = this.value.indexOf(\".\");\n        let precision = decimalPos > 0\n            ? this.value.length - decimalPos - 1\n            : 0;\n        return { value, precision };\n    }\n}\nclass MessageReference extends Expression {\n    constructor(id, attribute = null) {\n        super();\n        this.type = \"MessageReference\";\n        this.id = id;\n        this.attribute = attribute;\n    }\n}\nclass TermReference extends Expression {\n    constructor(id, attribute = null, args = null) {\n        super();\n        this.type = \"TermReference\";\n        this.id = id;\n        this.attribute = attribute;\n        this.arguments = args;\n    }\n}\nclass VariableReference extends Expression {\n    constructor(id) {\n        super();\n        this.type = \"VariableReference\";\n        this.id = id;\n    }\n}\nclass FunctionReference extends Expression {\n    constructor(id, args) {\n        super();\n        this.type = \"FunctionReference\";\n        this.id = id;\n        this.arguments = args;\n    }\n}\nclass SelectExpression extends Expression {\n    constructor(selector, variants) {\n        super();\n        this.type = \"SelectExpression\";\n        this.selector = selector;\n        this.variants = variants;\n    }\n}\nclass CallArguments extends SyntaxNode {\n    constructor(positional = [], named = []) {\n        super();\n        this.type = \"CallArguments\";\n        this.positional = positional;\n        this.named = named;\n    }\n}\nclass Attribute extends SyntaxNode {\n    constructor(id, value) {\n        super();\n        this.type = \"Attribute\";\n        this.id = id;\n        this.value = value;\n    }\n}\nclass Variant extends SyntaxNode {\n    constructor(key, value, def) {\n        super();\n        this.type = \"Variant\";\n        this.key = key;\n        this.value = value;\n        this.default = def;\n    }\n}\nclass NamedArgument extends SyntaxNode {\n    constructor(name, value) {\n        super();\n        this.type = \"NamedArgument\";\n        this.name = name;\n        this.value = value;\n    }\n}\nclass Identifier extends SyntaxNode {\n    constructor(name) {\n        super();\n        this.type = \"Identifier\";\n        this.name = name;\n    }\n}\nclass BaseComment extends Entry {\n    constructor(content) {\n        super();\n        this.type = \"BaseComment\";\n        this.content = content;\n    }\n}\nclass Comment extends BaseComment {\n    constructor() {\n        super(...arguments);\n        this.type = \"Comment\";\n    }\n}\nclass GroupComment extends BaseComment {\n    constructor() {\n        super(...arguments);\n        this.type = \"GroupComment\";\n    }\n}\nclass ResourceComment extends BaseComment {\n    constructor() {\n        super(...arguments);\n        this.type = \"ResourceComment\";\n    }\n}\nclass Junk extends SyntaxNode {\n    constructor(content) {\n        super();\n        this.type = \"Junk\";\n        this.annotations = [];\n        this.content = content;\n    }\n    addAnnotation(annotation) {\n        this.annotations.push(annotation);\n    }\n}\nclass Span extends BaseNode {\n    constructor(start, end) {\n        super();\n        this.type = \"Span\";\n        this.start = start;\n        this.end = end;\n    }\n}\nclass Annotation extends SyntaxNode {\n    constructor(code, args = [], message) {\n        super();\n        this.type = \"Annotation\";\n        this.code = code;\n        this.arguments = args;\n        this.message = message;\n    }\n}\n\nclass ParseError extends Error {\n    constructor(code, ...args) {\n        super();\n        this.code = code;\n        this.args = args;\n        this.message = getErrorMessage(code, args);\n    }\n}\n/* eslint-disable complexity */\nfunction getErrorMessage(code, args) {\n    switch (code) {\n        case \"E0001\":\n            return \"Generic error\";\n        case \"E0002\":\n            return \"Expected an entry start\";\n        case \"E0003\": {\n            const [token] = args;\n            return `Expected token: \"${token}\"`;\n        }\n        case \"E0004\": {\n            const [range] = args;\n            return `Expected a character from range: \"${range}\"`;\n        }\n        case \"E0005\": {\n            const [id] = args;\n            return `Expected message \"${id}\" to have a value or attributes`;\n        }\n        case \"E0006\": {\n            const [id] = args;\n            return `Expected term \"-${id}\" to have a value`;\n        }\n        case \"E0007\":\n            return \"Keyword cannot end with a whitespace\";\n        case \"E0008\":\n            return \"The callee has to be an upper-case identifier or a term\";\n        case \"E0009\":\n            return \"The argument name has to be a simple identifier\";\n        case \"E0010\":\n            return \"Expected one of the variants to be marked as default (*)\";\n        case \"E0011\":\n            return 'Expected at least one variant after \"->\"';\n        case \"E0012\":\n            return \"Expected value\";\n        case \"E0013\":\n            return \"Expected variant key\";\n        case \"E0014\":\n            return \"Expected literal\";\n        case \"E0015\":\n            return \"Only one variant can be marked as default (*)\";\n        case \"E0016\":\n            return \"Message references cannot be used as selectors\";\n        case \"E0017\":\n            return \"Terms cannot be used as selectors\";\n        case \"E0018\":\n            return \"Attributes of messages cannot be used as selectors\";\n        case \"E0019\":\n            return \"Attributes of terms cannot be used as placeables\";\n        case \"E0020\":\n            return \"Unterminated string expression\";\n        case \"E0021\":\n            return \"Positional arguments must not follow named arguments\";\n        case \"E0022\":\n            return \"Named arguments must be unique\";\n        case \"E0024\":\n            return \"Cannot access variants of a message.\";\n        case \"E0025\": {\n            const [char] = args;\n            return `Unknown escape sequence: \\\\${char}.`;\n        }\n        case \"E0026\": {\n            const [sequence] = args;\n            return `Invalid Unicode escape sequence: ${sequence}.`;\n        }\n        case \"E0027\":\n            return \"Unbalanced closing brace in TextElement.\";\n        case \"E0028\":\n            return \"Expected an inline expression\";\n        case \"E0029\":\n            return \"Expected simple expression as selector\";\n        default:\n            return code;\n    }\n}\n\n/* eslint no-magic-numbers: \"off\" */\nclass ParserStream {\n    constructor(string) {\n        this.string = string;\n        this.index = 0;\n        this.peekOffset = 0;\n    }\n    charAt(offset) {\n        // When the cursor is at CRLF, return LF but don't move the cursor.\n        // The cursor still points to the EOL position, which in this case is the\n        // beginning of the compound CRLF sequence. This ensures slices of\n        // [inclusive, exclusive) continue to work properly.\n        if (this.string[offset] === \"\\r\"\n            && this.string[offset + 1] === \"\\n\") {\n            return \"\\n\";\n        }\n        return this.string[offset];\n    }\n    currentChar() {\n        return this.charAt(this.index);\n    }\n    currentPeek() {\n        return this.charAt(this.index + this.peekOffset);\n    }\n    next() {\n        this.peekOffset = 0;\n        // Skip over the CRLF as if it was a single character.\n        if (this.string[this.index] === \"\\r\"\n            && this.string[this.index + 1] === \"\\n\") {\n            this.index++;\n        }\n        this.index++;\n        return this.string[this.index];\n    }\n    peek() {\n        // Skip over the CRLF as if it was a single character.\n        if (this.string[this.index + this.peekOffset] === \"\\r\"\n            && this.string[this.index + this.peekOffset + 1] === \"\\n\") {\n            this.peekOffset++;\n        }\n        this.peekOffset++;\n        return this.string[this.index + this.peekOffset];\n    }\n    resetPeek(offset = 0) {\n        this.peekOffset = offset;\n    }\n    skipToPeek() {\n        this.index += this.peekOffset;\n        this.peekOffset = 0;\n    }\n}\nconst EOL = \"\\n\";\nconst EOF = undefined;\nconst SPECIAL_LINE_START_CHARS = [\"}\", \".\", \"[\", \"*\"];\nclass FluentParserStream extends ParserStream {\n    peekBlankInline() {\n        const start = this.index + this.peekOffset;\n        while (this.currentPeek() === \" \") {\n            this.peek();\n        }\n        return this.string.slice(start, this.index + this.peekOffset);\n    }\n    skipBlankInline() {\n        const blank = this.peekBlankInline();\n        this.skipToPeek();\n        return blank;\n    }\n    peekBlankBlock() {\n        let blank = \"\";\n        while (true) {\n            const lineStart = this.peekOffset;\n            this.peekBlankInline();\n            if (this.currentPeek() === EOL) {\n                blank += EOL;\n                this.peek();\n                continue;\n            }\n            if (this.currentPeek() === EOF) {\n                // Treat the blank line at EOF as a blank block.\n                return blank;\n            }\n            // Any other char; reset to column 1 on this line.\n            this.resetPeek(lineStart);\n            return blank;\n        }\n    }\n    skipBlankBlock() {\n        const blank = this.peekBlankBlock();\n        this.skipToPeek();\n        return blank;\n    }\n    peekBlank() {\n        while (this.currentPeek() === \" \" || this.currentPeek() === EOL) {\n            this.peek();\n        }\n    }\n    skipBlank() {\n        this.peekBlank();\n        this.skipToPeek();\n    }\n    expectChar(ch) {\n        if (this.currentChar() === ch) {\n            this.next();\n            return;\n        }\n        throw new ParseError(\"E0003\", ch);\n    }\n    expectLineEnd() {\n        if (this.currentChar() === EOF) {\n            // EOF is a valid line end in Fluent.\n            return;\n        }\n        if (this.currentChar() === EOL) {\n            this.next();\n            return;\n        }\n        // Unicode Character 'SYMBOL FOR NEWLINE' (U+2424)\n        throw new ParseError(\"E0003\", \"\\u2424\");\n    }\n    takeChar(f) {\n        const ch = this.currentChar();\n        if (ch === EOF) {\n            return EOF;\n        }\n        if (f(ch)) {\n            this.next();\n            return ch;\n        }\n        return null;\n    }\n    isCharIdStart(ch) {\n        if (ch === EOF) {\n            return false;\n        }\n        const cc = ch.charCodeAt(0);\n        return (cc >= 97 && cc <= 122) || // a-z\n            (cc >= 65 && cc <= 90); // A-Z\n    }\n    isIdentifierStart() {\n        return this.isCharIdStart(this.currentPeek());\n    }\n    isNumberStart() {\n        const ch = this.currentChar() === \"-\"\n            ? this.peek()\n            : this.currentChar();\n        if (ch === EOF) {\n            this.resetPeek();\n            return false;\n        }\n        const cc = ch.charCodeAt(0);\n        const isDigit = cc >= 48 && cc <= 57; // 0-9\n        this.resetPeek();\n        return isDigit;\n    }\n    isCharPatternContinuation(ch) {\n        if (ch === EOF) {\n            return false;\n        }\n        return !SPECIAL_LINE_START_CHARS.includes(ch);\n    }\n    isValueStart() {\n        // Inline Patterns may start with any char.\n        const ch = this.currentPeek();\n        return ch !== EOL && ch !== EOF;\n    }\n    isValueContinuation() {\n        const column1 = this.peekOffset;\n        this.peekBlankInline();\n        if (this.currentPeek() === \"{\") {\n            this.resetPeek(column1);\n            return true;\n        }\n        if (this.peekOffset - column1 === 0) {\n            return false;\n        }\n        if (this.isCharPatternContinuation(this.currentPeek())) {\n            this.resetPeek(column1);\n            return true;\n        }\n        return false;\n    }\n    // -1 - any\n    //  0 - comment\n    //  1 - group comment\n    //  2 - resource comment\n    isNextLineComment(level = -1) {\n        if (this.currentChar() !== EOL) {\n            return false;\n        }\n        let i = 0;\n        while (i <= level || (level === -1 && i < 3)) {\n            if (this.peek() !== \"#\") {\n                if (i <= level && level !== -1) {\n                    this.resetPeek();\n                    return false;\n                }\n                break;\n            }\n            i++;\n        }\n        // The first char after #, ## or ###.\n        const ch = this.peek();\n        if (ch === \" \" || ch === EOL) {\n            this.resetPeek();\n            return true;\n        }\n        this.resetPeek();\n        return false;\n    }\n    isVariantStart() {\n        const currentPeekOffset = this.peekOffset;\n        if (this.currentPeek() === \"*\") {\n            this.peek();\n        }\n        if (this.currentPeek() === \"[\") {\n            this.resetPeek(currentPeekOffset);\n            return true;\n        }\n        this.resetPeek(currentPeekOffset);\n        return false;\n    }\n    isAttributeStart() {\n        return this.currentPeek() === \".\";\n    }\n    skipToNextEntryStart(junkStart) {\n        let lastNewline = this.string.lastIndexOf(EOL, this.index);\n        if (junkStart < lastNewline) {\n            // Last seen newline is _after_ the junk start. It's safe to rewind\n            // without the risk of resuming at the same broken entry.\n            this.index = lastNewline;\n        }\n        while (this.currentChar()) {\n            // We're only interested in beginnings of line.\n            if (this.currentChar() !== EOL) {\n                this.next();\n                continue;\n            }\n            // Break if the first char in this line looks like an entry start.\n            const first = this.next();\n            if (this.isCharIdStart(first) || first === \"-\" || first === \"#\") {\n                break;\n            }\n        }\n    }\n    takeIDStart() {\n        if (this.isCharIdStart(this.currentChar())) {\n            const ret = this.currentChar();\n            this.next();\n            return ret;\n        }\n        throw new ParseError(\"E0004\", \"a-zA-Z\");\n    }\n    takeIDChar() {\n        const closure = (ch) => {\n            const cc = ch.charCodeAt(0);\n            return ((cc >= 97 && cc <= 122) || // a-z\n                (cc >= 65 && cc <= 90) || // A-Z\n                (cc >= 48 && cc <= 57) || // 0-9\n                cc === 95 || cc === 45); // _-\n        };\n        return this.takeChar(closure);\n    }\n    takeDigit() {\n        const closure = (ch) => {\n            const cc = ch.charCodeAt(0);\n            return (cc >= 48 && cc <= 57); // 0-9\n        };\n        return this.takeChar(closure);\n    }\n    takeHexDigit() {\n        const closure = (ch) => {\n            const cc = ch.charCodeAt(0);\n            return (cc >= 48 && cc <= 57) // 0-9\n                || (cc >= 65 && cc <= 70) // A-F\n                || (cc >= 97 && cc <= 102); // a-f\n        };\n        return this.takeChar(closure);\n    }\n}\n\n/*  eslint no-magic-numbers: [0]  */\nconst trailingWSRe = /[ \\t\\n\\r]+$/;\nfunction withSpan(fn) {\n    return function (ps, ...args) {\n        if (!this.withSpans) {\n            return fn.call(this, ps, ...args);\n        }\n        const start = ps.index;\n        const node = fn.call(this, ps, ...args);\n        // Don't re-add the span if the node already has it. This may happen when\n        // one decorated function calls another decorated function.\n        if (node.span) {\n            return node;\n        }\n        const end = ps.index;\n        node.addSpan(start, end);\n        return node;\n    };\n}\nclass FluentParser {\n    constructor({ withSpans = true } = {}) {\n        this.withSpans = withSpans;\n        // Poor man's decorators.\n        /* eslint-disable @typescript-eslint/unbound-method */\n        this.getComment = withSpan(this.getComment);\n        this.getMessage = withSpan(this.getMessage);\n        this.getTerm = withSpan(this.getTerm);\n        this.getAttribute = withSpan(this.getAttribute);\n        this.getIdentifier = withSpan(this.getIdentifier);\n        this.getVariant = withSpan(this.getVariant);\n        this.getNumber = withSpan(this.getNumber);\n        this.getPattern = withSpan(this.getPattern);\n        this.getTextElement = withSpan(this.getTextElement);\n        this.getPlaceable = withSpan(this.getPlaceable);\n        this.getExpression = withSpan(this.getExpression);\n        this.getInlineExpression = withSpan(this.getInlineExpression);\n        this.getCallArgument = withSpan(this.getCallArgument);\n        this.getCallArguments = withSpan(this.getCallArguments);\n        this.getString = withSpan(this.getString);\n        this.getLiteral = withSpan(this.getLiteral);\n        this.getComment = withSpan(this.getComment);\n        /* eslint-enable @typescript-eslint/unbound-method */\n    }\n    parse(source) {\n        const ps = new FluentParserStream(source);\n        ps.skipBlankBlock();\n        const entries = [];\n        let lastComment = null;\n        while (ps.currentChar()) {\n            const entry = this.getEntryOrJunk(ps);\n            const blankLines = ps.skipBlankBlock();\n            // Regular Comments require special logic. Comments may be attached to\n            // Messages or Terms if they are followed immediately by them. However\n            // they should parse as standalone when they're followed by Junk.\n            // Consequently, we only attach Comments once we know that the Message\n            // or the Term parsed successfully.\n            if (entry instanceof Comment\n                && blankLines.length === 0\n                && ps.currentChar()) {\n                // Stash the comment and decide what to do with it in the next pass.\n                lastComment = entry;\n                continue;\n            }\n            if (lastComment) {\n                if (entry instanceof Message || entry instanceof Term) {\n                    entry.comment = lastComment;\n                    if (this.withSpans) {\n                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                        entry.span.start = entry.comment.span.start;\n                    }\n                }\n                else {\n                    entries.push(lastComment);\n                }\n                // In either case, the stashed comment has been dealt with; clear it.\n                lastComment = null;\n            }\n            // No special logic for other types of entries.\n            entries.push(entry);\n        }\n        const res = new Resource(entries);\n        if (this.withSpans) {\n            res.addSpan(0, ps.index);\n        }\n        return res;\n    }\n    /*\n     * Parse the first Message or Term in `source`.\n     *\n     * Skip all encountered comments and start parsing at the first Message or\n     * Term start. Return Junk if the parsing is not successful.\n     *\n     * Preceding comments are ignored unless they contain syntax errors\n     * themselves, in which case Junk for the invalid comment is returned.\n     */\n    parseEntry(source) {\n        const ps = new FluentParserStream(source);\n        ps.skipBlankBlock();\n        while (ps.currentChar() === \"#\") {\n            const skipped = this.getEntryOrJunk(ps);\n            if (skipped instanceof Junk) {\n                // Don't skip Junk comments.\n                return skipped;\n            }\n            ps.skipBlankBlock();\n        }\n        return this.getEntryOrJunk(ps);\n    }\n    getEntryOrJunk(ps) {\n        const entryStartPos = ps.index;\n        try {\n            const entry = this.getEntry(ps);\n            ps.expectLineEnd();\n            return entry;\n        }\n        catch (err) {\n            if (!(err instanceof ParseError)) {\n                throw err;\n            }\n            let errorIndex = ps.index;\n            ps.skipToNextEntryStart(entryStartPos);\n            const nextEntryStart = ps.index;\n            if (nextEntryStart < errorIndex) {\n                // The position of the error must be inside of the Junk's span.\n                errorIndex = nextEntryStart;\n            }\n            // Create a Junk instance\n            const slice = ps.string.substring(entryStartPos, nextEntryStart);\n            const junk = new Junk(slice);\n            if (this.withSpans) {\n                junk.addSpan(entryStartPos, nextEntryStart);\n            }\n            const annot = new Annotation(err.code, err.args, err.message);\n            annot.addSpan(errorIndex, errorIndex);\n            junk.addAnnotation(annot);\n            return junk;\n        }\n    }\n    getEntry(ps) {\n        if (ps.currentChar() === \"#\") {\n            return this.getComment(ps);\n        }\n        if (ps.currentChar() === \"-\") {\n            return this.getTerm(ps);\n        }\n        if (ps.isIdentifierStart()) {\n            return this.getMessage(ps);\n        }\n        throw new ParseError(\"E0002\");\n    }\n    getComment(ps) {\n        // 0 - comment\n        // 1 - group comment\n        // 2 - resource comment\n        let level = -1;\n        let content = \"\";\n        while (true) {\n            let i = -1;\n            while (ps.currentChar() === \"#\" && (i < (level === -1 ? 2 : level))) {\n                ps.next();\n                i++;\n            }\n            if (level === -1) {\n                level = i;\n            }\n            if (ps.currentChar() !== EOL) {\n                ps.expectChar(\" \");\n                let ch;\n                while ((ch = ps.takeChar(x => x !== EOL))) {\n                    content += ch;\n                }\n            }\n            if (ps.isNextLineComment(level)) {\n                content += ps.currentChar();\n                ps.next();\n            }\n            else {\n                break;\n            }\n        }\n        let Comment$1;\n        switch (level) {\n            case 0:\n                Comment$1 = Comment;\n                break;\n            case 1:\n                Comment$1 = GroupComment;\n                break;\n            default:\n                Comment$1 = ResourceComment;\n        }\n        return new Comment$1(content);\n    }\n    getMessage(ps) {\n        const id = this.getIdentifier(ps);\n        ps.skipBlankInline();\n        ps.expectChar(\"=\");\n        const value = this.maybeGetPattern(ps);\n        const attrs = this.getAttributes(ps);\n        if (value === null && attrs.length === 0) {\n            throw new ParseError(\"E0005\", id.name);\n        }\n        return new Message(id, value, attrs);\n    }\n    getTerm(ps) {\n        ps.expectChar(\"-\");\n        const id = this.getIdentifier(ps);\n        ps.skipBlankInline();\n        ps.expectChar(\"=\");\n        const value = this.maybeGetPattern(ps);\n        if (value === null) {\n            throw new ParseError(\"E0006\", id.name);\n        }\n        const attrs = this.getAttributes(ps);\n        return new Term(id, value, attrs);\n    }\n    getAttribute(ps) {\n        ps.expectChar(\".\");\n        const key = this.getIdentifier(ps);\n        ps.skipBlankInline();\n        ps.expectChar(\"=\");\n        const value = this.maybeGetPattern(ps);\n        if (value === null) {\n            throw new ParseError(\"E0012\");\n        }\n        return new Attribute(key, value);\n    }\n    getAttributes(ps) {\n        const attrs = [];\n        ps.peekBlank();\n        while (ps.isAttributeStart()) {\n            ps.skipToPeek();\n            const attr = this.getAttribute(ps);\n            attrs.push(attr);\n            ps.peekBlank();\n        }\n        return attrs;\n    }\n    getIdentifier(ps) {\n        let name = ps.takeIDStart();\n        let ch;\n        while ((ch = ps.takeIDChar())) {\n            name += ch;\n        }\n        return new Identifier(name);\n    }\n    getVariantKey(ps) {\n        const ch = ps.currentChar();\n        if (ch === EOF) {\n            throw new ParseError(\"E0013\");\n        }\n        const cc = ch.charCodeAt(0);\n        if ((cc >= 48 && cc <= 57) || cc === 45) { // 0-9, -\n            return this.getNumber(ps);\n        }\n        return this.getIdentifier(ps);\n    }\n    getVariant(ps, hasDefault = false) {\n        let defaultIndex = false;\n        if (ps.currentChar() === \"*\") {\n            if (hasDefault) {\n                throw new ParseError(\"E0015\");\n            }\n            ps.next();\n            defaultIndex = true;\n        }\n        ps.expectChar(\"[\");\n        ps.skipBlank();\n        const key = this.getVariantKey(ps);\n        ps.skipBlank();\n        ps.expectChar(\"]\");\n        const value = this.maybeGetPattern(ps);\n        if (value === null) {\n            throw new ParseError(\"E0012\");\n        }\n        return new Variant(key, value, defaultIndex);\n    }\n    getVariants(ps) {\n        const variants = [];\n        let hasDefault = false;\n        ps.skipBlank();\n        while (ps.isVariantStart()) {\n            const variant = this.getVariant(ps, hasDefault);\n            if (variant.default) {\n                hasDefault = true;\n            }\n            variants.push(variant);\n            ps.expectLineEnd();\n            ps.skipBlank();\n        }\n        if (variants.length === 0) {\n            throw new ParseError(\"E0011\");\n        }\n        if (!hasDefault) {\n            throw new ParseError(\"E0010\");\n        }\n        return variants;\n    }\n    getDigits(ps) {\n        let num = \"\";\n        let ch;\n        while ((ch = ps.takeDigit())) {\n            num += ch;\n        }\n        if (num.length === 0) {\n            throw new ParseError(\"E0004\", \"0-9\");\n        }\n        return num;\n    }\n    getNumber(ps) {\n        let value = \"\";\n        if (ps.currentChar() === \"-\") {\n            ps.next();\n            value += `-${this.getDigits(ps)}`;\n        }\n        else {\n            value += this.getDigits(ps);\n        }\n        if (ps.currentChar() === \".\") {\n            ps.next();\n            value += `.${this.getDigits(ps)}`;\n        }\n        return new NumberLiteral(value);\n    }\n    // maybeGetPattern distinguishes between patterns which start on the same line\n    // as the identifier (a.k.a. inline signleline patterns and inline multiline\n    // patterns) and patterns which start on a new line (a.k.a. block multiline\n    // patterns). The distinction is important for the dedentation logic: the\n    // indent of the first line of a block pattern must be taken into account when\n    // calculating the maximum common indent.\n    maybeGetPattern(ps) {\n        ps.peekBlankInline();\n        if (ps.isValueStart()) {\n            ps.skipToPeek();\n            return this.getPattern(ps, false);\n        }\n        ps.peekBlankBlock();\n        if (ps.isValueContinuation()) {\n            ps.skipToPeek();\n            return this.getPattern(ps, true);\n        }\n        return null;\n    }\n    getPattern(ps, isBlock) {\n        const elements = [];\n        let commonIndentLength;\n        if (isBlock) {\n            // A block pattern is a pattern which starts on a new line. Store and\n            // measure the indent of this first line for the dedentation logic.\n            const blankStart = ps.index;\n            const firstIndent = ps.skipBlankInline();\n            elements.push(this.getIndent(ps, firstIndent, blankStart));\n            commonIndentLength = firstIndent.length;\n        }\n        else {\n            commonIndentLength = Infinity;\n        }\n        let ch;\n        elements: while ((ch = ps.currentChar())) {\n            switch (ch) {\n                case EOL: {\n                    const blankStart = ps.index;\n                    const blankLines = ps.peekBlankBlock();\n                    if (ps.isValueContinuation()) {\n                        ps.skipToPeek();\n                        const indent = ps.skipBlankInline();\n                        commonIndentLength = Math.min(commonIndentLength, indent.length);\n                        elements.push(this.getIndent(ps, blankLines + indent, blankStart));\n                        continue elements;\n                    }\n                    // The end condition for getPattern's while loop is a newline\n                    // which is not followed by a valid pattern continuation.\n                    ps.resetPeek();\n                    break elements;\n                }\n                case \"{\":\n                    elements.push(this.getPlaceable(ps));\n                    continue elements;\n                case \"}\":\n                    throw new ParseError(\"E0027\");\n                default:\n                    elements.push(this.getTextElement(ps));\n            }\n        }\n        const dedented = this.dedent(elements, commonIndentLength);\n        return new Pattern(dedented);\n    }\n    // Create a token representing an indent. It's not part of the AST and it will\n    // be trimmed and merged into adjacent TextElements, or turned into a new\n    // TextElement, if it's surrounded by two Placeables.\n    getIndent(ps, value, start) {\n        return new Indent(value, start, ps.index);\n    }\n    // Dedent a list of elements by removing the maximum common indent from the\n    // beginning of text lines. The common indent is calculated in getPattern.\n    dedent(elements, commonIndent) {\n        const trimmed = [];\n        for (let element of elements) {\n            if (element instanceof Placeable) {\n                trimmed.push(element);\n                continue;\n            }\n            if (element instanceof Indent) {\n                // Strip common indent.\n                element.value = element.value.slice(0, element.value.length - commonIndent);\n                if (element.value.length === 0) {\n                    continue;\n                }\n            }\n            let prev = trimmed[trimmed.length - 1];\n            if (prev && prev instanceof TextElement) {\n                // Join adjacent TextElements by replacing them with their sum.\n                const sum = new TextElement(prev.value + element.value);\n                if (this.withSpans) {\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    sum.addSpan(prev.span.start, element.span.end);\n                }\n                trimmed[trimmed.length - 1] = sum;\n                continue;\n            }\n            if (element instanceof Indent) {\n                // If the indent hasn't been merged into a preceding TextElement,\n                // convert it into a new TextElement.\n                const textElement = new TextElement(element.value);\n                if (this.withSpans) {\n                    textElement.addSpan(element.span.start, element.span.end);\n                }\n                element = textElement;\n            }\n            trimmed.push(element);\n        }\n        // Trim trailing whitespace from the Pattern.\n        const lastElement = trimmed[trimmed.length - 1];\n        if (lastElement instanceof TextElement) {\n            lastElement.value = lastElement.value.replace(trailingWSRe, \"\");\n            if (lastElement.value.length === 0) {\n                trimmed.pop();\n            }\n        }\n        return trimmed;\n    }\n    getTextElement(ps) {\n        let buffer = \"\";\n        let ch;\n        while ((ch = ps.currentChar())) {\n            if (ch === \"{\" || ch === \"}\") {\n                return new TextElement(buffer);\n            }\n            if (ch === EOL) {\n                return new TextElement(buffer);\n            }\n            buffer += ch;\n            ps.next();\n        }\n        return new TextElement(buffer);\n    }\n    getEscapeSequence(ps) {\n        const next = ps.currentChar();\n        switch (next) {\n            case \"\\\\\":\n            case \"\\\"\":\n                ps.next();\n                return `\\\\${next}`;\n            case \"u\":\n                return this.getUnicodeEscapeSequence(ps, next, 4);\n            case \"U\":\n                return this.getUnicodeEscapeSequence(ps, next, 6);\n            default:\n                throw new ParseError(\"E0025\", next);\n        }\n    }\n    getUnicodeEscapeSequence(ps, u, digits) {\n        ps.expectChar(u);\n        let sequence = \"\";\n        for (let i = 0; i < digits; i++) {\n            const ch = ps.takeHexDigit();\n            if (!ch) {\n                throw new ParseError(\"E0026\", `\\\\${u}${sequence}${ps.currentChar()}`);\n            }\n            sequence += ch;\n        }\n        return `\\\\${u}${sequence}`;\n    }\n    getPlaceable(ps) {\n        ps.expectChar(\"{\");\n        ps.skipBlank();\n        const expression = this.getExpression(ps);\n        ps.expectChar(\"}\");\n        return new Placeable(expression);\n    }\n    getExpression(ps) {\n        const selector = this.getInlineExpression(ps);\n        ps.skipBlank();\n        if (ps.currentChar() === \"-\") {\n            if (ps.peek() !== \">\") {\n                ps.resetPeek();\n                return selector;\n            }\n            // Validate selector expression according to\n            // abstract.js in the Fluent specification\n            if (selector instanceof MessageReference) {\n                if (selector.attribute === null) {\n                    throw new ParseError(\"E0016\");\n                }\n                else {\n                    throw new ParseError(\"E0018\");\n                }\n            }\n            else if (selector instanceof TermReference) {\n                if (selector.attribute === null) {\n                    throw new ParseError(\"E0017\");\n                }\n            }\n            else if (selector instanceof Placeable) {\n                throw new ParseError(\"E0029\");\n            }\n            ps.next();\n            ps.next();\n            ps.skipBlankInline();\n            ps.expectLineEnd();\n            const variants = this.getVariants(ps);\n            return new SelectExpression(selector, variants);\n        }\n        if (selector instanceof TermReference && selector.attribute !== null) {\n            throw new ParseError(\"E0019\");\n        }\n        return selector;\n    }\n    getInlineExpression(ps) {\n        if (ps.currentChar() === \"{\") {\n            return this.getPlaceable(ps);\n        }\n        if (ps.isNumberStart()) {\n            return this.getNumber(ps);\n        }\n        if (ps.currentChar() === '\"') {\n            return this.getString(ps);\n        }\n        if (ps.currentChar() === \"$\") {\n            ps.next();\n            const id = this.getIdentifier(ps);\n            return new VariableReference(id);\n        }\n        if (ps.currentChar() === \"-\") {\n            ps.next();\n            const id = this.getIdentifier(ps);\n            let attr;\n            if (ps.currentChar() === \".\") {\n                ps.next();\n                attr = this.getIdentifier(ps);\n            }\n            let args;\n            ps.peekBlank();\n            if (ps.currentPeek() === \"(\") {\n                ps.skipToPeek();\n                args = this.getCallArguments(ps);\n            }\n            return new TermReference(id, attr, args);\n        }\n        if (ps.isIdentifierStart()) {\n            const id = this.getIdentifier(ps);\n            ps.peekBlank();\n            if (ps.currentPeek() === \"(\") {\n                // It's a Function. Ensure it's all upper-case.\n                if (!/^[A-Z][A-Z0-9_-]*$/.test(id.name)) {\n                    throw new ParseError(\"E0008\");\n                }\n                ps.skipToPeek();\n                let args = this.getCallArguments(ps);\n                return new FunctionReference(id, args);\n            }\n            let attr;\n            if (ps.currentChar() === \".\") {\n                ps.next();\n                attr = this.getIdentifier(ps);\n            }\n            return new MessageReference(id, attr);\n        }\n        throw new ParseError(\"E0028\");\n    }\n    getCallArgument(ps) {\n        const exp = this.getInlineExpression(ps);\n        ps.skipBlank();\n        if (ps.currentChar() !== \":\") {\n            return exp;\n        }\n        if (exp instanceof MessageReference && exp.attribute === null) {\n            ps.next();\n            ps.skipBlank();\n            const value = this.getLiteral(ps);\n            return new NamedArgument(exp.id, value);\n        }\n        throw new ParseError(\"E0009\");\n    }\n    getCallArguments(ps) {\n        const positional = [];\n        const named = [];\n        const argumentNames = new Set();\n        ps.expectChar(\"(\");\n        ps.skipBlank();\n        while (true) {\n            if (ps.currentChar() === \")\") {\n                break;\n            }\n            const arg = this.getCallArgument(ps);\n            if (arg instanceof NamedArgument) {\n                if (argumentNames.has(arg.name.name)) {\n                    throw new ParseError(\"E0022\");\n                }\n                named.push(arg);\n                argumentNames.add(arg.name.name);\n            }\n            else if (argumentNames.size > 0) {\n                throw new ParseError(\"E0021\");\n            }\n            else {\n                positional.push(arg);\n            }\n            ps.skipBlank();\n            if (ps.currentChar() === \",\") {\n                ps.next();\n                ps.skipBlank();\n                continue;\n            }\n            break;\n        }\n        ps.expectChar(\")\");\n        return new CallArguments(positional, named);\n    }\n    getString(ps) {\n        ps.expectChar(\"\\\"\");\n        let value = \"\";\n        let ch;\n        while ((ch = ps.takeChar(x => x !== '\"' && x !== EOL))) {\n            if (ch === \"\\\\\") {\n                value += this.getEscapeSequence(ps);\n            }\n            else {\n                value += ch;\n            }\n        }\n        if (ps.currentChar() === EOL) {\n            throw new ParseError(\"E0020\");\n        }\n        ps.expectChar(\"\\\"\");\n        return new StringLiteral(value);\n    }\n    getLiteral(ps) {\n        if (ps.isNumberStart()) {\n            return this.getNumber(ps);\n        }\n        if (ps.currentChar() === '\"') {\n            return this.getString(ps);\n        }\n        throw new ParseError(\"E0014\");\n    }\n}\nclass Indent {\n    constructor(value, start, end) {\n        this.type = \"Indent\";\n        this.value = value;\n        this.span = new Span(start, end);\n    }\n}\n\nfunction parse(source, opts) {\n    const parser = new FluentParser(opts);\n    return parser.parse(source);\n}\n\nvar getTypeName = function getTypeName(item) {\n  return 'get' + item.type;\n};\n\nvar serializer = {\n  serialize: function serialize(item) {\n    if (this[getTypeName(item)]) {\n      return this[getTypeName(item)](item);\n    } else {\n      console.warn('unknown type:', item.type, item);\n    }\n  },\n  getComment: function getComment(item) {\n    return {\n      key: 'comment',\n      value: item.content\n    };\n  },\n  getGroupComment: function getGroupComment() {\n    return null;\n  },\n  getResourceComment: function getResourceComment() {\n    return null;\n  },\n  getMessage: function getMessage(item) {\n    var _this = this;\n\n    return {\n      key: this[getTypeName(item.id)](item.id),\n      value: this[getTypeName(item.value)](item.value),\n      comment: item.comment && this[getTypeName(item.comment)](item.comment),\n      attributes: item.attributes && item.attributes.map(function (attr) {\n        return _this.serialize(attr);\n      })\n    };\n  },\n  getAttribute: function getAttribute(item) {\n    return {\n      key: this[getTypeName(item.id)](item.id),\n      value: this[getTypeName(item.value)](item.value)\n    };\n  },\n  getTerm: function getTerm(item) {\n    var _this2 = this;\n\n    return {\n      key: \"-\".concat(this[getTypeName(item.id)](item.id)),\n      value: this[getTypeName(item.value)](item.value),\n      comment: item.comment && this[getTypeName(item.comment)](item.comment),\n      attributes: item.attributes && item.attributes.map(function (attr) {\n        return _this2.serialize(attr);\n      })\n    };\n  },\n  getIdentifier: function getIdentifier(item) {\n    return item.name;\n  },\n  getStringLiteral: function getStringLiteral(item) {\n    return item.value;\n  },\n  getPattern: function getPattern(item) {\n    var _this3 = this;\n\n    var items = item.elements.map(function (placeable) {\n      if (placeable.expression) {\n        if (!_this3[getTypeName(placeable.expression)]) {\n          return console.log('unknown1', getTypeName(placeable.expression), placeable.expression);\n        }\n\n        return _this3[getTypeName(placeable.expression)](placeable.expression);\n      } else {\n        if (!_this3[getTypeName(placeable)]) {\n          return console.log('unknown2', getTypeName(placeable), placeable);\n        }\n\n        return _this3[getTypeName(placeable)](placeable);\n      }\n    });\n    return items.join('');\n  },\n  getCallExpression: function getCallExpression(item) {\n    var _this4 = this;\n\n    var fcName = item.callee.name;\n    var positionals = item.positional.map(function (positional) {\n      return _this4[getTypeName(positional)](positional, true);\n    });\n    var nameds = item.named.map(function (named) {\n      return _this4[getTypeName(named)](named);\n    });\n    return '{ ' + fcName + '($' + positionals.join(' ') + (nameds.length ? ', ' + nameds.join(', ') : '') + ') }';\n  },\n  getNamedArgument: function getNamedArgument(item) {\n    return this[getTypeName(item.name)](item.name) + ': \"' + this[getTypeName(item.value)](item.value) + '\"';\n  },\n  getTextElement: function getTextElement(item) {\n    return item.value;\n  },\n  getSelectExpression: function getSelectExpression(item) {\n    var _this5 = this;\n\n    var id = this[getTypeName(item.selector)](item.selector, true);\n    var variants = item.variants.map(function (variant) {\n      return _this5[getTypeName(variant)](variant);\n    });\n    return '{ $' + id + ' ->\\n' + variants.join('\\n') + '\\n}';\n  },\n  getVariantExpression: function getVariantExpression(item) {\n    var ref = this[getTypeName(item.ref)](item.ref, true);\n    var key = this[getTypeName(item.key)](item.key);\n    if (key) return '{ ' + ref + '[' + key + '] }';\n    return ' { ' + ref + ' } ';\n  },\n  getVariableReference: function getVariableReference(item, plain) {\n    if (plain) return this[getTypeName(item.id)](item.id);\n    return '{ $' + this[getTypeName(item.id)](item.id) + ' }';\n  },\n  getTermReferences: function getTermReferences(item, plain) {\n    if (plain) return this[getTypeName(item.id)](item.id);\n    return '{ ' + this[getTypeName(item.id)](item.id) + ' }';\n  },\n  getVariantName: function getVariantName(item) {\n    return item.name;\n  },\n  getVariantList: function getVariantList(item) {\n    var _this6 = this;\n\n    var variants = item.variants.map(function (variant) {\n      return _this6[getTypeName(variant)](variant);\n    });\n    return '{\\n' + variants.join('\\n') + '\\n}';\n  },\n  getVariant: function getVariant(item) {\n    var name = item.key.name ? item.key.name : item.key.value;\n    var isDefault = item.default;\n    var pattern = this[getTypeName(item.value)](item.value);\n    var ret = '[' + name + '] ' + pattern;\n    if (isDefault) return ' *' + ret;\n    return '  ' + ret;\n  },\n  getFunctionReference: function getFunctionReference(item) {\n    var args = '';\n    item.arguments.positional.forEach(function (p, i) {\n      if (i > 0) args += ', ';\n      args += \"$\".concat(p.id.name);\n    });\n    item.arguments.named.forEach(function (n, i) {\n      if (i > 0 || args !== '') args += ', ';\n      args += \"\".concat(n.name.name, \": \\\"\").concat(n.value.value, \"\\\"\");\n    });\n    return \"{ \".concat(item.id.name, \"(\").concat(args, \") }\");\n  },\n  getTermReference: function getTermReference(item) {\n    return \"{ -\".concat(item.id.name, \" }\");\n  },\n  getJunk: function getJunk(item) {\n    var parts = item.content.split('=');\n    var key = parts.shift().trim();\n    var value = parts.join('=').trim().replace(/\\n {3}/g, '\\n ').replace(/\\n {2}}/g, '\\n}');\n    return {\n      key: key,\n      value: value\n    };\n  }\n};\n\nfunction ftlToJs(str, cb) {\n  var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    respectComments: true\n  };\n\n  if (typeof str !== 'string') {\n    if (!cb) throw new Error('The first parameter was not a string');\n    return cb(new Error('The first parameter was not a string'));\n  }\n\n  var parsed = parse(str, {\n    withSpans: false\n  });\n  var result = parsed.body.reduce(function (mem, segment) {\n    var item = serializer.serialize(segment);\n    if (!item) return mem;\n\n    if (item.attributes && item.attributes.length || item.comment && params.respectComments) {\n      var inner = {};\n      if (item.comment) inner[item.comment.key] = item.comment.value;\n\n      if (item.attributes && item.attributes.length) {\n        item.attributes.forEach(function (attr) {\n          inner[attr.key] = attr.value;\n        });\n      }\n\n      inner.val = item.value;\n      mem[item.key] = inner;\n    } else {\n      mem[item.key] = item.value;\n    }\n\n    return mem;\n  }, {});\n  if (cb) cb(null, result);\n  return result;\n}\n\nfunction addValue(k, value) {\n  var ftl = '';\n  ftl = ftl + k + ' =';\n\n  if (value && value.indexOf('\\n') > -1) {\n    ftl = ftl + '\\n  ';\n    ftl = ftl + value.split('\\n').join('\\n  ');\n  } else {\n    ftl = ftl + ' ' + value;\n  }\n\n  return ftl;\n}\n\nfunction addComment(comment) {\n  var ftl = '';\n  ftl = ftl + '# ' + comment.split('\\n').join('\\n# ');\n  ftl = ftl + '\\n';\n  return ftl;\n}\n\nfunction js2ftl(resources, cb) {\n  var ftl = '';\n  Object.keys(resources).forEach(function (k) {\n    var value = resources[k];\n\n    if (typeof value === 'string') {\n      ftl = ftl + addValue(k, value);\n      ftl = ftl + '\\n\\n';\n    } else {\n      if (value.comment) ftl = ftl + addComment(value.comment);\n      ftl = ftl + addValue(k, value.val);\n      Object.keys(value).forEach(function (innerK) {\n        if (innerK === 'comment' || innerK === 'val') return;\n        var innerValue = value[innerK];\n        ftl = ftl + addValue('\\n  .' + innerK, innerValue);\n      });\n      ftl = ftl + '\\n\\n';\n    }\n  });\n  if (cb) cb(null, ftl);\n  return ftl;\n}\n\nvar index = {\n  ftl2js: ftlToJs,\n  js2ftl: js2ftl\n};\n\nexport default index;\nexport { ftlToJs as ftl2js, js2ftl };\n"],"sourceRoot":""}