{"version":3,"file":"static/js/848.77b940c2.chunk.js","mappings":"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","sources":["../../file-fluent/dist/es/index-4e34f293.js","../../../node_modules/@babel/runtime/helpers/esm/construct.js","../../../node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js","../../../node_modules/@babel/runtime/helpers/esm/isNativeFunction.js"],"sourcesContent":["/**\n * Base class for all Fluent AST nodes.\n *\n * All productions described in the ASDL subclass BaseNode, including Span and\n * Annotation.\n *\n */\nclass BaseNode {\n    equals(other, ignoredFields = [\"span\"]) {\n        const thisKeys = new Set(Object.keys(this));\n        const otherKeys = new Set(Object.keys(other));\n        if (ignoredFields) {\n            for (const fieldName of ignoredFields) {\n                thisKeys.delete(fieldName);\n                otherKeys.delete(fieldName);\n            }\n        }\n        if (thisKeys.size !== otherKeys.size) {\n            return false;\n        }\n        for (const fieldName of thisKeys) {\n            if (!otherKeys.has(fieldName)) {\n                return false;\n            }\n            const thisVal = this[fieldName];\n            const otherVal = other[fieldName];\n            if (typeof thisVal !== typeof otherVal) {\n                return false;\n            }\n            if (thisVal instanceof Array && otherVal instanceof Array) {\n                if (thisVal.length !== otherVal.length) {\n                    return false;\n                }\n                for (let i = 0; i < thisVal.length; ++i) {\n                    if (!scalarsEqual(thisVal[i], otherVal[i], ignoredFields)) {\n                        return false;\n                    }\n                }\n            }\n            else if (!scalarsEqual(thisVal, otherVal, ignoredFields)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    clone() {\n        function visit(value) {\n            if (value instanceof BaseNode) {\n                return value.clone();\n            }\n            if (Array.isArray(value)) {\n                return value.map(visit);\n            }\n            return value;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        const clone = Object.create(this.constructor.prototype);\n        for (const prop of Object.keys(this)) {\n            clone[prop] = visit(this[prop]);\n        }\n        return clone;\n    }\n}\nfunction scalarsEqual(thisVal, otherVal, ignoredFields) {\n    if (thisVal instanceof BaseNode && otherVal instanceof BaseNode) {\n        return thisVal.equals(otherVal, ignoredFields);\n    }\n    return thisVal === otherVal;\n}\n/**\n * Base class for AST nodes which can have Spans.\n */\nclass SyntaxNode extends BaseNode {\n    /** @ignore */\n    addSpan(start, end) {\n        this.span = new Span(start, end);\n    }\n}\nclass Resource extends SyntaxNode {\n    constructor(body = []) {\n        super();\n        this.type = \"Resource\";\n        this.body = body;\n    }\n}\nclass Message extends SyntaxNode {\n    constructor(id, value = null, attributes = [], comment = null) {\n        super();\n        this.type = \"Message\";\n        this.id = id;\n        this.value = value;\n        this.attributes = attributes;\n        this.comment = comment;\n    }\n}\nclass Term extends SyntaxNode {\n    constructor(id, value, attributes = [], comment = null) {\n        super();\n        this.type = \"Term\";\n        this.id = id;\n        this.value = value;\n        this.attributes = attributes;\n        this.comment = comment;\n    }\n}\nclass Pattern extends SyntaxNode {\n    constructor(elements) {\n        super();\n        this.type = \"Pattern\";\n        this.elements = elements;\n    }\n}\nclass TextElement extends SyntaxNode {\n    constructor(value) {\n        super();\n        this.type = \"TextElement\";\n        this.value = value;\n    }\n}\nclass Placeable extends SyntaxNode {\n    constructor(expression) {\n        super();\n        this.type = \"Placeable\";\n        this.expression = expression;\n    }\n}\n// An abstract base class for Literals.\nclass BaseLiteral extends SyntaxNode {\n    constructor(value) {\n        super();\n        // The \"value\" field contains the exact contents of the literal,\n        // character-for-character.\n        this.value = value;\n    }\n}\nclass StringLiteral extends BaseLiteral {\n    constructor() {\n        super(...arguments);\n        this.type = \"StringLiteral\";\n    }\n    parse() {\n        // Backslash backslash, backslash double quote, uHHHH, UHHHHHH.\n        const KNOWN_ESCAPES = /(?:\\\\\\\\|\\\\\"|\\\\u([0-9a-fA-F]{4})|\\\\U([0-9a-fA-F]{6}))/g;\n        function fromEscapeSequence(match, codepoint4, codepoint6) {\n            switch (match) {\n                case \"\\\\\\\\\":\n                    return \"\\\\\";\n                case '\\\\\"':\n                    return '\"';\n                default: {\n                    let codepoint = parseInt(codepoint4 || codepoint6, 16);\n                    if (codepoint <= 0xd7ff || 0xe000 <= codepoint) {\n                        // It's a Unicode scalar value.\n                        return String.fromCodePoint(codepoint);\n                    }\n                    // Escape sequences reresenting surrogate code points are\n                    // well-formed but invalid in Fluent. Replace them with U+FFFD\n                    // REPLACEMENT CHARACTER.\n                    return \"ï¿½\";\n                }\n            }\n        }\n        let value = this.value.replace(KNOWN_ESCAPES, fromEscapeSequence);\n        return { value };\n    }\n}\nclass NumberLiteral extends BaseLiteral {\n    constructor() {\n        super(...arguments);\n        this.type = \"NumberLiteral\";\n    }\n    parse() {\n        let value = parseFloat(this.value);\n        let decimalPos = this.value.indexOf(\".\");\n        let precision = decimalPos > 0 ? this.value.length - decimalPos - 1 : 0;\n        return { value, precision };\n    }\n}\nclass MessageReference extends SyntaxNode {\n    constructor(id, attribute = null) {\n        super();\n        this.type = \"MessageReference\";\n        this.id = id;\n        this.attribute = attribute;\n    }\n}\nclass TermReference extends SyntaxNode {\n    constructor(id, attribute = null, args = null) {\n        super();\n        this.type = \"TermReference\";\n        this.id = id;\n        this.attribute = attribute;\n        this.arguments = args;\n    }\n}\nclass VariableReference extends SyntaxNode {\n    constructor(id) {\n        super();\n        this.type = \"VariableReference\";\n        this.id = id;\n    }\n}\nclass FunctionReference extends SyntaxNode {\n    constructor(id, args) {\n        super();\n        this.type = \"FunctionReference\";\n        this.id = id;\n        this.arguments = args;\n    }\n}\nclass SelectExpression extends SyntaxNode {\n    constructor(selector, variants) {\n        super();\n        this.type = \"SelectExpression\";\n        this.selector = selector;\n        this.variants = variants;\n    }\n}\nclass CallArguments extends SyntaxNode {\n    constructor(positional = [], named = []) {\n        super();\n        this.type = \"CallArguments\";\n        this.positional = positional;\n        this.named = named;\n    }\n}\nclass Attribute extends SyntaxNode {\n    constructor(id, value) {\n        super();\n        this.type = \"Attribute\";\n        this.id = id;\n        this.value = value;\n    }\n}\nclass Variant extends SyntaxNode {\n    constructor(key, value, def) {\n        super();\n        this.type = \"Variant\";\n        this.key = key;\n        this.value = value;\n        this.default = def;\n    }\n}\nclass NamedArgument extends SyntaxNode {\n    constructor(name, value) {\n        super();\n        this.type = \"NamedArgument\";\n        this.name = name;\n        this.value = value;\n    }\n}\nclass Identifier extends SyntaxNode {\n    constructor(name) {\n        super();\n        this.type = \"Identifier\";\n        this.name = name;\n    }\n}\nclass BaseComment extends SyntaxNode {\n    constructor(content) {\n        super();\n        this.content = content;\n    }\n}\nclass Comment extends BaseComment {\n    constructor() {\n        super(...arguments);\n        this.type = \"Comment\";\n    }\n}\nclass GroupComment extends BaseComment {\n    constructor() {\n        super(...arguments);\n        this.type = \"GroupComment\";\n    }\n}\nclass ResourceComment extends BaseComment {\n    constructor() {\n        super(...arguments);\n        this.type = \"ResourceComment\";\n    }\n}\nclass Junk extends SyntaxNode {\n    constructor(content) {\n        super();\n        this.type = \"Junk\";\n        this.annotations = [];\n        this.content = content;\n    }\n    addAnnotation(annotation) {\n        this.annotations.push(annotation);\n    }\n}\nclass Span extends BaseNode {\n    constructor(start, end) {\n        super();\n        this.type = \"Span\";\n        this.start = start;\n        this.end = end;\n    }\n}\nclass Annotation extends SyntaxNode {\n    constructor(code, args = [], message) {\n        super();\n        this.type = \"Annotation\";\n        this.code = code;\n        this.arguments = args;\n        this.message = message;\n    }\n}\n\n/* eslint-disable @typescript-eslint/restrict-template-expressions */\nclass ParseError extends Error {\n    constructor(code, ...args) {\n        super();\n        this.code = code;\n        this.args = args;\n        this.message = getErrorMessage(code, args);\n    }\n}\n/* eslint-disable complexity */\nfunction getErrorMessage(code, args) {\n    switch (code) {\n        case \"E0001\":\n            return \"Generic error\";\n        case \"E0002\":\n            return \"Expected an entry start\";\n        case \"E0003\": {\n            const [token] = args;\n            return `Expected token: \"${token}\"`;\n        }\n        case \"E0004\": {\n            const [range] = args;\n            return `Expected a character from range: \"${range}\"`;\n        }\n        case \"E0005\": {\n            const [id] = args;\n            return `Expected message \"${id}\" to have a value or attributes`;\n        }\n        case \"E0006\": {\n            const [id] = args;\n            return `Expected term \"-${id}\" to have a value`;\n        }\n        case \"E0007\":\n            return \"Keyword cannot end with a whitespace\";\n        case \"E0008\":\n            return \"The callee has to be an upper-case identifier or a term\";\n        case \"E0009\":\n            return \"The argument name has to be a simple identifier\";\n        case \"E0010\":\n            return \"Expected one of the variants to be marked as default (*)\";\n        case \"E0011\":\n            return 'Expected at least one variant after \"->\"';\n        case \"E0012\":\n            return \"Expected value\";\n        case \"E0013\":\n            return \"Expected variant key\";\n        case \"E0014\":\n            return \"Expected literal\";\n        case \"E0015\":\n            return \"Only one variant can be marked as default (*)\";\n        case \"E0016\":\n            return \"Message references cannot be used as selectors\";\n        case \"E0017\":\n            return \"Terms cannot be used as selectors\";\n        case \"E0018\":\n            return \"Attributes of messages cannot be used as selectors\";\n        case \"E0019\":\n            return \"Attributes of terms cannot be used as placeables\";\n        case \"E0020\":\n            return \"Unterminated string expression\";\n        case \"E0021\":\n            return \"Positional arguments must not follow named arguments\";\n        case \"E0022\":\n            return \"Named arguments must be unique\";\n        case \"E0024\":\n            return \"Cannot access variants of a message.\";\n        case \"E0025\": {\n            const [char] = args;\n            return `Unknown escape sequence: \\\\${char}.`;\n        }\n        case \"E0026\": {\n            const [sequence] = args;\n            return `Invalid Unicode escape sequence: ${sequence}.`;\n        }\n        case \"E0027\":\n            return \"Unbalanced closing brace in TextElement.\";\n        case \"E0028\":\n            return \"Expected an inline expression\";\n        case \"E0029\":\n            return \"Expected simple expression as selector\";\n        default:\n            return code;\n    }\n}\n\n/* eslint no-magic-numbers: \"off\" */\nclass ParserStream {\n    constructor(string) {\n        this.string = string;\n        this.index = 0;\n        this.peekOffset = 0;\n    }\n    charAt(offset) {\n        // When the cursor is at CRLF, return LF but don't move the cursor.\n        // The cursor still points to the EOL position, which in this case is the\n        // beginning of the compound CRLF sequence. This ensures slices of\n        // [inclusive, exclusive) continue to work properly.\n        if (this.string[offset] === \"\\r\" && this.string[offset + 1] === \"\\n\") {\n            return \"\\n\";\n        }\n        return this.string[offset];\n    }\n    currentChar() {\n        return this.charAt(this.index);\n    }\n    currentPeek() {\n        return this.charAt(this.index + this.peekOffset);\n    }\n    next() {\n        this.peekOffset = 0;\n        // Skip over the CRLF as if it was a single character.\n        if (this.string[this.index] === \"\\r\" &&\n            this.string[this.index + 1] === \"\\n\") {\n            this.index++;\n        }\n        this.index++;\n        return this.string[this.index];\n    }\n    peek() {\n        // Skip over the CRLF as if it was a single character.\n        if (this.string[this.index + this.peekOffset] === \"\\r\" &&\n            this.string[this.index + this.peekOffset + 1] === \"\\n\") {\n            this.peekOffset++;\n        }\n        this.peekOffset++;\n        return this.string[this.index + this.peekOffset];\n    }\n    resetPeek(offset = 0) {\n        this.peekOffset = offset;\n    }\n    skipToPeek() {\n        this.index += this.peekOffset;\n        this.peekOffset = 0;\n    }\n}\nconst EOL = \"\\n\";\nconst EOF = undefined;\nconst SPECIAL_LINE_START_CHARS = [\"}\", \".\", \"[\", \"*\"];\nclass FluentParserStream extends ParserStream {\n    peekBlankInline() {\n        const start = this.index + this.peekOffset;\n        while (this.currentPeek() === \" \") {\n            this.peek();\n        }\n        return this.string.slice(start, this.index + this.peekOffset);\n    }\n    skipBlankInline() {\n        const blank = this.peekBlankInline();\n        this.skipToPeek();\n        return blank;\n    }\n    peekBlankBlock() {\n        let blank = \"\";\n        while (true) {\n            const lineStart = this.peekOffset;\n            this.peekBlankInline();\n            if (this.currentPeek() === EOL) {\n                blank += EOL;\n                this.peek();\n                continue;\n            }\n            if (this.currentPeek() === EOF) {\n                // Treat the blank line at EOF as a blank block.\n                return blank;\n            }\n            // Any other char; reset to column 1 on this line.\n            this.resetPeek(lineStart);\n            return blank;\n        }\n    }\n    skipBlankBlock() {\n        const blank = this.peekBlankBlock();\n        this.skipToPeek();\n        return blank;\n    }\n    peekBlank() {\n        while (this.currentPeek() === \" \" || this.currentPeek() === EOL) {\n            this.peek();\n        }\n    }\n    skipBlank() {\n        this.peekBlank();\n        this.skipToPeek();\n    }\n    expectChar(ch) {\n        if (this.currentChar() === ch) {\n            this.next();\n            return;\n        }\n        throw new ParseError(\"E0003\", ch);\n    }\n    expectLineEnd() {\n        if (this.currentChar() === EOF) {\n            // EOF is a valid line end in Fluent.\n            return;\n        }\n        if (this.currentChar() === EOL) {\n            this.next();\n            return;\n        }\n        // Unicode Character 'SYMBOL FOR NEWLINE' (U+2424)\n        throw new ParseError(\"E0003\", \"\\u2424\");\n    }\n    takeChar(f) {\n        const ch = this.currentChar();\n        if (ch === EOF) {\n            return EOF;\n        }\n        if (f(ch)) {\n            this.next();\n            return ch;\n        }\n        return null;\n    }\n    isCharIdStart(ch) {\n        if (ch === EOF) {\n            return false;\n        }\n        const cc = ch.charCodeAt(0);\n        return ((cc >= 97 && cc <= 122) || // a-z\n            (cc >= 65 && cc <= 90)); // A-Z\n    }\n    isIdentifierStart() {\n        return this.isCharIdStart(this.currentPeek());\n    }\n    isNumberStart() {\n        const ch = this.currentChar() === \"-\" ? this.peek() : this.currentChar();\n        if (ch === EOF) {\n            this.resetPeek();\n            return false;\n        }\n        const cc = ch.charCodeAt(0);\n        const isDigit = cc >= 48 && cc <= 57; // 0-9\n        this.resetPeek();\n        return isDigit;\n    }\n    isCharPatternContinuation(ch) {\n        if (ch === EOF) {\n            return false;\n        }\n        return !SPECIAL_LINE_START_CHARS.includes(ch);\n    }\n    isValueStart() {\n        // Inline Patterns may start with any char.\n        const ch = this.currentPeek();\n        return ch !== EOL && ch !== EOF;\n    }\n    isValueContinuation() {\n        const column1 = this.peekOffset;\n        this.peekBlankInline();\n        if (this.currentPeek() === \"{\") {\n            this.resetPeek(column1);\n            return true;\n        }\n        if (this.peekOffset - column1 === 0) {\n            return false;\n        }\n        if (this.isCharPatternContinuation(this.currentPeek())) {\n            this.resetPeek(column1);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * @param level - -1: any, 0: comment, 1: group comment, 2: resource comment\n     */\n    isNextLineComment(level = -1) {\n        if (this.currentChar() !== EOL) {\n            return false;\n        }\n        let i = 0;\n        while (i <= level || (level === -1 && i < 3)) {\n            if (this.peek() !== \"#\") {\n                if (i <= level && level !== -1) {\n                    this.resetPeek();\n                    return false;\n                }\n                break;\n            }\n            i++;\n        }\n        // The first char after #, ## or ###.\n        const ch = this.peek();\n        if (ch === \" \" || ch === EOL) {\n            this.resetPeek();\n            return true;\n        }\n        this.resetPeek();\n        return false;\n    }\n    isVariantStart() {\n        const currentPeekOffset = this.peekOffset;\n        if (this.currentPeek() === \"*\") {\n            this.peek();\n        }\n        if (this.currentPeek() === \"[\") {\n            this.resetPeek(currentPeekOffset);\n            return true;\n        }\n        this.resetPeek(currentPeekOffset);\n        return false;\n    }\n    isAttributeStart() {\n        return this.currentPeek() === \".\";\n    }\n    skipToNextEntryStart(junkStart) {\n        let lastNewline = this.string.lastIndexOf(EOL, this.index);\n        if (junkStart < lastNewline) {\n            // Last seen newline is _after_ the junk start. It's safe to rewind\n            // without the risk of resuming at the same broken entry.\n            this.index = lastNewline;\n        }\n        while (this.currentChar()) {\n            // We're only interested in beginnings of line.\n            if (this.currentChar() !== EOL) {\n                this.next();\n                continue;\n            }\n            // Break if the first char in this line looks like an entry start.\n            const first = this.next();\n            if (this.isCharIdStart(first) || first === \"-\" || first === \"#\") {\n                break;\n            }\n        }\n    }\n    takeIDStart() {\n        if (this.isCharIdStart(this.currentChar())) {\n            const ret = this.currentChar();\n            this.next();\n            return ret;\n        }\n        throw new ParseError(\"E0004\", \"a-zA-Z\");\n    }\n    takeIDChar() {\n        const closure = (ch) => {\n            const cc = ch.charCodeAt(0);\n            return ((cc >= 97 && cc <= 122) || // a-z\n                (cc >= 65 && cc <= 90) || // A-Z\n                (cc >= 48 && cc <= 57) || // 0-9\n                cc === 95 ||\n                cc === 45); // _-\n        };\n        return this.takeChar(closure);\n    }\n    takeDigit() {\n        const closure = (ch) => {\n            const cc = ch.charCodeAt(0);\n            return cc >= 48 && cc <= 57; // 0-9\n        };\n        return this.takeChar(closure);\n    }\n    takeHexDigit() {\n        const closure = (ch) => {\n            const cc = ch.charCodeAt(0);\n            return ((cc >= 48 && cc <= 57) || // 0-9\n                (cc >= 65 && cc <= 70) || // A-F\n                (cc >= 97 && cc <= 102)); // a-f\n        };\n        return this.takeChar(closure);\n    }\n}\n\n/*  eslint no-magic-numbers: [0]  */\nconst trailingWSRe = /[ \\n\\r]+$/;\nfunction withSpan(fn) {\n    return function (ps, ...args) {\n        if (!this.withSpans) {\n            return fn.call(this, ps, ...args);\n        }\n        const start = ps.index;\n        const node = fn.call(this, ps, ...args);\n        // Don't re-add the span if the node already has it. This may happen when\n        // one decorated function calls another decorated function.\n        if (node.span) {\n            return node;\n        }\n        const end = ps.index;\n        node.addSpan(start, end);\n        return node;\n    };\n}\nclass FluentParser {\n    constructor({ withSpans = true } = {}) {\n        this.withSpans = withSpans;\n        // Poor man's decorators.\n        /* eslint-disable @typescript-eslint/unbound-method */\n        this.getComment = withSpan(this.getComment);\n        this.getMessage = withSpan(this.getMessage);\n        this.getTerm = withSpan(this.getTerm);\n        this.getAttribute = withSpan(this.getAttribute);\n        this.getIdentifier = withSpan(this.getIdentifier);\n        this.getVariant = withSpan(this.getVariant);\n        this.getNumber = withSpan(this.getNumber);\n        this.getPattern = withSpan(this.getPattern);\n        this.getTextElement = withSpan(this.getTextElement);\n        this.getPlaceable = withSpan(this.getPlaceable);\n        this.getExpression = withSpan(this.getExpression);\n        this.getInlineExpression = withSpan(this.getInlineExpression);\n        this.getCallArgument = withSpan(this.getCallArgument);\n        this.getCallArguments = withSpan(this.getCallArguments);\n        this.getString = withSpan(this.getString);\n        this.getLiteral = withSpan(this.getLiteral);\n        this.getComment = withSpan(this.getComment);\n        /* eslint-enable @typescript-eslint/unbound-method */\n    }\n    parse(source) {\n        const ps = new FluentParserStream(source);\n        ps.skipBlankBlock();\n        const entries = [];\n        let lastComment = null;\n        while (ps.currentChar()) {\n            const entry = this.getEntryOrJunk(ps);\n            const blankLines = ps.skipBlankBlock();\n            // Regular Comments require special logic. Comments may be attached to\n            // Messages or Terms if they are followed immediately by them. However\n            // they should parse as standalone when they're followed by Junk.\n            // Consequently, we only attach Comments once we know that the Message\n            // or the Term parsed successfully.\n            if (entry instanceof Comment &&\n                blankLines.length === 0 &&\n                ps.currentChar()) {\n                // Stash the comment and decide what to do with it in the next pass.\n                lastComment = entry;\n                continue;\n            }\n            if (lastComment) {\n                if (entry instanceof Message || entry instanceof Term) {\n                    entry.comment = lastComment;\n                    if (this.withSpans) {\n                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                        entry.span.start = entry.comment.span.start;\n                    }\n                }\n                else {\n                    entries.push(lastComment);\n                }\n                // In either case, the stashed comment has been dealt with; clear it.\n                lastComment = null;\n            }\n            // No special logic for other types of entries.\n            entries.push(entry);\n        }\n        const res = new Resource(entries);\n        if (this.withSpans) {\n            res.addSpan(0, ps.index);\n        }\n        return res;\n    }\n    /**\n     * Parse the first Message or Term in `source`.\n     *\n     * Skip all encountered comments and start parsing at the first Message or\n     * Term start. Return Junk if the parsing is not successful.\n     *\n     * Preceding comments are ignored unless they contain syntax errors\n     * themselves, in which case Junk for the invalid comment is returned.\n     */\n    parseEntry(source) {\n        const ps = new FluentParserStream(source);\n        ps.skipBlankBlock();\n        while (ps.currentChar() === \"#\") {\n            const skipped = this.getEntryOrJunk(ps);\n            if (skipped instanceof Junk) {\n                // Don't skip Junk comments.\n                return skipped;\n            }\n            ps.skipBlankBlock();\n        }\n        return this.getEntryOrJunk(ps);\n    }\n    getEntryOrJunk(ps) {\n        const entryStartPos = ps.index;\n        try {\n            const entry = this.getEntry(ps);\n            ps.expectLineEnd();\n            return entry;\n        }\n        catch (err) {\n            if (!(err instanceof ParseError)) {\n                throw err;\n            }\n            let errorIndex = ps.index;\n            ps.skipToNextEntryStart(entryStartPos);\n            const nextEntryStart = ps.index;\n            if (nextEntryStart < errorIndex) {\n                // The position of the error must be inside of the Junk's span.\n                errorIndex = nextEntryStart;\n            }\n            // Create a Junk instance\n            const slice = ps.string.substring(entryStartPos, nextEntryStart);\n            const junk = new Junk(slice);\n            if (this.withSpans) {\n                junk.addSpan(entryStartPos, nextEntryStart);\n            }\n            const annot = new Annotation(err.code, err.args, err.message);\n            annot.addSpan(errorIndex, errorIndex);\n            junk.addAnnotation(annot);\n            return junk;\n        }\n    }\n    getEntry(ps) {\n        if (ps.currentChar() === \"#\") {\n            return this.getComment(ps);\n        }\n        if (ps.currentChar() === \"-\") {\n            return this.getTerm(ps);\n        }\n        if (ps.isIdentifierStart()) {\n            return this.getMessage(ps);\n        }\n        throw new ParseError(\"E0002\");\n    }\n    getComment(ps) {\n        // 0 - comment\n        // 1 - group comment\n        // 2 - resource comment\n        let level = -1;\n        let content = \"\";\n        while (true) {\n            let i = -1;\n            while (ps.currentChar() === \"#\" && i < (level === -1 ? 2 : level)) {\n                ps.next();\n                i++;\n            }\n            if (level === -1) {\n                level = i;\n            }\n            if (ps.currentChar() !== EOL) {\n                ps.expectChar(\" \");\n                let ch;\n                while ((ch = ps.takeChar(x => x !== EOL))) {\n                    content += ch;\n                }\n            }\n            if (ps.isNextLineComment(level)) {\n                content += ps.currentChar();\n                ps.next();\n            }\n            else {\n                break;\n            }\n        }\n        let Comment$1;\n        switch (level) {\n            case 0:\n                Comment$1 = Comment;\n                break;\n            case 1:\n                Comment$1 = GroupComment;\n                break;\n            default:\n                Comment$1 = ResourceComment;\n        }\n        return new Comment$1(content);\n    }\n    getMessage(ps) {\n        const id = this.getIdentifier(ps);\n        ps.skipBlankInline();\n        ps.expectChar(\"=\");\n        const value = this.maybeGetPattern(ps);\n        const attrs = this.getAttributes(ps);\n        if (value === null && attrs.length === 0) {\n            throw new ParseError(\"E0005\", id.name);\n        }\n        return new Message(id, value, attrs);\n    }\n    getTerm(ps) {\n        ps.expectChar(\"-\");\n        const id = this.getIdentifier(ps);\n        ps.skipBlankInline();\n        ps.expectChar(\"=\");\n        const value = this.maybeGetPattern(ps);\n        if (value === null) {\n            throw new ParseError(\"E0006\", id.name);\n        }\n        const attrs = this.getAttributes(ps);\n        return new Term(id, value, attrs);\n    }\n    getAttribute(ps) {\n        ps.expectChar(\".\");\n        const key = this.getIdentifier(ps);\n        ps.skipBlankInline();\n        ps.expectChar(\"=\");\n        const value = this.maybeGetPattern(ps);\n        if (value === null) {\n            throw new ParseError(\"E0012\");\n        }\n        return new Attribute(key, value);\n    }\n    getAttributes(ps) {\n        const attrs = [];\n        ps.peekBlank();\n        while (ps.isAttributeStart()) {\n            ps.skipToPeek();\n            const attr = this.getAttribute(ps);\n            attrs.push(attr);\n            ps.peekBlank();\n        }\n        return attrs;\n    }\n    getIdentifier(ps) {\n        let name = ps.takeIDStart();\n        let ch;\n        while ((ch = ps.takeIDChar())) {\n            name += ch;\n        }\n        return new Identifier(name);\n    }\n    getVariantKey(ps) {\n        const ch = ps.currentChar();\n        if (ch === EOF) {\n            throw new ParseError(\"E0013\");\n        }\n        const cc = ch.charCodeAt(0);\n        if ((cc >= 48 && cc <= 57) || cc === 45) {\n            // 0-9, -\n            return this.getNumber(ps);\n        }\n        return this.getIdentifier(ps);\n    }\n    getVariant(ps, hasDefault = false) {\n        let defaultIndex = false;\n        if (ps.currentChar() === \"*\") {\n            if (hasDefault) {\n                throw new ParseError(\"E0015\");\n            }\n            ps.next();\n            defaultIndex = true;\n        }\n        ps.expectChar(\"[\");\n        ps.skipBlank();\n        const key = this.getVariantKey(ps);\n        ps.skipBlank();\n        ps.expectChar(\"]\");\n        const value = this.maybeGetPattern(ps);\n        if (value === null) {\n            throw new ParseError(\"E0012\");\n        }\n        return new Variant(key, value, defaultIndex);\n    }\n    getVariants(ps) {\n        const variants = [];\n        let hasDefault = false;\n        ps.skipBlank();\n        while (ps.isVariantStart()) {\n            const variant = this.getVariant(ps, hasDefault);\n            if (variant.default) {\n                hasDefault = true;\n            }\n            variants.push(variant);\n            ps.expectLineEnd();\n            ps.skipBlank();\n        }\n        if (variants.length === 0) {\n            throw new ParseError(\"E0011\");\n        }\n        if (!hasDefault) {\n            throw new ParseError(\"E0010\");\n        }\n        return variants;\n    }\n    getDigits(ps) {\n        let num = \"\";\n        let ch;\n        while ((ch = ps.takeDigit())) {\n            num += ch;\n        }\n        if (num.length === 0) {\n            throw new ParseError(\"E0004\", \"0-9\");\n        }\n        return num;\n    }\n    getNumber(ps) {\n        let value = \"\";\n        if (ps.currentChar() === \"-\") {\n            ps.next();\n            value += `-${this.getDigits(ps)}`;\n        }\n        else {\n            value += this.getDigits(ps);\n        }\n        if (ps.currentChar() === \".\") {\n            ps.next();\n            value += `.${this.getDigits(ps)}`;\n        }\n        return new NumberLiteral(value);\n    }\n    /**\n     * maybeGetPattern distinguishes between patterns which start on the same line\n     * as the identifier (a.k.a. inline signleline patterns and inline multiline\n     * patterns) and patterns which start on a new line (a.k.a. block multiline\n     * patterns). The distinction is important for the dedentation logic: the\n     * indent of the first line of a block pattern must be taken into account when\n     * calculating the maximum common indent.\n     */\n    maybeGetPattern(ps) {\n        ps.peekBlankInline();\n        if (ps.isValueStart()) {\n            ps.skipToPeek();\n            return this.getPattern(ps, false);\n        }\n        ps.peekBlankBlock();\n        if (ps.isValueContinuation()) {\n            ps.skipToPeek();\n            return this.getPattern(ps, true);\n        }\n        return null;\n    }\n    getPattern(ps, isBlock) {\n        const elements = [];\n        let commonIndentLength;\n        if (isBlock) {\n            // A block pattern is a pattern which starts on a new line. Store and\n            // measure the indent of this first line for the dedentation logic.\n            const blankStart = ps.index;\n            const firstIndent = ps.skipBlankInline();\n            elements.push(this.getIndent(ps, firstIndent, blankStart));\n            commonIndentLength = firstIndent.length;\n        }\n        else {\n            commonIndentLength = Infinity;\n        }\n        let ch;\n        elements: while ((ch = ps.currentChar())) {\n            switch (ch) {\n                case EOL: {\n                    const blankStart = ps.index;\n                    const blankLines = ps.peekBlankBlock();\n                    if (ps.isValueContinuation()) {\n                        ps.skipToPeek();\n                        const indent = ps.skipBlankInline();\n                        commonIndentLength = Math.min(commonIndentLength, indent.length);\n                        elements.push(this.getIndent(ps, blankLines + indent, blankStart));\n                        continue elements;\n                    }\n                    // The end condition for getPattern's while loop is a newline\n                    // which is not followed by a valid pattern continuation.\n                    ps.resetPeek();\n                    break elements;\n                }\n                case \"{\":\n                    elements.push(this.getPlaceable(ps));\n                    continue elements;\n                case \"}\":\n                    throw new ParseError(\"E0027\");\n                default:\n                    elements.push(this.getTextElement(ps));\n            }\n        }\n        const dedented = this.dedent(elements, commonIndentLength);\n        return new Pattern(dedented);\n    }\n    /**\n     * Create a token representing an indent. It's not part of the AST and it will\n     * be trimmed and merged into adjacent TextElements, or turned into a new\n     * TextElement, if it's surrounded by two Placeables.\n     */\n    getIndent(ps, value, start) {\n        return new Indent(value, start, ps.index);\n    }\n    /**\n     * Dedent a list of elements by removing the maximum common indent from the\n     * beginning of text lines. The common indent is calculated in getPattern.\n     */\n    dedent(elements, commonIndent) {\n        const trimmed = [];\n        for (let element of elements) {\n            if (element instanceof Placeable) {\n                trimmed.push(element);\n                continue;\n            }\n            if (element instanceof Indent) {\n                // Strip common indent.\n                element.value = element.value.slice(0, element.value.length - commonIndent);\n                if (element.value.length === 0) {\n                    continue;\n                }\n            }\n            let prev = trimmed[trimmed.length - 1];\n            if (prev && prev instanceof TextElement) {\n                // Join adjacent TextElements by replacing them with their sum.\n                const sum = new TextElement(prev.value + element.value);\n                if (this.withSpans) {\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    sum.addSpan(prev.span.start, element.span.end);\n                }\n                trimmed[trimmed.length - 1] = sum;\n                continue;\n            }\n            if (element instanceof Indent) {\n                // If the indent hasn't been merged into a preceding TextElement,\n                // convert it into a new TextElement.\n                const textElement = new TextElement(element.value);\n                if (this.withSpans) {\n                    textElement.addSpan(element.span.start, element.span.end);\n                }\n                element = textElement;\n            }\n            trimmed.push(element);\n        }\n        // Trim trailing whitespace from the Pattern.\n        const lastElement = trimmed[trimmed.length - 1];\n        if (lastElement instanceof TextElement) {\n            lastElement.value = lastElement.value.replace(trailingWSRe, \"\");\n            if (lastElement.value.length === 0) {\n                trimmed.pop();\n            }\n        }\n        return trimmed;\n    }\n    getTextElement(ps) {\n        let buffer = \"\";\n        let ch;\n        while ((ch = ps.currentChar())) {\n            if (ch === \"{\" || ch === \"}\") {\n                return new TextElement(buffer);\n            }\n            if (ch === EOL) {\n                return new TextElement(buffer);\n            }\n            buffer += ch;\n            ps.next();\n        }\n        return new TextElement(buffer);\n    }\n    getEscapeSequence(ps) {\n        const next = ps.currentChar();\n        switch (next) {\n            case \"\\\\\":\n            case '\"':\n                ps.next();\n                return `\\\\${next}`;\n            case \"u\":\n                return this.getUnicodeEscapeSequence(ps, next, 4);\n            case \"U\":\n                return this.getUnicodeEscapeSequence(ps, next, 6);\n            default:\n                throw new ParseError(\"E0025\", next);\n        }\n    }\n    getUnicodeEscapeSequence(ps, u, digits) {\n        ps.expectChar(u);\n        let sequence = \"\";\n        for (let i = 0; i < digits; i++) {\n            const ch = ps.takeHexDigit();\n            if (!ch) {\n                throw new ParseError(\"E0026\", `\\\\${u}${sequence}${ps.currentChar()}`);\n            }\n            sequence += ch;\n        }\n        return `\\\\${u}${sequence}`;\n    }\n    getPlaceable(ps) {\n        ps.expectChar(\"{\");\n        ps.skipBlank();\n        const expression = this.getExpression(ps);\n        ps.expectChar(\"}\");\n        return new Placeable(expression);\n    }\n    getExpression(ps) {\n        const selector = this.getInlineExpression(ps);\n        ps.skipBlank();\n        if (ps.currentChar() === \"-\") {\n            if (ps.peek() !== \">\") {\n                ps.resetPeek();\n                return selector;\n            }\n            // Validate selector expression according to\n            // abstract.js in the Fluent specification\n            if (selector instanceof MessageReference) {\n                if (selector.attribute === null) {\n                    throw new ParseError(\"E0016\");\n                }\n                else {\n                    throw new ParseError(\"E0018\");\n                }\n            }\n            else if (selector instanceof TermReference) {\n                if (selector.attribute === null) {\n                    throw new ParseError(\"E0017\");\n                }\n            }\n            else if (selector instanceof Placeable) {\n                throw new ParseError(\"E0029\");\n            }\n            ps.next();\n            ps.next();\n            ps.skipBlankInline();\n            ps.expectLineEnd();\n            const variants = this.getVariants(ps);\n            return new SelectExpression(selector, variants);\n        }\n        if (selector instanceof TermReference && selector.attribute !== null) {\n            throw new ParseError(\"E0019\");\n        }\n        return selector;\n    }\n    getInlineExpression(ps) {\n        if (ps.currentChar() === \"{\") {\n            return this.getPlaceable(ps);\n        }\n        if (ps.isNumberStart()) {\n            return this.getNumber(ps);\n        }\n        if (ps.currentChar() === '\"') {\n            return this.getString(ps);\n        }\n        if (ps.currentChar() === \"$\") {\n            ps.next();\n            const id = this.getIdentifier(ps);\n            return new VariableReference(id);\n        }\n        if (ps.currentChar() === \"-\") {\n            ps.next();\n            const id = this.getIdentifier(ps);\n            let attr;\n            if (ps.currentChar() === \".\") {\n                ps.next();\n                attr = this.getIdentifier(ps);\n            }\n            let args;\n            ps.peekBlank();\n            if (ps.currentPeek() === \"(\") {\n                ps.skipToPeek();\n                args = this.getCallArguments(ps);\n            }\n            return new TermReference(id, attr, args);\n        }\n        if (ps.isIdentifierStart()) {\n            const id = this.getIdentifier(ps);\n            ps.peekBlank();\n            if (ps.currentPeek() === \"(\") {\n                // It's a Function. Ensure it's all upper-case.\n                if (!/^[A-Z][A-Z0-9_-]*$/.test(id.name)) {\n                    throw new ParseError(\"E0008\");\n                }\n                ps.skipToPeek();\n                let args = this.getCallArguments(ps);\n                return new FunctionReference(id, args);\n            }\n            let attr;\n            if (ps.currentChar() === \".\") {\n                ps.next();\n                attr = this.getIdentifier(ps);\n            }\n            return new MessageReference(id, attr);\n        }\n        throw new ParseError(\"E0028\");\n    }\n    getCallArgument(ps) {\n        const exp = this.getInlineExpression(ps);\n        ps.skipBlank();\n        if (ps.currentChar() !== \":\") {\n            return exp;\n        }\n        if (exp instanceof MessageReference && exp.attribute === null) {\n            ps.next();\n            ps.skipBlank();\n            const value = this.getLiteral(ps);\n            return new NamedArgument(exp.id, value);\n        }\n        throw new ParseError(\"E0009\");\n    }\n    getCallArguments(ps) {\n        const positional = [];\n        const named = [];\n        const argumentNames = new Set();\n        ps.expectChar(\"(\");\n        ps.skipBlank();\n        while (true) {\n            if (ps.currentChar() === \")\") {\n                break;\n            }\n            const arg = this.getCallArgument(ps);\n            if (arg instanceof NamedArgument) {\n                if (argumentNames.has(arg.name.name)) {\n                    throw new ParseError(\"E0022\");\n                }\n                named.push(arg);\n                argumentNames.add(arg.name.name);\n            }\n            else if (argumentNames.size > 0) {\n                throw new ParseError(\"E0021\");\n            }\n            else {\n                positional.push(arg);\n            }\n            ps.skipBlank();\n            if (ps.currentChar() === \",\") {\n                ps.next();\n                ps.skipBlank();\n                continue;\n            }\n            break;\n        }\n        ps.expectChar(\")\");\n        return new CallArguments(positional, named);\n    }\n    getString(ps) {\n        ps.expectChar('\"');\n        let value = \"\";\n        let ch;\n        while ((ch = ps.takeChar(x => x !== '\"' && x !== EOL))) {\n            if (ch === \"\\\\\") {\n                value += this.getEscapeSequence(ps);\n            }\n            else {\n                value += ch;\n            }\n        }\n        if (ps.currentChar() === EOL) {\n            throw new ParseError(\"E0020\");\n        }\n        ps.expectChar('\"');\n        return new StringLiteral(value);\n    }\n    getLiteral(ps) {\n        if (ps.isNumberStart()) {\n            return this.getNumber(ps);\n        }\n        if (ps.currentChar() === '\"') {\n            return this.getString(ps);\n        }\n        throw new ParseError(\"E0014\");\n    }\n}\nclass Indent {\n    /** @ignore */\n    constructor(value, start, end) {\n        this.type = \"Indent\";\n        this.value = value;\n        this.span = new Span(start, end);\n    }\n}\n\nfunction parse(source, opts) {\n    const parser = new FluentParser(opts);\n    return parser.parse(source);\n}\n\nvar getTypeName = function getTypeName(item) {\n  return 'get' + item.type;\n};\nvar serializer = {\n  serialize: function serialize(item) {\n    if (this[getTypeName(item)]) {\n      return this[getTypeName(item)](item);\n    } else {\n      console.warn('unknown type:', item.type, item);\n    }\n  },\n  getComment: function getComment(item) {\n    return {\n      key: 'comment',\n      value: item.content\n    };\n  },\n  getGroupComment: function getGroupComment() {\n    return null;\n  },\n  getResourceComment: function getResourceComment() {\n    return null;\n  },\n  getMessage: function getMessage(item) {\n    var _this = this;\n    return {\n      key: this[getTypeName(item.id)](item.id),\n      value: this[getTypeName(item.value)](item.value),\n      comment: item.comment && this[getTypeName(item.comment)](item.comment),\n      attributes: item.attributes && item.attributes.map(function (attr) {\n        return _this.serialize(attr);\n      })\n    };\n  },\n  getAttribute: function getAttribute(item) {\n    return {\n      key: this[getTypeName(item.id)](item.id),\n      value: this[getTypeName(item.value)](item.value)\n    };\n  },\n  getTerm: function getTerm(item) {\n    var _this2 = this;\n    return {\n      key: \"-\".concat(this[getTypeName(item.id)](item.id)),\n      value: this[getTypeName(item.value)](item.value),\n      comment: item.comment && this[getTypeName(item.comment)](item.comment),\n      attributes: item.attributes && item.attributes.map(function (attr) {\n        return _this2.serialize(attr);\n      })\n    };\n  },\n  getIdentifier: function getIdentifier(item) {\n    return item.name;\n  },\n  getStringLiteral: function getStringLiteral(item) {\n    return item.value;\n  },\n  getPattern: function getPattern(item) {\n    var _this3 = this;\n    var items = item.elements.map(function (placeable) {\n      if (placeable.expression) {\n        if (!_this3[getTypeName(placeable.expression)]) {\n          return console.log('unknown1', getTypeName(placeable.expression), placeable.expression);\n        }\n        return _this3[getTypeName(placeable.expression)](placeable.expression);\n      } else {\n        if (!_this3[getTypeName(placeable)]) {\n          return console.log('unknown2', getTypeName(placeable), placeable);\n        }\n        return _this3[getTypeName(placeable)](placeable);\n      }\n    });\n    return items.join('');\n  },\n  getCallExpression: function getCallExpression(item) {\n    var _this4 = this;\n    var fcName = item.callee.name;\n    var positionals = item.positional.map(function (positional) {\n      return _this4[getTypeName(positional)](positional, true);\n    });\n    var nameds = item.named.map(function (named) {\n      return _this4[getTypeName(named)](named);\n    });\n    return '{ ' + fcName + '($' + positionals.join(' ') + (nameds.length ? ', ' + nameds.join(', ') : '') + ') }';\n  },\n  getNamedArgument: function getNamedArgument(item) {\n    return this[getTypeName(item.name)](item.name) + ': \"' + this[getTypeName(item.value)](item.value) + '\"';\n  },\n  getTextElement: function getTextElement(item) {\n    return item.value;\n  },\n  getSelectExpression: function getSelectExpression(item) {\n    var _this5 = this;\n    var id = this[getTypeName(item.selector)](item.selector, true);\n    var variants = item.variants.map(function (variant) {\n      return _this5[getTypeName(variant)](variant);\n    });\n    return '{ $' + id + ' ->\\n' + variants.join('\\n') + '\\n}';\n  },\n  getVariantExpression: function getVariantExpression(item) {\n    var ref = this[getTypeName(item.ref)](item.ref, true);\n    var key = this[getTypeName(item.key)](item.key);\n    if (key) return '{ ' + ref + '[' + key + '] }';\n    return ' { ' + ref + ' } ';\n  },\n  getVariableReference: function getVariableReference(item, plain) {\n    if (plain) return this[getTypeName(item.id)](item.id);\n    return '{ $' + this[getTypeName(item.id)](item.id) + ' }';\n  },\n  getTermReferences: function getTermReferences(item, plain) {\n    if (plain) return this[getTypeName(item.id)](item.id);\n    return '{ ' + this[getTypeName(item.id)](item.id) + ' }';\n  },\n  getVariantName: function getVariantName(item) {\n    return item.name;\n  },\n  getVariantList: function getVariantList(item) {\n    var _this6 = this;\n    var variants = item.variants.map(function (variant) {\n      return _this6[getTypeName(variant)](variant);\n    });\n    return '{\\n' + variants.join('\\n') + '\\n}';\n  },\n  getVariant: function getVariant(item) {\n    var name = item.key.name ? item.key.name : item.key.value;\n    var isDefault = item.default;\n    var pattern = this[getTypeName(item.value)](item.value);\n    var ret = '[' + name + '] ' + pattern;\n    if (isDefault) return ' *' + ret;\n    return '  ' + ret;\n  },\n  getFunctionReference: function getFunctionReference(item) {\n    var args = '';\n    item.arguments.positional.forEach(function (p, i) {\n      if (i > 0) args += ', ';\n      args += \"$\".concat(p.id.name);\n    });\n    item.arguments.named.forEach(function (n, i) {\n      if (i > 0 || args !== '') args += ', ';\n      args += \"\".concat(n.name.name, \": \\\"\").concat(n.value.value, \"\\\"\");\n    });\n    return \"{ \".concat(item.id.name, \"(\").concat(args, \") }\");\n  },\n  getTermReference: function getTermReference(item) {\n    return \"{ -\".concat(item.id.name, \" }\");\n  },\n  getMessageReference: function getMessageReference(item) {\n    return \"{ \".concat(item.id.name, \" }\");\n  },\n  getJunk: function getJunk(item) {\n    var parts = item.content.split('=');\n    var key = parts.shift().trim();\n    var value = parts.join('=').trim().replace(/\\n {3}/g, '\\n ').replace(/\\n {2}}/g, '\\n}');\n    return {\n      key: key,\n      value: value\n    };\n  }\n};\n\nfunction ftlToJs(str, cb) {\n  var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    respectComments: true\n  };\n  if (typeof str !== 'string') {\n    if (!cb) throw new Error('The first parameter was not a string');\n    return cb(new Error('The first parameter was not a string'));\n  }\n  var parsed = parse(str, {\n    withSpans: false\n  });\n  var result = parsed.body.reduce(function (mem, segment) {\n    var item = serializer.serialize(segment);\n    if (!item) return mem;\n    if (item.attributes && item.attributes.length || item.comment && params.respectComments) {\n      var inner = {};\n      if (item.comment) inner[item.comment.key] = item.comment.value;\n      if (item.attributes && item.attributes.length) {\n        item.attributes.forEach(function (attr) {\n          inner[attr.key] = attr.value;\n        });\n      }\n      inner.val = item.value;\n      mem[item.key] = inner;\n    } else {\n      mem[item.key] = item.value;\n    }\n    return mem;\n  }, {});\n  if (cb) cb(null, result);\n  return result;\n}\n\nfunction addValue(k, value) {\n  var ftl = '';\n  ftl = ftl + k + ' =';\n  if (value && value.indexOf('\\n') > -1) {\n    ftl = ftl + '\\n  ';\n    ftl = ftl + value.split('\\n').join('\\n  ');\n  } else {\n    ftl = ftl + ' ' + value;\n  }\n  return ftl;\n}\nfunction addComment(comment) {\n  var ftl = '';\n  ftl = ftl + '# ' + comment.split('\\n').join('\\n# ');\n  ftl = ftl + '\\n';\n  return ftl;\n}\nfunction js2ftl(resources, cb) {\n  var ftl = '';\n  Object.keys(resources).forEach(function (k) {\n    var value = resources[k];\n    if (typeof value === 'string') {\n      ftl = ftl + addValue(k, value);\n      ftl = ftl + '\\n\\n';\n    } else {\n      if (value.comment) ftl = ftl + addComment(value.comment);\n      ftl = ftl + addValue(k, value.val);\n      Object.keys(value).forEach(function (innerK) {\n        if (innerK === 'comment' || innerK === 'val') return;\n        var innerValue = value[innerK];\n        ftl = ftl + addValue('\\n  .' + innerK, innerValue);\n      });\n      ftl = ftl + '\\n\\n';\n    }\n  });\n  if (cb) cb(null, ftl);\n  return ftl;\n}\n\nvar index = {\n  ftl2js: ftlToJs,\n  js2ftl: js2ftl\n};\n\nexport default index;\nexport { ftlToJs as ftl2js, js2ftl };\n","import setPrototypeOf from \"./setPrototypeOf.js\";\nimport isNativeReflectConstruct from \"./isNativeReflectConstruct.js\";\nexport default function _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    _construct = Reflect.construct.bind();\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n  return _construct.apply(null, arguments);\n}","import getPrototypeOf from \"./getPrototypeOf.js\";\nimport setPrototypeOf from \"./setPrototypeOf.js\";\nimport isNativeFunction from \"./isNativeFunction.js\";\nimport construct from \"./construct.js\";\nexport default function _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n      _cache.set(Class, Wrapper);\n    }\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  };\n  return _wrapNativeSuper(Class);\n}","export default function _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}"],"names":["BaseNode","other","ignoredFields","thisKeys","Set","Object","keys","this","otherKeys","fieldName","delete","size","has","thisVal","otherVal","Array","length","i","scalarsEqual","visit","value","clone","isArray","map","create","constructor","prototype","prop","equals","SyntaxNode","start","end","span","Span","Resource","body","type","Message","id","attributes","comment","Term","Pattern","elements","TextElement","Placeable","expression","BaseLiteral","StringLiteral","arguments","replace","match","codepoint4","codepoint6","codepoint","parseInt","String","fromCodePoint","NumberLiteral","parseFloat","decimalPos","indexOf","precision","MessageReference","attribute","TermReference","args","VariableReference","FunctionReference","SelectExpression","selector","variants","CallArguments","positional","named","Attribute","Variant","key","def","default","NamedArgument","name","Identifier","BaseComment","content","Comment","GroupComment","ResourceComment","Junk","annotations","annotation","push","Annotation","code","message","ParseError","getErrorMessage","Error","token","range","char","sequence","ParserStream","string","index","peekOffset","offset","charAt","EOL","EOF","undefined","SPECIAL_LINE_START_CHARS","FluentParserStream","currentPeek","peek","slice","blank","peekBlankInline","skipToPeek","lineStart","resetPeek","peekBlankBlock","peekBlank","ch","currentChar","next","f","cc","charCodeAt","isCharIdStart","isDigit","includes","column1","isCharPatternContinuation","level","currentPeekOffset","junkStart","lastNewline","lastIndexOf","first","ret","takeChar","trailingWSRe","withSpan","fn","ps","withSpans","call","node","addSpan","FluentParser","getComment","getMessage","getTerm","getAttribute","getIdentifier","getVariant","getNumber","getPattern","getTextElement","getPlaceable","getExpression","getInlineExpression","getCallArgument","getCallArguments","getString","getLiteral","source","skipBlankBlock","entries","lastComment","entry","getEntryOrJunk","blankLines","res","skipped","entryStartPos","getEntry","expectLineEnd","err","errorIndex","skipToNextEntryStart","nextEntryStart","substring","junk","annot","addAnnotation","isIdentifierStart","Comment$1","expectChar","x","isNextLineComment","skipBlankInline","maybeGetPattern","attrs","getAttributes","isAttributeStart","attr","takeIDStart","takeIDChar","hasDefault","defaultIndex","skipBlank","getVariantKey","isVariantStart","variant","num","takeDigit","getDigits","isValueStart","isValueContinuation","isBlock","commonIndentLength","blankStart","firstIndent","getIndent","Infinity","indent","Math","min","dedented","dedent","Indent","commonIndent","trimmed","element","prev","sum","textElement","lastElement","pop","buffer","getUnicodeEscapeSequence","u","digits","takeHexDigit","getVariants","isNumberStart","test","exp","argumentNames","arg","add","getEscapeSequence","parse","opts","getTypeName","item","serializer","serialize","console","warn","getGroupComment","getResourceComment","_this","_this2","concat","getStringLiteral","_this3","placeable","log","join","getCallExpression","_this4","fcName","callee","positionals","nameds","getNamedArgument","getSelectExpression","_this5","getVariantExpression","ref","getVariableReference","plain","getTermReferences","getVariantName","getVariantList","_this6","isDefault","getFunctionReference","forEach","p","n","getTermReference","getMessageReference","getJunk","parts","split","shift","trim","ftlToJs","str","cb","params","respectComments","parsed","result","reduce","mem","segment","inner","val","addValue","k","ftl","js2ftl","resources","addComment","innerK","innerValue","ftl2js","_construct","Parent","Class","isNativeReflectConstruct","Reflect","construct","bind","a","apply","instance","Function","setPrototypeOf","_wrapNativeSuper","_cache","Map","toString","TypeError","get","set","Wrapper","getPrototypeOf","enumerable","writable","configurable"],"sourceRoot":""}