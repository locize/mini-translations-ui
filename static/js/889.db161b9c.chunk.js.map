{"version":3,"file":"static/js/889.db161b9c.chunk.js","mappings":"mQAOMA,EAAAA,WACF,cAAc,eACVC,KAAKC,KAAO,UACf,C,qCACD,SAAOC,GAAiC,IAA1BC,EAA0B,uDAAV,CAAC,QACrBC,EAAW,IAAIC,IAAIC,OAAOC,KAAKP,OAC/BQ,EAAY,IAAIH,IAAIC,OAAOC,KAAKL,IACtC,GAAIC,EAAe,iBACSA,GADT,IACf,IAAK,EAAL,qBAAuC,KAA5BM,EAA4B,QACnCL,EAASM,OAAOD,GAChBD,EAAUE,OAAOD,EACpB,CAJc,+BAKlB,CACD,GAAIL,EAASO,OAASH,EAAUG,KAC5B,OAAO,EAVyB,gBAYZP,GAZY,IAYpC,IAAK,EAAL,qBAAkC,KAAvBK,EAAuB,QAC9B,IAAKD,EAAUI,IAAIH,GACf,OAAO,EAEX,IAAMI,EAAUb,KAAKS,GACfK,EAAWZ,EAAMO,GACvB,UAAWI,WAAmBC,EAC1B,OAAO,EAEX,GAAID,aAAmBE,OAASD,aAAoBC,MAAO,CACvD,GAAIF,EAAQG,SAAWF,EAASE,OAC5B,OAAO,EAEX,IAAK,IAAIC,EAAI,EAAGA,EAAIJ,EAAQG,SAAUC,EAClC,IAAKC,EAAaL,EAAQI,GAAIH,EAASG,GAAId,GACvC,OAAO,CAGlB,MACI,IAAKe,EAAaL,EAASC,EAAUX,GACtC,OAAO,CAEd,CAlCmC,+BAmCpC,OAAO,CACV,G,mBACD,WACI,SAASgB,EAAMC,GACX,OAAIA,aAAiBrB,EACVqB,EAAMC,QAEbN,MAAMO,QAAQF,GACPA,EAAMG,IAAIJ,GAEdC,CACV,CAED,IADA,IAAMC,EAAQf,OAAOkB,OAAOxB,KAAKyB,YAAYC,WAC7C,MAAmBpB,OAAOC,KAAKP,MAA/B,eAAsC,CAAjC,IAAM2B,EAAI,KACXN,EAAMM,GAAQR,EAAMnB,KAAK2B,GAC5B,CACD,OAAON,CACV,K,EAxDCtB,GA0DN,SAASmB,EAAaL,EAASC,EAAUX,GACrC,OAAIU,aAAmBd,GAAYe,aAAoBf,EAC5Cc,EAAQe,OAAOd,EAAUX,GAE7BU,IAAYC,CACtB,C,IAIKe,EAAAA,SAAAA,I,6BACF,aAAc,6BACV,eAASC,YACJ7B,KAAO,aAFF,CAGb,C,sCACD,SAAQ8B,EAAOC,GACXhC,KAAKiC,KAAO,IAAIC,EAAKH,EAAOC,EAC/B,K,EAPCH,CAAmB9B,GASnBoC,EAAAA,SAAAA,I,6BACF,aAAuB,MAAXC,EAAW,uDAAJ,GAAI,uBACnB,gBACKnC,KAAO,WACZ,EAAKmC,KAAOA,EAHO,CAItB,C,iBALCD,CAAiBN,GAUjBQ,EAAAA,SAAAA,I,6BACF,aAAc,6BACV,eAASP,YACJ7B,KAAO,QAFF,CAGb,C,iBAJCoC,CAAcR,GAMdS,EAAAA,SAAAA,I,6BACF,WAAYC,GAAmD,MAA/CnB,EAA+C,uDAAvC,KAAMoB,EAAiC,uDAApB,GAAIC,EAAgB,uDAAN,KAAM,uBAC3D,gBACKxC,KAAO,UACZ,EAAKsC,GAAKA,EACV,EAAKnB,MAAQA,EACb,EAAKoB,WAAaA,EAClB,EAAKC,QAAUA,EAN4C,CAO9D,C,iBARCH,CAAgBD,GAUhBK,EAAAA,SAAAA,I,6BACF,WAAYH,EAAInB,GAAwC,MAAjCoB,EAAiC,uDAApB,GAAIC,EAAgB,uDAAN,KAAM,uBACpD,gBACKxC,KAAO,OACZ,EAAKsC,GAAKA,EACV,EAAKnB,MAAQA,EACb,EAAKoB,WAAaA,EAClB,EAAKC,QAAUA,EANqC,CAOvD,C,iBARCC,CAAaL,GAUbM,EAAAA,SAAAA,I,6BACF,WAAYC,GAAU,6BAClB,gBACK3C,KAAO,UACZ,EAAK2C,SAAWA,EAHE,CAIrB,C,iBALCD,CAAgBd,GAUhBgB,EAAAA,SAAAA,I,6BACF,aAAc,6BACV,eAASf,YACJ7B,KAAO,iBAFF,CAGb,C,iBAJC4C,CAAuBhB,GAMvBiB,EAAAA,SAAAA,I,6BACF,WAAY1B,GAAO,6BACf,gBACKnB,KAAO,cACZ,EAAKmB,MAAQA,EAHE,CAIlB,C,iBALC0B,CAAoBD,GAOpBE,EAAAA,SAAAA,I,6BACF,WAAYC,GAAY,6BACpB,gBACK/C,KAAO,YACZ,EAAK+C,WAAaA,EAHE,CAIvB,C,iBALCD,CAAkBF,GAUlBI,EAAAA,SAAAA,I,6BACF,aAAc,6BACV,eAASnB,YACJ7B,KAAO,aAFF,CAGb,C,iBAJCgD,CAAmBpB,GAOnBqB,EAAAA,SAAAA,I,6BACF,WAAY9B,GAAO,6BACf,gBACKnB,KAAO,UAGZ,EAAKmB,MAAQA,EALE,CAMlB,C,iBAPC8B,CAAgBD,GAShBE,EAAAA,SAAAA,I,6BACF,aAAc,6BACV,eAASrB,YACJ7B,KAAO,gBAFF,CAGb,C,oCACD,WAuBI,MAAO,CAAEmB,MADGpB,KAAKoB,MAAMgC,QApBD,yDACtB,SAA4BC,EAAOC,EAAYC,GAC3C,OAAQF,GACJ,IAAK,OACD,MAAO,KACX,IAAK,MACD,MAAO,IACX,QACI,IAAIG,EAAYC,SAASH,GAAcC,EAAY,IACnD,OAAIC,GAAa,OAAU,OAAUA,EAE1BE,OAAOC,cAAcH,GAKzB,SAGlB,IAGJ,K,EA7BCL,CAAsBD,GA+BtBU,EAAAA,SAAAA,I,6BACF,aAAc,6BACV,eAAS9B,YACJ7B,KAAO,gBAFF,CAGb,C,oCACD,WACI,IAAImB,EAAQyC,WAAW7D,KAAKoB,OACxB0C,EAAa9D,KAAKoB,MAAM2C,QAAQ,KAIpC,MAAO,CAAE3C,MAAAA,EAAO4C,UAHAF,EAAa,EACvB9D,KAAKoB,MAAMJ,OAAS8C,EAAa,EACjC,EAET,K,EAZCF,CAAsBV,GActBe,EAAAA,SAAAA,I,6BACF,WAAY1B,GAAsB,MAAlB2B,EAAkB,uDAAN,KAAM,uBAC9B,gBACKjE,KAAO,mBACZ,EAAKsC,GAAKA,EACV,EAAK2B,UAAYA,EAJa,CAKjC,C,iBANCD,CAAyBhB,GAQzBkB,EAAAA,SAAAA,I,6BACF,WAAY5B,GAAmC,MAA/B2B,EAA+B,uDAAnB,KAAME,EAAa,uDAAN,KAAM,uBAC3C,gBACKnE,KAAO,gBACZ,EAAKsC,GAAKA,EACV,EAAK2B,UAAYA,EACjB,EAAKpC,UAAYsC,EAL0B,CAM9C,C,iBAPCD,CAAsBlB,GAStBoB,EAAAA,SAAAA,I,6BACF,WAAY9B,GAAI,6BACZ,gBACKtC,KAAO,oBACZ,EAAKsC,GAAKA,EAHE,CAIf,C,iBALC8B,CAA0BpB,GAO1BqB,EAAAA,SAAAA,I,6BACF,WAAY/B,EAAI6B,GAAM,6BAClB,gBACKnE,KAAO,oBACZ,EAAKsC,GAAKA,EACV,EAAKT,UAAYsC,EAJC,CAKrB,C,iBANCE,CAA0BrB,GAQ1BsB,EAAAA,SAAAA,I,6BACF,WAAYC,EAAUC,GAAU,6BAC5B,gBACKxE,KAAO,mBACZ,EAAKuE,SAAWA,EAChB,EAAKC,SAAWA,EAJY,CAK/B,C,iBANCF,CAAyBtB,GAQzByB,EAAAA,SAAAA,I,6BACF,aAAyC,MAA7BC,EAA6B,uDAAhB,GAAIC,EAAY,uDAAJ,GAAI,uBACrC,gBACK3E,KAAO,gBACZ,EAAK0E,WAAaA,EAClB,EAAKC,MAAQA,EAJwB,CAKxC,C,iBANCF,CAAsB7C,GAQtBgD,EAAAA,SAAAA,I,6BACF,WAAYtC,EAAInB,GAAO,6BACnB,gBACKnB,KAAO,YACZ,EAAKsC,GAAKA,EACV,EAAKnB,MAAQA,EAJM,CAKtB,C,iBANCyD,CAAkBhD,GAQlBiD,EAAAA,SAAAA,I,6BACF,WAAYC,EAAK3D,EAAO4D,GAAK,6BACzB,gBACK/E,KAAO,UACZ,EAAK8E,IAAMA,EACX,EAAK3D,MAAQA,EACb,EAAK6D,QAAUD,EALU,CAM5B,C,iBAPCF,CAAgBjD,GAShBqD,EAAAA,SAAAA,I,6BACF,WAAYC,EAAM/D,GAAO,6BACrB,gBACKnB,KAAO,gBACZ,EAAKkF,KAAOA,EACZ,EAAK/D,MAAQA,EAJQ,CAKxB,C,iBANC8D,CAAsBrD,GAQtBuD,EAAAA,SAAAA,I,6BACF,WAAYD,GAAM,6BACd,gBACKlF,KAAO,aACZ,EAAKkF,KAAOA,EAHE,CAIjB,C,iBALCC,CAAmBvD,GAOnBwD,EAAAA,SAAAA,I,6BACF,WAAYC,GAAS,6BACjB,gBACKrF,KAAO,cACZ,EAAKqF,QAAUA,EAHE,CAIpB,C,iBALCD,CAAoBhD,GAOpBkD,EAAAA,SAAAA,I,6BACF,aAAc,6BACV,eAASzD,YACJ7B,KAAO,UAFF,CAGb,C,iBAJCsF,CAAgBF,GAMhBG,EAAAA,SAAAA,I,6BACF,aAAc,6BACV,eAAS1D,YACJ7B,KAAO,eAFF,CAGb,C,iBAJCuF,CAAqBH,GAMrBI,EAAAA,SAAAA,I,6BACF,aAAc,6BACV,eAAS3D,YACJ7B,KAAO,kBAFF,CAGb,C,iBAJCwF,CAAwBJ,GAMxBK,EAAAA,SAAAA,I,6BACF,WAAYJ,GAAS,6BACjB,gBACKrF,KAAO,OACZ,EAAK0F,YAAc,GACnB,EAAKL,QAAUA,EAJE,CAKpB,C,4CACD,SAAcM,GACV5F,KAAK2F,YAAYE,KAAKD,EACzB,K,EATCF,CAAa7D,GAWbK,EAAAA,SAAAA,I,6BACF,WAAYH,EAAOC,GAAK,6BACpB,gBACK/B,KAAO,OACZ,EAAK8B,MAAQA,EACb,EAAKC,IAAMA,EAJS,CAKvB,C,iBANCE,CAAanC,GAQb+F,EAAAA,SAAAA,I,6BACF,WAAYC,GAA0B,MAApB3B,EAAoB,uDAAb,GAAI4B,EAAS,8DAClC,gBACK/F,KAAO,aACZ,EAAK8F,KAAOA,EACZ,EAAKjE,UAAYsC,EACjB,EAAK4B,QAAUA,EALmB,CAMrC,C,iBAPCF,CAAmBjE,GAUnBoE,EAAAA,SAAAA,I,6BACF,WAAYF,GAAe,uBACvB,gBACKA,KAAOA,EAFW,2BAAN3B,EAAM,iCAANA,EAAM,yBAGvB,EAAKA,KAAOA,EACZ,EAAK4B,QAAUE,EAAgBH,EAAM3B,GAJd,CAK1B,C,iBANC6B,E,OAAmBE,QASzB,SAASD,EAAgBH,EAAM3B,GAC3B,OAAQ2B,GACJ,IAAK,QACD,MAAO,gBACX,IAAK,QACD,MAAO,0BACX,IAAK,QACD,IAAOK,GAAP,OAAgBhC,EAAhB,MACA,MAAO,oBAAP,OAA2BgC,EAA3B,KAEJ,IAAK,QACD,IAAOC,GAAP,OAAgBjC,EAAhB,MACA,MAAO,qCAAP,OAA4CiC,EAA5C,KAEJ,IAAK,QACD,IAAO9D,GAAP,OAAa6B,EAAb,MACA,MAAO,qBAAP,OAA4B7B,EAA5B,mCAEJ,IAAK,QACD,IAAOA,GAAP,OAAa6B,EAAb,MACA,MAAO,mBAAP,OAA0B7B,EAA1B,qBAEJ,IAAK,QACD,MAAO,uCACX,IAAK,QACD,MAAO,0DACX,IAAK,QACD,MAAO,kDACX,IAAK,QACD,MAAO,2DACX,IAAK,QACD,MAAO,2CACX,IAAK,QACD,MAAO,iBACX,IAAK,QACD,MAAO,uBACX,IAAK,QACD,MAAO,mBACX,IAAK,QACD,MAAO,gDACX,IAAK,QACD,MAAO,iDACX,IAAK,QACD,MAAO,oCACX,IAAK,QACD,MAAO,qDACX,IAAK,QACD,MAAO,mDACX,IAAK,QACD,MAAO,iCACX,IAAK,QACD,MAAO,uDACX,IAAK,QACD,MAAO,iCACX,IAAK,QACD,MAAO,uCACX,IAAK,QACD,IAAO+D,GAAP,OAAelC,EAAf,MACA,MAAO,8BAAP,OAAqCkC,EAArC,KAEJ,IAAK,QACD,IAAOC,GAAP,OAAmBnC,EAAnB,MACA,MAAO,oCAAP,OAA2CmC,EAA3C,KAEJ,IAAK,QACD,MAAO,2CACX,IAAK,QACD,MAAO,gCACX,IAAK,QACD,MAAO,yCACX,QACI,OAAOR,EAElB,C,IAGKS,EAAAA,WACF,WAAYC,IAAQ,eAChBzG,KAAKyG,OAASA,EACdzG,KAAK0G,MAAQ,EACb1G,KAAK2G,WAAa,CACrB,C,qCACD,SAAOC,GAKH,MAA4B,OAAxB5G,KAAKyG,OAAOG,IACmB,OAA5B5G,KAAKyG,OAAOG,EAAS,GACjB,KAEJ5G,KAAKyG,OAAOG,EACtB,G,yBACD,WACI,OAAO5G,KAAK6G,OAAO7G,KAAK0G,MAC3B,G,yBACD,WACI,OAAO1G,KAAK6G,OAAO7G,KAAK0G,MAAQ1G,KAAK2G,WACxC,G,kBACD,WAQI,OAPA3G,KAAK2G,WAAa,EAEc,OAA5B3G,KAAKyG,OAAOzG,KAAK0G,QACkB,OAAhC1G,KAAKyG,OAAOzG,KAAK0G,MAAQ,IAC5B1G,KAAK0G,QAET1G,KAAK0G,QACE1G,KAAKyG,OAAOzG,KAAK0G,MAC3B,G,kBACD,WAOI,MALkD,OAA9C1G,KAAKyG,OAAOzG,KAAK0G,MAAQ1G,KAAK2G,aACuB,OAAlD3G,KAAKyG,OAAOzG,KAAK0G,MAAQ1G,KAAK2G,WAAa,IAC9C3G,KAAK2G,aAET3G,KAAK2G,aACE3G,KAAKyG,OAAOzG,KAAK0G,MAAQ1G,KAAK2G,WACxC,G,uBACD,WAAsB,IAAZC,EAAY,uDAAH,EACf5G,KAAK2G,WAAaC,CACrB,G,wBACD,WACI5G,KAAK0G,OAAS1G,KAAK2G,WACnB3G,KAAK2G,WAAa,CACrB,K,EAhDCH,GAkDAM,EAAM,KACNC,OAAMC,EACNC,EAA2B,CAAC,IAAK,IAAK,IAAK,KAC3CC,EAAAA,SAAAA,I,sIACF,WAEI,IADA,IAAMnF,EAAQ/B,KAAK0G,MAAQ1G,KAAK2G,WACF,MAAvB3G,KAAKmH,eACRnH,KAAKoH,OAET,OAAOpH,KAAKyG,OAAOY,MAAMtF,EAAO/B,KAAK0G,MAAQ1G,KAAK2G,WACrD,G,6BACD,WACI,IAAMW,EAAQtH,KAAKuH,kBAEnB,OADAvH,KAAKwH,aACEF,CACV,G,4BACD,WAEI,IADA,IAAIA,EAAQ,KACC,CACT,IAAMG,EAAYzH,KAAK2G,WAEvB,GADA3G,KAAKuH,kBACDvH,KAAKmH,gBAAkBL,EAK3B,OAAI9G,KAAKmH,gBAAkBJ,GAK3B/G,KAAK0H,UAAUD,GAHJH,EANPA,GAASR,EACT9G,KAAKoH,MAUZ,CACJ,G,4BACD,WACI,IAAME,EAAQtH,KAAK2H,iBAEnB,OADA3H,KAAKwH,aACEF,CACV,G,uBACD,WACI,KAA8B,MAAvBtH,KAAKmH,eAAyBnH,KAAKmH,gBAAkBL,GACxD9G,KAAKoH,MAEZ,G,uBACD,WACIpH,KAAK4H,YACL5H,KAAKwH,YACR,G,wBACD,SAAWK,GACP,GAAI7H,KAAK8H,gBAAkBD,EAI3B,MAAM,IAAI5B,EAAW,QAAS4B,GAH1B7H,KAAK+H,MAIZ,G,2BACD,WACI,GAAI/H,KAAK8H,gBAAkBf,EAA3B,CAIA,GAAI/G,KAAK8H,gBAAkBhB,EAK3B,MAAM,IAAIb,EAAW,QAAS,UAJ1BjG,KAAK+H,MAFR,CAOJ,G,sBACD,SAASC,GACL,IAAMH,EAAK7H,KAAK8H,cAChB,OAAID,IAAOd,EACAA,EAEPiB,EAAEH,IACF7H,KAAK+H,OACEF,GAEJ,IACV,G,2BACD,SAAcA,GACV,GAAIA,IAAOd,EACP,OAAO,EAEX,IAAMkB,EAAKJ,EAAGK,WAAW,GACzB,OAAQD,GAAM,IAAMA,GAAM,KACrBA,GAAM,IAAMA,GAAM,EAC1B,G,+BACD,WACI,OAAOjI,KAAKmI,cAAcnI,KAAKmH,cAClC,G,2BACD,WACI,IAAMU,EAA4B,MAAvB7H,KAAK8H,cACV9H,KAAKoH,OACLpH,KAAK8H,cACX,GAAID,IAAOd,EAEP,OADA/G,KAAK0H,aACE,EAEX,IAAMO,EAAKJ,EAAGK,WAAW,GACnBE,EAAUH,GAAM,IAAMA,GAAM,GAElC,OADAjI,KAAK0H,YACEU,CACV,G,uCACD,SAA0BP,GACtB,OAAIA,IAAOd,IAGHE,EAAyBoB,SAASR,EAC7C,G,0BACD,WAEI,IAAMA,EAAK7H,KAAKmH,cAChB,OAAOU,IAAOf,GAAOe,IAAOd,CAC/B,G,iCACD,WACI,IAAMuB,EAAUtI,KAAK2G,WAErB,OADA3G,KAAKuH,kBACsB,MAAvBvH,KAAKmH,eACLnH,KAAK0H,UAAUY,IACR,GAEPtI,KAAK2G,WAAa2B,IAAY,MAG9BtI,KAAKuI,0BAA0BvI,KAAKmH,iBACpCnH,KAAK0H,UAAUY,IACR,GAGd,G,+BAKD,WAA8B,IAAZE,EAAY,wDAAH,EACvB,GAAIxI,KAAK8H,gBAAkBhB,EACvB,OAAO,EAGX,IADA,IAAI7F,EAAI,EACDA,GAAKuH,IAAqB,IAAXA,GAAgBvH,EAAI,GAAI,CAC1C,GAAoB,MAAhBjB,KAAKoH,OAAgB,CACrB,GAAInG,GAAKuH,IAAoB,IAAXA,EAEd,OADAxI,KAAK0H,aACE,EAEX,KACH,CACDzG,GACH,CAED,IAAM4G,EAAK7H,KAAKoH,OAChB,MAAW,MAAPS,GAAcA,IAAOf,GACrB9G,KAAK0H,aACE,IAEX1H,KAAK0H,aACE,EACV,G,4BACD,WACI,IAAMe,EAAoBzI,KAAK2G,WAI/B,MAH2B,MAAvB3G,KAAKmH,eACLnH,KAAKoH,OAEkB,MAAvBpH,KAAKmH,eACLnH,KAAK0H,UAAUe,IACR,IAEXzI,KAAK0H,UAAUe,IACR,EACV,G,8BACD,WACI,MAA8B,MAAvBzI,KAAKmH,aACf,G,kCACD,SAAqBuB,GACjB,IAAIC,EAAc3I,KAAKyG,OAAOmC,YAAY9B,EAAK9G,KAAK0G,OAMpD,IALIgC,EAAYC,IAGZ3I,KAAK0G,MAAQiC,GAEV3I,KAAK8H,eAER,GAAI9H,KAAK8H,gBAAkBhB,EAA3B,CAKA,IAAM+B,EAAQ7I,KAAK+H,OACnB,GAAI/H,KAAKmI,cAAcU,IAAoB,MAAVA,GAA2B,MAAVA,EAC9C,KAJH,MAFG7I,KAAK+H,MAShB,G,yBACD,WACI,GAAI/H,KAAKmI,cAAcnI,KAAK8H,eAAgB,CACxC,IAAMgB,EAAM9I,KAAK8H,cAEjB,OADA9H,KAAK+H,OACEe,CACV,CACD,MAAM,IAAI7C,EAAW,QAAS,SACjC,G,wBACD,WAQI,OAAOjG,KAAK+I,UAPI,SAAClB,GACb,IAAMI,EAAKJ,EAAGK,WAAW,GACzB,OAASD,GAAM,IAAMA,GAAM,KACtBA,GAAM,IAAMA,GAAM,IAClBA,GAAM,IAAMA,GAAM,IACZ,KAAPA,GAAoB,KAAPA,CACpB,GAEJ,G,uBACD,WAKI,OAAOjI,KAAK+I,UAJI,SAAClB,GACb,IAAMI,EAAKJ,EAAGK,WAAW,GACzB,OAAQD,GAAM,IAAMA,GAAM,EAC7B,GAEJ,G,0BACD,WAOI,OAAOjI,KAAK+I,UANI,SAAClB,GACb,IAAMI,EAAKJ,EAAGK,WAAW,GACzB,OAAQD,GAAM,IAAMA,GAAM,IAClBA,GAAM,IAAMA,GAAM,IAClBA,GAAM,IAAMA,GAAM,GAC7B,GAEJ,K,EA/NCf,CAA2BV,GAmO3BwC,EAAe,cACrB,SAASC,EAASC,GACd,OAAO,SAAUC,GAAa,2BAAN/E,EAAM,iCAANA,EAAM,kBAC1B,IAAKpE,KAAKoJ,UACN,OAAOF,EAAGG,KAAH,MAAAH,EAAE,CAAMlJ,KAAMmJ,GAAZ,OAAmB/E,IAEhC,IAAMrC,EAAQoH,EAAGzC,MACX4C,EAAOJ,EAAGG,KAAH,MAAAH,EAAE,CAAMlJ,KAAMmJ,GAAZ,OAAmB/E,IAGlC,GAAIkF,EAAKrH,KACL,OAAOqH,EAEX,IAAMtH,EAAMmH,EAAGzC,MAEf,OADA4C,EAAKC,QAAQxH,EAAOC,GACbsH,CACV,CACJ,C,IACKE,EAAAA,WACF,aAAuC,6DAAJ,CAAC,EAAG,IAAzBJ,UAAAA,OAAyB,yBACnCpJ,KAAKoJ,UAAYA,EAGjBpJ,KAAKyJ,WAAaR,EAASjJ,KAAKyJ,YAChCzJ,KAAK0J,WAAaT,EAASjJ,KAAK0J,YAChC1J,KAAK2J,QAAUV,EAASjJ,KAAK2J,SAC7B3J,KAAK4J,aAAeX,EAASjJ,KAAK4J,cAClC5J,KAAK6J,cAAgBZ,EAASjJ,KAAK6J,eACnC7J,KAAK8J,WAAab,EAASjJ,KAAK8J,YAChC9J,KAAK+J,UAAYd,EAASjJ,KAAK+J,WAC/B/J,KAAKgK,WAAaf,EAASjJ,KAAKgK,YAChChK,KAAKiK,eAAiBhB,EAASjJ,KAAKiK,gBACpCjK,KAAKkK,aAAejB,EAASjJ,KAAKkK,cAClClK,KAAKmK,cAAgBlB,EAASjJ,KAAKmK,eACnCnK,KAAKoK,oBAAsBnB,EAASjJ,KAAKoK,qBACzCpK,KAAKqK,gBAAkBpB,EAASjJ,KAAKqK,iBACrCrK,KAAKsK,iBAAmBrB,EAASjJ,KAAKsK,kBACtCtK,KAAKuK,UAAYtB,EAASjJ,KAAKuK,WAC/BvK,KAAKwK,WAAavB,EAASjJ,KAAKwK,YAChCxK,KAAKyJ,WAAaR,EAASjJ,KAAKyJ,WAEnC,C,oCACD,SAAMgB,GACF,IAAMtB,EAAK,IAAIjC,EAAmBuD,GAClCtB,EAAGuB,iBAGH,IAFA,IAAMC,EAAU,GACZC,EAAc,KACXzB,EAAGrB,eAAe,CACrB,IAAM+C,EAAQ7K,KAAK8K,eAAe3B,GAC5B4B,EAAa5B,EAAGuB,iBAMlBG,aAAiBtF,GACQ,IAAtBwF,EAAW/J,QACXmI,EAAGrB,cAEN8C,EAAcC,GAGdD,IACIC,aAAiBvI,GAAWuI,aAAiBnI,GAC7CmI,EAAMpI,QAAUmI,EACZ5K,KAAKoJ,YAELyB,EAAM5I,KAAKF,MAAQ8I,EAAMpI,QAAQR,KAAKF,QAI1C4I,EAAQ9E,KAAK+E,GAGjBA,EAAc,MAGlBD,EAAQ9E,KAAKgF,GAChB,CACD,IAAMG,EAAM,IAAI7I,EAASwI,GAIzB,OAHI3K,KAAKoJ,WACL4B,EAAIzB,QAAQ,EAAGJ,EAAGzC,OAEfsE,CACV,G,wBAUD,SAAWP,GACP,IAAMtB,EAAK,IAAIjC,EAAmBuD,GAElC,IADAtB,EAAGuB,iBACyB,MAArBvB,EAAGrB,eAAuB,CAC7B,IAAMmD,EAAUjL,KAAK8K,eAAe3B,GACpC,GAAI8B,aAAmBvF,EAEnB,OAAOuF,EAEX9B,EAAGuB,gBACN,CACD,OAAO1K,KAAK8K,eAAe3B,EAC9B,G,4BACD,SAAeA,GACX,IAAM+B,EAAgB/B,EAAGzC,MACzB,IACI,IAAMmE,EAAQ7K,KAAKmL,SAAShC,GAE5B,OADAA,EAAGiC,gBACIP,CAuBV,CArBD,MAAOQ,GACH,KAAMA,aAAepF,GACjB,MAAMoF,EAEV,IAAIC,EAAanC,EAAGzC,MACpByC,EAAGoC,qBAAqBL,GACxB,IAAMM,EAAiBrC,EAAGzC,MACtB8E,EAAiBF,IAEjBA,EAAaE,GAGjB,IAAMnE,EAAQ8B,EAAG1C,OAAOgF,UAAUP,EAAeM,GAC3CE,EAAO,IAAIhG,EAAK2B,GAClBrH,KAAKoJ,WACLsC,EAAKnC,QAAQ2B,EAAeM,GAEhC,IAAMG,EAAQ,IAAI7F,EAAWuF,EAAItF,KAAMsF,EAAIjH,KAAMiH,EAAIrF,SAGrD,OAFA2F,EAAMpC,QAAQ+B,EAAYA,GAC1BI,EAAKE,cAAcD,GACZD,CACV,CACJ,G,sBACD,SAASvC,GACL,GAAyB,MAArBA,EAAGrB,cACH,OAAO9H,KAAKyJ,WAAWN,GAE3B,GAAyB,MAArBA,EAAGrB,cACH,OAAO9H,KAAK2J,QAAQR,GAExB,GAAIA,EAAG0C,oBACH,OAAO7L,KAAK0J,WAAWP,GAE3B,MAAM,IAAIlD,EAAW,QACxB,G,wBACD,SAAWkD,GAMP,IAFA,IA0BI2C,EA1BAtD,GAAS,EACTlD,EAAU,KACD,CAET,IADA,IAAIrE,GAAK,EACmB,MAArBkI,EAAGrB,eAA0B7G,IAAgB,IAAXuH,EAAe,EAAIA,IACxDW,EAAGpB,OACH9G,IAKJ,IAHe,IAAXuH,IACAA,EAAQvH,GAERkI,EAAGrB,gBAAkBhB,EAAK,CAC1BqC,EAAG4C,WAAW,KAEd,IADA,IAAIlE,OAAE,EACEA,EAAKsB,EAAGJ,UAAS,SAAAiD,GAAC,OAAIA,IAAMlF,CAAV,KACtBxB,GAAWuC,CAElB,CACD,IAAIsB,EAAG8C,kBAAkBzD,GAKrB,MAJAlD,GAAW6D,EAAGrB,cACdqB,EAAGpB,MAKV,CAED,OAAQS,GACJ,KAAK,EACDsD,EAAYvG,EACZ,MACJ,KAAK,EACDuG,EAAYtG,EACZ,MACJ,QACIsG,EAAYrG,EAEpB,OAAO,IAAIqG,EAAUxG,EACxB,G,wBACD,SAAW6D,GACP,IAAM5G,EAAKvC,KAAK6J,cAAcV,GAC9BA,EAAG+C,kBACH/C,EAAG4C,WAAW,KACd,IAAM3K,EAAQpB,KAAKmM,gBAAgBhD,GAC7BiD,EAAQpM,KAAKqM,cAAclD,GACjC,GAAc,OAAV/H,GAAmC,IAAjBgL,EAAMpL,OACxB,MAAM,IAAIiF,EAAW,QAAS1D,EAAG4C,MAErC,OAAO,IAAI7C,EAAQC,EAAInB,EAAOgL,EACjC,G,qBACD,SAAQjD,GACJA,EAAG4C,WAAW,KACd,IAAMxJ,EAAKvC,KAAK6J,cAAcV,GAC9BA,EAAG+C,kBACH/C,EAAG4C,WAAW,KACd,IAAM3K,EAAQpB,KAAKmM,gBAAgBhD,GACnC,GAAc,OAAV/H,EACA,MAAM,IAAI6E,EAAW,QAAS1D,EAAG4C,MAErC,IAAMiH,EAAQpM,KAAKqM,cAAclD,GACjC,OAAO,IAAIzG,EAAKH,EAAInB,EAAOgL,EAC9B,G,0BACD,SAAajD,GACTA,EAAG4C,WAAW,KACd,IAAMhH,EAAM/E,KAAK6J,cAAcV,GAC/BA,EAAG+C,kBACH/C,EAAG4C,WAAW,KACd,IAAM3K,EAAQpB,KAAKmM,gBAAgBhD,GACnC,GAAc,OAAV/H,EACA,MAAM,IAAI6E,EAAW,SAEzB,OAAO,IAAIpB,EAAUE,EAAK3D,EAC7B,G,2BACD,SAAc+H,GACV,IAAMiD,EAAQ,GAEd,IADAjD,EAAGvB,YACIuB,EAAGmD,oBAAoB,CAC1BnD,EAAG3B,aACH,IAAM+E,EAAOvM,KAAK4J,aAAaT,GAC/BiD,EAAMvG,KAAK0G,GACXpD,EAAGvB,WACN,CACD,OAAOwE,CACV,G,2BACD,SAAcjD,GAGV,IAFA,IACItB,EADA1C,EAAOgE,EAAGqD,cAEN3E,EAAKsB,EAAGsD,cACZtH,GAAQ0C,EAEZ,OAAO,IAAIzC,EAAWD,EACzB,G,2BACD,SAAcgE,GACV,IAAMtB,EAAKsB,EAAGrB,cACd,GAAID,IAAOd,EACP,MAAM,IAAId,EAAW,SAEzB,IAAMgC,EAAKJ,EAAGK,WAAW,GACzB,OAAKD,GAAM,IAAMA,GAAM,IAAc,KAAPA,EACnBjI,KAAK+J,UAAUZ,GAEnBnJ,KAAK6J,cAAcV,EAC7B,G,wBACD,SAAWA,GAAwB,IAApBuD,EAAoB,wDAC3BC,GAAe,EACnB,GAAyB,MAArBxD,EAAGrB,cAAuB,CAC1B,GAAI4E,EACA,MAAM,IAAIzG,EAAW,SAEzBkD,EAAGpB,OACH4E,GAAe,CAClB,CACDxD,EAAG4C,WAAW,KACd5C,EAAGyD,YACH,IAAM7H,EAAM/E,KAAK6M,cAAc1D,GAC/BA,EAAGyD,YACHzD,EAAG4C,WAAW,KACd,IAAM3K,EAAQpB,KAAKmM,gBAAgBhD,GACnC,GAAc,OAAV/H,EACA,MAAM,IAAI6E,EAAW,SAEzB,OAAO,IAAInB,EAAQC,EAAK3D,EAAOuL,EAClC,G,yBACD,SAAYxD,GACR,IAAM1E,EAAW,GACbiI,GAAa,EAEjB,IADAvD,EAAGyD,YACIzD,EAAG2D,kBAAkB,CACxB,IAAMC,EAAU/M,KAAK8J,WAAWX,EAAIuD,GAChCK,EAAQ9H,UACRyH,GAAa,GAEjBjI,EAASoB,KAAKkH,GACd5D,EAAGiC,gBACHjC,EAAGyD,WACN,CACD,GAAwB,IAApBnI,EAASzD,OACT,MAAM,IAAIiF,EAAW,SAEzB,IAAKyG,EACD,MAAM,IAAIzG,EAAW,SAEzB,OAAOxB,CACV,G,uBACD,SAAU0E,GAGN,IAFA,IACItB,EADAmF,EAAM,GAEFnF,EAAKsB,EAAG8D,aACZD,GAAOnF,EAEX,GAAmB,IAAfmF,EAAIhM,OACJ,MAAM,IAAIiF,EAAW,QAAS,OAElC,OAAO+G,CACV,G,uBACD,SAAU7D,GACN,IAAI/H,EAAQ,GAYZ,MAXyB,MAArB+H,EAAGrB,eACHqB,EAAGpB,OACH3G,GAAS,IAAJ,OAAQpB,KAAKkN,UAAU/D,KAG5B/H,GAASpB,KAAKkN,UAAU/D,GAEH,MAArBA,EAAGrB,gBACHqB,EAAGpB,OACH3G,GAAS,IAAJ,OAAQpB,KAAKkN,UAAU/D,KAEzB,IAAIvF,EAAcxC,EAC5B,G,6BAOD,SAAgB+H,GAEZ,OADAA,EAAG5B,kBACC4B,EAAGgE,gBACHhE,EAAG3B,aACIxH,KAAKgK,WAAWb,GAAI,KAE/BA,EAAGxB,iBACCwB,EAAGiE,uBACHjE,EAAG3B,aACIxH,KAAKgK,WAAWb,GAAI,IAExB,KACV,G,wBACD,SAAWA,EAAIkE,GACX,IACIC,EAYAzF,EAbEjF,EAAW,GAEjB,GAAIyK,EAAS,CAGT,IAAME,EAAapE,EAAGzC,MAChB8G,EAAcrE,EAAG+C,kBACvBtJ,EAASiD,KAAK7F,KAAKyN,UAAUtE,EAAIqE,EAAaD,IAC9CD,EAAqBE,EAAYxM,MACpC,MAEGsM,EAAqBI,IAGzB9K,EAAU,KAAQiF,EAAKsB,EAAGrB,eACtB,OAAQD,GACJ,KAAKf,EACD,IAAMyG,EAAapE,EAAGzC,MAChBqE,EAAa5B,EAAGxB,iBACtB,GAAIwB,EAAGiE,sBAAuB,CAC1BjE,EAAG3B,aACH,IAAMmG,EAASxE,EAAG+C,kBAClBoB,EAAqBM,KAAKC,IAAIP,EAAoBK,EAAO3M,QACzD4B,EAASiD,KAAK7F,KAAKyN,UAAUtE,EAAI4B,EAAa4C,EAAQJ,IACtD,SAAS3K,CACZ,CAGDuG,EAAGzB,YACH,MAAM9E,EAEV,IAAK,IACDA,EAASiD,KAAK7F,KAAKkK,aAAaf,IAChC,SAASvG,EACb,IAAK,IACD,MAAM,IAAIqD,EAAW,SACzB,QACIrD,EAASiD,KAAK7F,KAAKiK,eAAed,IAG9C,IAAM2E,EAAW9N,KAAK+N,OAAOnL,EAAU0K,GACvC,OAAO,IAAI3K,EAAQmL,EACtB,G,uBAID,SAAU3E,EAAI/H,EAAOW,GACjB,OAAO,IAAIiM,EAAO5M,EAAOW,EAAOoH,EAAGzC,MACtC,G,oBAGD,SAAO9D,EAAUqL,GACb,IAD2B,EACrBC,EAAU,GADW,UAEPtL,GAFO,IAE3B,IAAK,EAAL,qBAA8B,KAArBuL,EAAqB,QAC1B,GAAIA,aAAmBpL,EACnBmL,EAAQrI,KAAKsI,QAGjB,KAAIA,aAAmBH,IAEnBG,EAAQ/M,MAAQ+M,EAAQ/M,MAAMiG,MAAM,EAAG8G,EAAQ/M,MAAMJ,OAASiN,GACjC,IAAzBE,EAAQ/M,MAAMJ,SAHtB,CAOA,IAAIoN,EAAOF,EAAQA,EAAQlN,OAAS,GACpC,GAAIoN,GAAQA,aAAgBtL,EAA5B,CAEI,IAAMuL,EAAM,IAAIvL,EAAYsL,EAAKhN,MAAQ+M,EAAQ/M,OAC7CpB,KAAKoJ,WAELiF,EAAI9E,QAAQ6E,EAAKnM,KAAKF,MAAOoM,EAAQlM,KAAKD,KAE9CkM,EAAQA,EAAQlN,OAAS,GAAKqN,CAEjC,KATD,CAUA,GAAIF,aAAmBH,EAAQ,CAG3B,IAAMM,EAAc,IAAIxL,EAAYqL,EAAQ/M,OACxCpB,KAAKoJ,WACLkF,EAAY/E,QAAQ4E,EAAQlM,KAAKF,MAAOoM,EAAQlM,KAAKD,KAEzDmM,EAAUG,CACb,CACDJ,EAAQrI,KAAKsI,EAVZ,CAXA,CAsBJ,CAnC0B,+BAqC3B,IAAMI,EAAcL,EAAQA,EAAQlN,OAAS,GAO7C,OANIuN,aAAuBzL,IACvByL,EAAYnN,MAAQmN,EAAYnN,MAAMgC,QAAQ4F,EAAc,IAC3B,IAA7BuF,EAAYnN,MAAMJ,QAClBkN,EAAQM,OAGTN,CACV,G,4BACD,SAAe/E,GAGX,IAFA,IACItB,EADA4G,EAAS,GAEL5G,EAAKsB,EAAGrB,eAAgB,CAC5B,GAAW,MAAPD,GAAqB,MAAPA,EACd,OAAO,IAAI/E,EAAY2L,GAE3B,GAAI5G,IAAOf,EACP,OAAO,IAAIhE,EAAY2L,GAE3BA,GAAU5G,EACVsB,EAAGpB,MACN,CACD,OAAO,IAAIjF,EAAY2L,EAC1B,G,+BACD,SAAkBtF,GACd,IAAMpB,EAAOoB,EAAGrB,cAChB,OAAQC,GACJ,IAAK,KACL,IAAK,IAED,OADAoB,EAAGpB,OACI,KAAP,OAAYA,GAChB,IAAK,IACD,OAAO/H,KAAK0O,yBAAyBvF,EAAIpB,EAAM,GACnD,IAAK,IACD,OAAO/H,KAAK0O,yBAAyBvF,EAAIpB,EAAM,GACnD,QACI,MAAM,IAAI9B,EAAW,QAAS8B,GAEzC,G,sCACD,SAAyBoB,EAAIwF,EAAGC,GAC5BzF,EAAG4C,WAAW4C,GAEd,IADA,IAAIpI,EAAW,GACNtF,EAAI,EAAGA,EAAI2N,EAAQ3N,IAAK,CAC7B,IAAM4G,EAAKsB,EAAG0F,eACd,IAAKhH,EACD,MAAM,IAAI5B,EAAW,QAAf,YAA6B0I,GAA7B,OAAiCpI,GAAjC,OAA4C4C,EAAGrB,gBAEzDvB,GAAYsB,CACf,CACD,MAAO,KAAP,OAAY8G,GAAZ,OAAgBpI,EACnB,G,0BACD,SAAa4C,GACTA,EAAG4C,WAAW,KACd5C,EAAGyD,YACH,IAAM5J,EAAahD,KAAKmK,cAAchB,GAEtC,OADAA,EAAG4C,WAAW,KACP,IAAIhJ,EAAUC,EACxB,G,2BACD,SAAcmG,GACV,IAAM3E,EAAWxE,KAAKoK,oBAAoBjB,GAE1C,GADAA,EAAGyD,YACsB,MAArBzD,EAAGrB,cAAuB,CAC1B,GAAkB,MAAdqB,EAAG/B,OAEH,OADA+B,EAAGzB,YACIlD,EAIX,GAAIA,aAAoBP,EACpB,MAA2B,OAAvBO,EAASN,UACH,IAAI+B,EAAW,SAGf,IAAIA,EAAW,SAGxB,GAAIzB,aAAoBL,GACzB,GAA2B,OAAvBK,EAASN,UACT,MAAM,IAAI+B,EAAW,cAGxB,GAAIzB,aAAoBzB,EACzB,MAAM,IAAIkD,EAAW,SAEzBkD,EAAGpB,OACHoB,EAAGpB,OACHoB,EAAG+C,kBACH/C,EAAGiC,gBACH,IAAM3G,EAAWzE,KAAK8O,YAAY3F,GAClC,OAAO,IAAI5E,EAAiBC,EAAUC,EACzC,CACD,GAAID,aAAoBL,GAAwC,OAAvBK,EAASN,UAC9C,MAAM,IAAI+B,EAAW,SAEzB,OAAOzB,CACV,G,iCACD,SAAoB2E,GAChB,GAAyB,MAArBA,EAAGrB,cACH,OAAO9H,KAAKkK,aAAaf,GAE7B,GAAIA,EAAG4F,gBACH,OAAO/O,KAAK+J,UAAUZ,GAE1B,GAAyB,MAArBA,EAAGrB,cACH,OAAO9H,KAAKuK,UAAUpB,GAE1B,GAAyB,MAArBA,EAAGrB,cAAuB,CAC1BqB,EAAGpB,OACH,IAAMxF,EAAKvC,KAAK6J,cAAcV,GAC9B,OAAO,IAAI9E,EAAkB9B,EAChC,CACD,GAAyB,MAArB4G,EAAGrB,cAAuB,CAC1BqB,EAAGpB,OACH,IACIwE,EAKAnI,EANE7B,EAAKvC,KAAK6J,cAAcV,GAY9B,MAVyB,MAArBA,EAAGrB,gBACHqB,EAAGpB,OACHwE,EAAOvM,KAAK6J,cAAcV,IAG9BA,EAAGvB,YACsB,MAArBuB,EAAGhC,gBACHgC,EAAG3B,aACHpD,EAAOpE,KAAKsK,iBAAiBnB,IAE1B,IAAIhF,EAAc5B,EAAIgK,EAAMnI,EACtC,CACD,GAAI+E,EAAG0C,oBAAqB,CACxB,IAWIU,EAXEhK,EAAKvC,KAAK6J,cAAcV,GAE9B,GADAA,EAAGvB,YACsB,MAArBuB,EAAGhC,cAAuB,CAE1B,IAAK,qBAAqB6H,KAAKzM,EAAG4C,MAC9B,MAAM,IAAIc,EAAW,SAEzBkD,EAAG3B,aACH,IAAIpD,EAAOpE,KAAKsK,iBAAiBnB,GACjC,OAAO,IAAI7E,EAAkB/B,EAAI6B,EACpC,CAMD,MAJyB,MAArB+E,EAAGrB,gBACHqB,EAAGpB,OACHwE,EAAOvM,KAAK6J,cAAcV,IAEvB,IAAIlF,EAAiB1B,EAAIgK,EACnC,CACD,MAAM,IAAItG,EAAW,QACxB,G,6BACD,SAAgBkD,GACZ,IAAM8F,EAAMjP,KAAKoK,oBAAoBjB,GAErC,GADAA,EAAGyD,YACsB,MAArBzD,EAAGrB,cACH,OAAOmH,EAEX,GAAIA,aAAehL,GAAsC,OAAlBgL,EAAI/K,UAAoB,CAC3DiF,EAAGpB,OACHoB,EAAGyD,YACH,IAAMxL,EAAQpB,KAAKwK,WAAWrB,GAC9B,OAAO,IAAIjE,EAAc+J,EAAI1M,GAAInB,EACpC,CACD,MAAM,IAAI6E,EAAW,QACxB,G,8BACD,SAAiBkD,GACb,IAAMxE,EAAa,GACbC,EAAQ,GACRsK,EAAgB,IAAI7O,IAG1B,IAFA8I,EAAG4C,WAAW,KACd5C,EAAGyD,YAE0B,MAArBzD,EAAGrB,eADE,CAIT,IAAMqH,EAAMnP,KAAKqK,gBAAgBlB,GACjC,GAAIgG,aAAejK,EAAe,CAC9B,GAAIgK,EAActO,IAAIuO,EAAIhK,KAAKA,MAC3B,MAAM,IAAIc,EAAW,SAEzBrB,EAAMiB,KAAKsJ,GACXD,EAAcE,IAAID,EAAIhK,KAAKA,KAC9B,KACI,IAAI+J,EAAcvO,KAAO,EAC1B,MAAM,IAAIsF,EAAW,SAGrBtB,EAAWkB,KAAKsJ,EACnB,CAED,GADAhG,EAAGyD,YACsB,MAArBzD,EAAGrB,cAKP,MAJIqB,EAAGpB,OACHoB,EAAGyD,WAIV,CAED,OADAzD,EAAG4C,WAAW,KACP,IAAIrH,EAAcC,EAAYC,EACxC,G,uBACD,SAAUuE,GACNA,EAAG4C,WAAW,KAGd,IAFA,IACIlE,EADAzG,EAAQ,GAEJyG,EAAKsB,EAAGJ,UAAS,SAAAiD,GAAC,MAAU,MAANA,GAAaA,IAAMlF,CAAvB,KAElB1F,GADO,OAAPyG,EACS7H,KAAKqP,kBAAkBlG,GAGvBtB,EAGjB,GAAIsB,EAAGrB,gBAAkBhB,EACrB,MAAM,IAAIb,EAAW,SAGzB,OADAkD,EAAG4C,WAAW,KACP,IAAI5I,EAAc/B,EAC5B,G,wBACD,SAAW+H,GACP,GAAIA,EAAG4F,gBACH,OAAO/O,KAAK+J,UAAUZ,GAE1B,GAAyB,MAArBA,EAAGrB,cACH,OAAO9H,KAAKuK,UAAUpB,GAE1B,MAAM,IAAIlD,EAAW,QACxB,K,EA5nBCuD,GA8nBAwE,GAAAA,EAAAA,EAAAA,IACF,WAAY5M,EAAOW,EAAOC,IAAK,eAC3BhC,KAAKC,KAAO,SACZD,KAAKoB,MAAQA,EACbpB,KAAKiC,KAAO,IAAIC,EAAKH,EAAOC,EAC/B,IAGL,SAASsN,EAAM7E,EAAQ8E,GAEnB,OADe,IAAI/F,EAAa+F,GAClBD,MAAM7E,EACvB,CAED,IAAI+E,GAAc,SAAqBC,GACrC,MAAO,MAAQA,EAAKxP,IACrB,EAEGyP,GAAa,CACfC,UAAW,SAAmBF,GAC5B,GAAIzP,KAAKwP,GAAYC,IACnB,OAAOzP,KAAKwP,GAAYC,IAAOA,GAE/BG,QAAQC,KAAK,gBAAiBJ,EAAKxP,KAAMwP,EAE5C,EACDhG,WAAY,SAAoBgG,GAC9B,MAAO,CACL1K,IAAK,UACL3D,MAAOqO,EAAKnK,QAEf,EACDwK,gBAAiB,WACf,OAAO,IACR,EACDC,mBAAoB,WAClB,OAAO,IACR,EACDrG,WAAY,SAAoB+F,GAC9B,IAAIO,EAAQhQ,KAEZ,MAAO,CACL+E,IAAK/E,KAAKwP,GAAYC,EAAKlN,KAAKkN,EAAKlN,IACrCnB,MAAOpB,KAAKwP,GAAYC,EAAKrO,QAAQqO,EAAKrO,OAC1CqB,QAASgN,EAAKhN,SAAWzC,KAAKwP,GAAYC,EAAKhN,UAAUgN,EAAKhN,SAC9DD,WAAYiN,EAAKjN,YAAciN,EAAKjN,WAAWjB,KAAI,SAAUgL,GAC3D,OAAOyD,EAAML,UAAUpD,EACxB,IAEJ,EACD3C,aAAc,SAAsB6F,GAClC,MAAO,CACL1K,IAAK/E,KAAKwP,GAAYC,EAAKlN,KAAKkN,EAAKlN,IACrCnB,MAAOpB,KAAKwP,GAAYC,EAAKrO,QAAQqO,EAAKrO,OAE7C,EACDuI,QAAS,SAAiB8F,GACxB,IAAIQ,EAASjQ,KAEb,MAAO,CACL+E,IAAK,IAAImL,OAAOlQ,KAAKwP,GAAYC,EAAKlN,KAAKkN,EAAKlN,KAChDnB,MAAOpB,KAAKwP,GAAYC,EAAKrO,QAAQqO,EAAKrO,OAC1CqB,QAASgN,EAAKhN,SAAWzC,KAAKwP,GAAYC,EAAKhN,UAAUgN,EAAKhN,SAC9DD,WAAYiN,EAAKjN,YAAciN,EAAKjN,WAAWjB,KAAI,SAAUgL,GAC3D,OAAO0D,EAAON,UAAUpD,EACzB,IAEJ,EACD1C,cAAe,SAAuB4F,GACpC,OAAOA,EAAKtK,IACb,EACDgL,iBAAkB,SAA0BV,GAC1C,OAAOA,EAAKrO,KACb,EACD4I,WAAY,SAAoByF,GAC9B,IAAIW,EAASpQ,KAiBb,OAfYyP,EAAK7M,SAASrB,KAAI,SAAU8O,GACtC,OAAIA,EAAUrN,WACPoN,EAAOZ,GAAYa,EAAUrN,aAI3BoN,EAAOZ,GAAYa,EAAUrN,aAAaqN,EAAUrN,YAHlD4M,QAAQU,IAAI,WAAYd,GAAYa,EAAUrN,YAAaqN,EAAUrN,YAKzEoN,EAAOZ,GAAYa,IAIjBD,EAAOZ,GAAYa,IAAYA,GAH7BT,QAAQU,IAAI,WAAYd,GAAYa,GAAYA,EAK5D,IACYE,KAAK,GACnB,EACDC,kBAAmB,SAA2Bf,GAC5C,IAAIgB,EAASzQ,KAET0Q,EAASjB,EAAKkB,OAAOxL,KACrByL,EAAcnB,EAAK9K,WAAWpD,KAAI,SAAUoD,GAC9C,OAAO8L,EAAOjB,GAAY7K,IAAaA,GAAY,EACpD,IACGkM,EAASpB,EAAK7K,MAAMrD,KAAI,SAAUqD,GACpC,OAAO6L,EAAOjB,GAAY5K,IAAQA,EACnC,IACD,MAAO,KAAO8L,EAAS,KAAOE,EAAYL,KAAK,MAAQM,EAAO7P,OAAS,KAAO6P,EAAON,KAAK,MAAQ,IAAM,KACzG,EACDO,iBAAkB,SAA0BrB,GAC1C,OAAOzP,KAAKwP,GAAYC,EAAKtK,OAAOsK,EAAKtK,MAAQ,MAAQnF,KAAKwP,GAAYC,EAAKrO,QAAQqO,EAAKrO,OAAS,GACtG,EACD6I,eAAgB,SAAwBwF,GACtC,OAAOA,EAAKrO,KACb,EACD2P,oBAAqB,SAA6BtB,GAChD,IAAIuB,EAAShR,KAMb,MAAO,MAJEA,KAAKwP,GAAYC,EAAKjL,WAAWiL,EAAKjL,UAAU,GAIrC,QAHLiL,EAAKhL,SAASlD,KAAI,SAAUwL,GACzC,OAAOiE,EAAOxB,GAAYzC,IAAUA,EACrC,IACsCwD,KAAK,MAAQ,KACrD,EACDU,qBAAsB,SAA8BxB,GAClD,IAAIyB,EAAMlR,KAAKwP,GAAYC,EAAKyB,MAAMzB,EAAKyB,KAAK,GAC5CnM,EAAM/E,KAAKwP,GAAYC,EAAK1K,MAAM0K,EAAK1K,KAC3C,OAAIA,EAAY,KAAOmM,EAAM,IAAMnM,EAAM,MAClC,MAAQmM,EAAM,KACtB,EACDC,qBAAsB,SAA8B1B,EAAM2B,GACxD,OAAIA,EAAcpR,KAAKwP,GAAYC,EAAKlN,KAAKkN,EAAKlN,IAC3C,MAAQvC,KAAKwP,GAAYC,EAAKlN,KAAKkN,EAAKlN,IAAM,IACtD,EACD8O,kBAAmB,SAA2B5B,EAAM2B,GAClD,OAAIA,EAAcpR,KAAKwP,GAAYC,EAAKlN,KAAKkN,EAAKlN,IAC3C,KAAOvC,KAAKwP,GAAYC,EAAKlN,KAAKkN,EAAKlN,IAAM,IACrD,EACD+O,eAAgB,SAAwB7B,GACtC,OAAOA,EAAKtK,IACb,EACDoM,eAAgB,SAAwB9B,GACtC,IAAI+B,EAASxR,KAKb,MAAO,MAHQyP,EAAKhL,SAASlD,KAAI,SAAUwL,GACzC,OAAOyE,EAAOhC,GAAYzC,IAAUA,EACrC,IACuBwD,KAAK,MAAQ,KACtC,EACDzG,WAAY,SAAoB2F,GAC9B,IAAItK,EAAOsK,EAAK1K,IAAII,KAAOsK,EAAK1K,IAAII,KAAOsK,EAAK1K,IAAI3D,MAChDqQ,EAAYhC,EAAKxK,QAEjB6D,EAAM,IAAM3D,EAAO,KADTnF,KAAKwP,GAAYC,EAAKrO,QAAQqO,EAAKrO,OAEjD,OAAIqQ,EAAkB,KAAO3I,EACtB,KAAOA,CACf,EACD4I,qBAAsB,SAA8BjC,GAClD,IAAIrL,EAAO,GASX,OARAqL,EAAK3N,UAAU6C,WAAWgN,SAAQ,SAAUC,EAAG3Q,GACzCA,EAAI,IAAGmD,GAAQ,MACnBA,GAAQ,IAAI8L,OAAO0B,EAAErP,GAAG4C,KACzB,IACDsK,EAAK3N,UAAU8C,MAAM+M,SAAQ,SAAUE,EAAG5Q,IACpCA,EAAI,GAAc,KAATmD,KAAaA,GAAQ,MAClCA,GAAQ,GAAG8L,OAAO2B,EAAE1M,KAAKA,KAAM,OAAQ+K,OAAO2B,EAAEzQ,MAAMA,MAAO,IAC9D,IACM,KAAK8O,OAAOT,EAAKlN,GAAG4C,KAAM,KAAK+K,OAAO9L,EAAM,MACpD,EACD0N,iBAAkB,SAA0BrC,GAC1C,MAAO,MAAMS,OAAOT,EAAKlN,GAAG4C,KAAM,KACnC,EACD4M,QAAS,SAAiBtC,GACxB,IAAIuC,EAAQvC,EAAKnK,QAAQ2M,MAAM,KAG/B,MAAO,CACLlN,IAHQiN,EAAME,QAAQC,OAItB/Q,MAHU4Q,EAAMzB,KAAK,KAAK4B,OAAO/O,QAAQ,UAAW,OAAOA,QAAQ,WAAY,OAKlF,GAGH,SAASgP,GAAQC,EAAKC,GACpB,IAAIC,EAASzQ,UAAUd,OAAS,QAAsBgG,IAAjBlF,UAAU,GAAmBA,UAAU,GAAK,CAC/E0Q,iBAAiB,GAGnB,GAAmB,kBAARH,EAAkB,CAC3B,IAAKC,EAAI,MAAM,IAAInM,MAAM,wCACzB,OAAOmM,EAAG,IAAInM,MAAM,wCACrB,CAED,IAAIsM,EAASnD,EAAM+C,EAAK,CACtBjJ,WAAW,IAETsJ,EAASD,EAAOrQ,KAAKuQ,QAAO,SAAUC,EAAKC,GAC7C,IAAIpD,EAAOC,GAAWC,UAAUkD,GAChC,IAAKpD,EAAM,OAAOmD,EAElB,GAAInD,EAAKjN,YAAciN,EAAKjN,WAAWxB,QAAUyO,EAAKhN,SAAW8P,EAAOC,gBAAiB,CACvF,IAAIM,EAAQ,CAAC,EACTrD,EAAKhN,UAASqQ,EAAMrD,EAAKhN,QAAQsC,KAAO0K,EAAKhN,QAAQrB,OAErDqO,EAAKjN,YAAciN,EAAKjN,WAAWxB,QACrCyO,EAAKjN,WAAWmP,SAAQ,SAAUpF,GAChCuG,EAAMvG,EAAKxH,KAAOwH,EAAKnL,KACxB,IAGH0R,EAAMC,IAAMtD,EAAKrO,MACjBwR,EAAInD,EAAK1K,KAAO+N,CACjB,MACCF,EAAInD,EAAK1K,KAAO0K,EAAKrO,MAGvB,OAAOwR,CACR,GAAE,CAAC,GAEJ,OADIN,GAAIA,EAAG,KAAMI,GACVA,CACR,CAED,SAASM,GAASC,EAAG7R,GACnB,IAAI8R,EAAM,GAUV,OATAA,EAAMA,EAAMD,EAAI,KAEZ7R,GAASA,EAAM2C,QAAQ,OAAS,GAClCmP,GAAY,OACZA,GAAY9R,EAAM6Q,MAAM,MAAM1B,KAAK,SAEnC2C,EAAMA,EAAM,IAAM9R,EAGb8R,CACR,CASD,SAASC,GAAOC,EAAWd,GACzB,IAAIY,EAAM,GAmBV,OAlBA5S,OAAOC,KAAK6S,GAAWzB,SAAQ,SAAUsB,GACvC,IAAI7R,EAAQgS,EAAUH,GAED,kBAAV7R,GACT8R,GAAYF,GAASC,EAAG7R,GACxB8R,GAAY,SAER9R,EAAMqB,UAASyQ,GAhBzB,SAAoBzQ,GAClB,IAAIyQ,EAAM,GAGV,OAFAA,EAAMA,EAAM,KAAOzQ,EAAQwP,MAAM,MAAM1B,KAAK,QAC5C2C,EAAY,IAEb,CAWoCG,CAAWjS,EAAMqB,UAChDyQ,GAAYF,GAASC,EAAG7R,EAAM2R,KAC9BzS,OAAOC,KAAKa,GAAOuQ,SAAQ,SAAU2B,GACnC,GAAe,YAAXA,GAAmC,QAAXA,EAA5B,CACA,IAAIC,EAAanS,EAAMkS,GACvBJ,GAAYF,GAAS,QAAUM,EAAQC,EAFa,CAGrD,IACDL,GAAY,OAEf,IACGZ,GAAIA,EAAG,KAAMY,GACVA,CACR,CAED,IAAIxM,GAAQ,CACV8M,OAAQpB,GACRe,OAAQA,IAGV,Y,wFChmDe,SAASM,EAAaC,GACnC,IAAIC,GAA4B,SAChC,OAAO,WACL,IACEjB,EADEkB,GAAQ,OAAeF,GAE3B,GAAIC,EAA2B,CAC7B,IAAIE,GAAY,OAAe7T,MAAMyB,YACrCiR,EAASoB,QAAQC,UAAUH,EAAO9R,UAAW+R,EAC/C,MACEnB,EAASkB,EAAMI,MAAMhU,KAAM8B,WAE7B,OAAO,OAA0B9B,KAAM0S,EACzC,CACF,C,sBChBe,SAASuB,IACtB,GAAuB,qBAAZH,UAA4BA,QAAQC,UAAW,OAAO,EACjE,GAAID,QAAQC,UAAUG,KAAM,OAAO,EACnC,GAAqB,oBAAVC,MAAsB,OAAO,EACxC,IAEE,OADAC,QAAQ1S,UAAU2S,QAAQhL,KAAKyK,QAAQC,UAAUK,QAAS,IAAI,WAAa,MACpE,CAGT,CAFE,MAAOE,GACP,OAAO,CACT,CACF,C,2HCRe,SAASC,EAAWC,EAAQpQ,EAAMqQ,GAa/C,OAXEF,GADE,EAAAG,EAAA,KACWZ,QAAQC,UAAUY,OAElB,SAAoBH,EAAQpQ,EAAMqQ,GAC7C,IAAIG,EAAI,CAAC,MACTA,EAAE/O,KAAKmO,MAAMY,EAAGxQ,GAChB,IACIyQ,EAAW,IADGC,SAASH,KAAKX,MAAMQ,EAAQI,IAG9C,OADIH,IAAO,EAAAM,EAAA,GAAeF,EAAUJ,EAAM/S,WACnCmT,CACT,EAEKN,EAAWP,MAAM,KAAMlS,UAChC,CCZe,SAASkT,EAAiBP,GACvC,IAAIQ,EAAwB,oBAARC,IAAqB,IAAIA,SAAQlO,EAuBrD,OAtBAgO,EAAmB,SAA0BP,GAC3C,GAAc,OAAVA,ICPkCvL,EDOEuL,GCNsB,IAAzDK,SAASK,SAAS9L,KAAKH,GAAInF,QAAQ,kBDMQ,OAAO0Q,ECP5C,IAA2BvL,EDQtC,GAAqB,oBAAVuL,EACT,MAAM,IAAIW,UAAU,sDAEtB,GAAsB,qBAAXH,EAAwB,CACjC,GAAIA,EAAOrU,IAAI6T,GAAQ,OAAOQ,EAAOI,IAAIZ,GACzCQ,EAAOK,IAAIb,EAAOc,EACpB,CACA,SAASA,IACP,OAAO,EAAUd,EAAO3S,WAAW,EAAA0T,EAAA,GAAexV,MAAMyB,YAC1D,CASA,OARA8T,EAAQ7T,UAAYpB,OAAOkB,OAAOiT,EAAM/S,UAAW,CACjDD,YAAa,CACXL,MAAOmU,EACPE,YAAY,EACZC,UAAU,EACVC,cAAc,MAGX,EAAAZ,EAAA,GAAeQ,EAASd,EACjC,EACOO,EAAiBP,EAC1B,C","sources":["../../file-fluent/dist/es/index-f22bddf0.js","../../../node_modules/@babel/runtime/helpers/esm/createSuper.js","../../../node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js","../../../node_modules/@babel/runtime/helpers/esm/construct.js","../../../node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js","../../../node_modules/@babel/runtime/helpers/esm/isNativeFunction.js"],"sourcesContent":["/*\n * Base class for all Fluent AST nodes.\n *\n * All productions described in the ASDL subclass BaseNode, including Span and\n * Annotation.\n *\n */\nclass BaseNode {\n    constructor() {\n        this.type = \"BaseNode\";\n    }\n    equals(other, ignoredFields = [\"span\"]) {\n        const thisKeys = new Set(Object.keys(this));\n        const otherKeys = new Set(Object.keys(other));\n        if (ignoredFields) {\n            for (const fieldName of ignoredFields) {\n                thisKeys.delete(fieldName);\n                otherKeys.delete(fieldName);\n            }\n        }\n        if (thisKeys.size !== otherKeys.size) {\n            return false;\n        }\n        for (const fieldName of thisKeys) {\n            if (!otherKeys.has(fieldName)) {\n                return false;\n            }\n            const thisVal = this[fieldName];\n            const otherVal = other[fieldName];\n            if (typeof thisVal !== typeof otherVal) {\n                return false;\n            }\n            if (thisVal instanceof Array && otherVal instanceof Array) {\n                if (thisVal.length !== otherVal.length) {\n                    return false;\n                }\n                for (let i = 0; i < thisVal.length; ++i) {\n                    if (!scalarsEqual(thisVal[i], otherVal[i], ignoredFields)) {\n                        return false;\n                    }\n                }\n            }\n            else if (!scalarsEqual(thisVal, otherVal, ignoredFields)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    clone() {\n        function visit(value) {\n            if (value instanceof BaseNode) {\n                return value.clone();\n            }\n            if (Array.isArray(value)) {\n                return value.map(visit);\n            }\n            return value;\n        }\n        const clone = Object.create(this.constructor.prototype);\n        for (const prop of Object.keys(this)) {\n            clone[prop] = visit(this[prop]);\n        }\n        return clone;\n    }\n}\nfunction scalarsEqual(thisVal, otherVal, ignoredFields) {\n    if (thisVal instanceof BaseNode && otherVal instanceof BaseNode) {\n        return thisVal.equals(otherVal, ignoredFields);\n    }\n    return thisVal === otherVal;\n}\n/*\n * Base class for AST nodes which can have Spans.\n */\nclass SyntaxNode extends BaseNode {\n    constructor() {\n        super(...arguments);\n        this.type = \"SyntaxNode\";\n    }\n    addSpan(start, end) {\n        this.span = new Span(start, end);\n    }\n}\nclass Resource extends SyntaxNode {\n    constructor(body = []) {\n        super();\n        this.type = \"Resource\";\n        this.body = body;\n    }\n}\n/*\n * An abstract base class for useful elements of Resource.body.\n */\nclass Entry extends SyntaxNode {\n    constructor() {\n        super(...arguments);\n        this.type = \"Entry\";\n    }\n}\nclass Message extends Entry {\n    constructor(id, value = null, attributes = [], comment = null) {\n        super();\n        this.type = \"Message\";\n        this.id = id;\n        this.value = value;\n        this.attributes = attributes;\n        this.comment = comment;\n    }\n}\nclass Term extends Entry {\n    constructor(id, value, attributes = [], comment = null) {\n        super();\n        this.type = \"Term\";\n        this.id = id;\n        this.value = value;\n        this.attributes = attributes;\n        this.comment = comment;\n    }\n}\nclass Pattern extends SyntaxNode {\n    constructor(elements) {\n        super();\n        this.type = \"Pattern\";\n        this.elements = elements;\n    }\n}\n/*\n * An abstract base class for elements of Patterns.\n */\nclass PatternElement extends SyntaxNode {\n    constructor() {\n        super(...arguments);\n        this.type = \"PatternElement\";\n    }\n}\nclass TextElement extends PatternElement {\n    constructor(value) {\n        super();\n        this.type = \"TextElement\";\n        this.value = value;\n    }\n}\nclass Placeable extends PatternElement {\n    constructor(expression) {\n        super();\n        this.type = \"Placeable\";\n        this.expression = expression;\n    }\n}\n/*\n * An abstract base class for expressions.\n */\nclass Expression extends SyntaxNode {\n    constructor() {\n        super(...arguments);\n        this.type = \"Expression\";\n    }\n}\n// An abstract base class for Literals.\nclass Literal extends Expression {\n    constructor(value) {\n        super();\n        this.type = \"Literal\";\n        // The \"value\" field contains the exact contents of the literal,\n        // character-for-character.\n        this.value = value;\n    }\n}\nclass StringLiteral extends Literal {\n    constructor() {\n        super(...arguments);\n        this.type = \"StringLiteral\";\n    }\n    parse() {\n        // Backslash backslash, backslash double quote, uHHHH, UHHHHHH.\n        const KNOWN_ESCAPES = /(?:\\\\\\\\|\\\\\"|\\\\u([0-9a-fA-F]{4})|\\\\U([0-9a-fA-F]{6}))/g;\n        function fromEscapeSequence(match, codepoint4, codepoint6) {\n            switch (match) {\n                case \"\\\\\\\\\":\n                    return \"\\\\\";\n                case \"\\\\\\\"\":\n                    return \"\\\"\";\n                default: {\n                    let codepoint = parseInt(codepoint4 || codepoint6, 16);\n                    if (codepoint <= 0xD7FF || 0xE000 <= codepoint) {\n                        // It's a Unicode scalar value.\n                        return String.fromCodePoint(codepoint);\n                    }\n                    // Escape sequences reresenting surrogate code points are\n                    // well-formed but invalid in Fluent. Replace them with U+FFFD\n                    // REPLACEMENT CHARACTER.\n                    return \"ï¿½\";\n                }\n            }\n        }\n        let value = this.value.replace(KNOWN_ESCAPES, fromEscapeSequence);\n        return { value };\n    }\n}\nclass NumberLiteral extends Literal {\n    constructor() {\n        super(...arguments);\n        this.type = \"NumberLiteral\";\n    }\n    parse() {\n        let value = parseFloat(this.value);\n        let decimalPos = this.value.indexOf(\".\");\n        let precision = decimalPos > 0\n            ? this.value.length - decimalPos - 1\n            : 0;\n        return { value, precision };\n    }\n}\nclass MessageReference extends Expression {\n    constructor(id, attribute = null) {\n        super();\n        this.type = \"MessageReference\";\n        this.id = id;\n        this.attribute = attribute;\n    }\n}\nclass TermReference extends Expression {\n    constructor(id, attribute = null, args = null) {\n        super();\n        this.type = \"TermReference\";\n        this.id = id;\n        this.attribute = attribute;\n        this.arguments = args;\n    }\n}\nclass VariableReference extends Expression {\n    constructor(id) {\n        super();\n        this.type = \"VariableReference\";\n        this.id = id;\n    }\n}\nclass FunctionReference extends Expression {\n    constructor(id, args) {\n        super();\n        this.type = \"FunctionReference\";\n        this.id = id;\n        this.arguments = args;\n    }\n}\nclass SelectExpression extends Expression {\n    constructor(selector, variants) {\n        super();\n        this.type = \"SelectExpression\";\n        this.selector = selector;\n        this.variants = variants;\n    }\n}\nclass CallArguments extends SyntaxNode {\n    constructor(positional = [], named = []) {\n        super();\n        this.type = \"CallArguments\";\n        this.positional = positional;\n        this.named = named;\n    }\n}\nclass Attribute extends SyntaxNode {\n    constructor(id, value) {\n        super();\n        this.type = \"Attribute\";\n        this.id = id;\n        this.value = value;\n    }\n}\nclass Variant extends SyntaxNode {\n    constructor(key, value, def) {\n        super();\n        this.type = \"Variant\";\n        this.key = key;\n        this.value = value;\n        this.default = def;\n    }\n}\nclass NamedArgument extends SyntaxNode {\n    constructor(name, value) {\n        super();\n        this.type = \"NamedArgument\";\n        this.name = name;\n        this.value = value;\n    }\n}\nclass Identifier extends SyntaxNode {\n    constructor(name) {\n        super();\n        this.type = \"Identifier\";\n        this.name = name;\n    }\n}\nclass BaseComment extends Entry {\n    constructor(content) {\n        super();\n        this.type = \"BaseComment\";\n        this.content = content;\n    }\n}\nclass Comment extends BaseComment {\n    constructor() {\n        super(...arguments);\n        this.type = \"Comment\";\n    }\n}\nclass GroupComment extends BaseComment {\n    constructor() {\n        super(...arguments);\n        this.type = \"GroupComment\";\n    }\n}\nclass ResourceComment extends BaseComment {\n    constructor() {\n        super(...arguments);\n        this.type = \"ResourceComment\";\n    }\n}\nclass Junk extends SyntaxNode {\n    constructor(content) {\n        super();\n        this.type = \"Junk\";\n        this.annotations = [];\n        this.content = content;\n    }\n    addAnnotation(annotation) {\n        this.annotations.push(annotation);\n    }\n}\nclass Span extends BaseNode {\n    constructor(start, end) {\n        super();\n        this.type = \"Span\";\n        this.start = start;\n        this.end = end;\n    }\n}\nclass Annotation extends SyntaxNode {\n    constructor(code, args = [], message) {\n        super();\n        this.type = \"Annotation\";\n        this.code = code;\n        this.arguments = args;\n        this.message = message;\n    }\n}\n\nclass ParseError extends Error {\n    constructor(code, ...args) {\n        super();\n        this.code = code;\n        this.args = args;\n        this.message = getErrorMessage(code, args);\n    }\n}\n/* eslint-disable complexity */\nfunction getErrorMessage(code, args) {\n    switch (code) {\n        case \"E0001\":\n            return \"Generic error\";\n        case \"E0002\":\n            return \"Expected an entry start\";\n        case \"E0003\": {\n            const [token] = args;\n            return `Expected token: \"${token}\"`;\n        }\n        case \"E0004\": {\n            const [range] = args;\n            return `Expected a character from range: \"${range}\"`;\n        }\n        case \"E0005\": {\n            const [id] = args;\n            return `Expected message \"${id}\" to have a value or attributes`;\n        }\n        case \"E0006\": {\n            const [id] = args;\n            return `Expected term \"-${id}\" to have a value`;\n        }\n        case \"E0007\":\n            return \"Keyword cannot end with a whitespace\";\n        case \"E0008\":\n            return \"The callee has to be an upper-case identifier or a term\";\n        case \"E0009\":\n            return \"The argument name has to be a simple identifier\";\n        case \"E0010\":\n            return \"Expected one of the variants to be marked as default (*)\";\n        case \"E0011\":\n            return 'Expected at least one variant after \"->\"';\n        case \"E0012\":\n            return \"Expected value\";\n        case \"E0013\":\n            return \"Expected variant key\";\n        case \"E0014\":\n            return \"Expected literal\";\n        case \"E0015\":\n            return \"Only one variant can be marked as default (*)\";\n        case \"E0016\":\n            return \"Message references cannot be used as selectors\";\n        case \"E0017\":\n            return \"Terms cannot be used as selectors\";\n        case \"E0018\":\n            return \"Attributes of messages cannot be used as selectors\";\n        case \"E0019\":\n            return \"Attributes of terms cannot be used as placeables\";\n        case \"E0020\":\n            return \"Unterminated string expression\";\n        case \"E0021\":\n            return \"Positional arguments must not follow named arguments\";\n        case \"E0022\":\n            return \"Named arguments must be unique\";\n        case \"E0024\":\n            return \"Cannot access variants of a message.\";\n        case \"E0025\": {\n            const [char] = args;\n            return `Unknown escape sequence: \\\\${char}.`;\n        }\n        case \"E0026\": {\n            const [sequence] = args;\n            return `Invalid Unicode escape sequence: ${sequence}.`;\n        }\n        case \"E0027\":\n            return \"Unbalanced closing brace in TextElement.\";\n        case \"E0028\":\n            return \"Expected an inline expression\";\n        case \"E0029\":\n            return \"Expected simple expression as selector\";\n        default:\n            return code;\n    }\n}\n\n/* eslint no-magic-numbers: \"off\" */\nclass ParserStream {\n    constructor(string) {\n        this.string = string;\n        this.index = 0;\n        this.peekOffset = 0;\n    }\n    charAt(offset) {\n        // When the cursor is at CRLF, return LF but don't move the cursor.\n        // The cursor still points to the EOL position, which in this case is the\n        // beginning of the compound CRLF sequence. This ensures slices of\n        // [inclusive, exclusive) continue to work properly.\n        if (this.string[offset] === \"\\r\"\n            && this.string[offset + 1] === \"\\n\") {\n            return \"\\n\";\n        }\n        return this.string[offset];\n    }\n    currentChar() {\n        return this.charAt(this.index);\n    }\n    currentPeek() {\n        return this.charAt(this.index + this.peekOffset);\n    }\n    next() {\n        this.peekOffset = 0;\n        // Skip over the CRLF as if it was a single character.\n        if (this.string[this.index] === \"\\r\"\n            && this.string[this.index + 1] === \"\\n\") {\n            this.index++;\n        }\n        this.index++;\n        return this.string[this.index];\n    }\n    peek() {\n        // Skip over the CRLF as if it was a single character.\n        if (this.string[this.index + this.peekOffset] === \"\\r\"\n            && this.string[this.index + this.peekOffset + 1] === \"\\n\") {\n            this.peekOffset++;\n        }\n        this.peekOffset++;\n        return this.string[this.index + this.peekOffset];\n    }\n    resetPeek(offset = 0) {\n        this.peekOffset = offset;\n    }\n    skipToPeek() {\n        this.index += this.peekOffset;\n        this.peekOffset = 0;\n    }\n}\nconst EOL = \"\\n\";\nconst EOF = undefined;\nconst SPECIAL_LINE_START_CHARS = [\"}\", \".\", \"[\", \"*\"];\nclass FluentParserStream extends ParserStream {\n    peekBlankInline() {\n        const start = this.index + this.peekOffset;\n        while (this.currentPeek() === \" \") {\n            this.peek();\n        }\n        return this.string.slice(start, this.index + this.peekOffset);\n    }\n    skipBlankInline() {\n        const blank = this.peekBlankInline();\n        this.skipToPeek();\n        return blank;\n    }\n    peekBlankBlock() {\n        let blank = \"\";\n        while (true) {\n            const lineStart = this.peekOffset;\n            this.peekBlankInline();\n            if (this.currentPeek() === EOL) {\n                blank += EOL;\n                this.peek();\n                continue;\n            }\n            if (this.currentPeek() === EOF) {\n                // Treat the blank line at EOF as a blank block.\n                return blank;\n            }\n            // Any other char; reset to column 1 on this line.\n            this.resetPeek(lineStart);\n            return blank;\n        }\n    }\n    skipBlankBlock() {\n        const blank = this.peekBlankBlock();\n        this.skipToPeek();\n        return blank;\n    }\n    peekBlank() {\n        while (this.currentPeek() === \" \" || this.currentPeek() === EOL) {\n            this.peek();\n        }\n    }\n    skipBlank() {\n        this.peekBlank();\n        this.skipToPeek();\n    }\n    expectChar(ch) {\n        if (this.currentChar() === ch) {\n            this.next();\n            return;\n        }\n        throw new ParseError(\"E0003\", ch);\n    }\n    expectLineEnd() {\n        if (this.currentChar() === EOF) {\n            // EOF is a valid line end in Fluent.\n            return;\n        }\n        if (this.currentChar() === EOL) {\n            this.next();\n            return;\n        }\n        // Unicode Character 'SYMBOL FOR NEWLINE' (U+2424)\n        throw new ParseError(\"E0003\", \"\\u2424\");\n    }\n    takeChar(f) {\n        const ch = this.currentChar();\n        if (ch === EOF) {\n            return EOF;\n        }\n        if (f(ch)) {\n            this.next();\n            return ch;\n        }\n        return null;\n    }\n    isCharIdStart(ch) {\n        if (ch === EOF) {\n            return false;\n        }\n        const cc = ch.charCodeAt(0);\n        return (cc >= 97 && cc <= 122) || // a-z\n            (cc >= 65 && cc <= 90); // A-Z\n    }\n    isIdentifierStart() {\n        return this.isCharIdStart(this.currentPeek());\n    }\n    isNumberStart() {\n        const ch = this.currentChar() === \"-\"\n            ? this.peek()\n            : this.currentChar();\n        if (ch === EOF) {\n            this.resetPeek();\n            return false;\n        }\n        const cc = ch.charCodeAt(0);\n        const isDigit = cc >= 48 && cc <= 57; // 0-9\n        this.resetPeek();\n        return isDigit;\n    }\n    isCharPatternContinuation(ch) {\n        if (ch === EOF) {\n            return false;\n        }\n        return !SPECIAL_LINE_START_CHARS.includes(ch);\n    }\n    isValueStart() {\n        // Inline Patterns may start with any char.\n        const ch = this.currentPeek();\n        return ch !== EOL && ch !== EOF;\n    }\n    isValueContinuation() {\n        const column1 = this.peekOffset;\n        this.peekBlankInline();\n        if (this.currentPeek() === \"{\") {\n            this.resetPeek(column1);\n            return true;\n        }\n        if (this.peekOffset - column1 === 0) {\n            return false;\n        }\n        if (this.isCharPatternContinuation(this.currentPeek())) {\n            this.resetPeek(column1);\n            return true;\n        }\n        return false;\n    }\n    // -1 - any\n    //  0 - comment\n    //  1 - group comment\n    //  2 - resource comment\n    isNextLineComment(level = -1) {\n        if (this.currentChar() !== EOL) {\n            return false;\n        }\n        let i = 0;\n        while (i <= level || (level === -1 && i < 3)) {\n            if (this.peek() !== \"#\") {\n                if (i <= level && level !== -1) {\n                    this.resetPeek();\n                    return false;\n                }\n                break;\n            }\n            i++;\n        }\n        // The first char after #, ## or ###.\n        const ch = this.peek();\n        if (ch === \" \" || ch === EOL) {\n            this.resetPeek();\n            return true;\n        }\n        this.resetPeek();\n        return false;\n    }\n    isVariantStart() {\n        const currentPeekOffset = this.peekOffset;\n        if (this.currentPeek() === \"*\") {\n            this.peek();\n        }\n        if (this.currentPeek() === \"[\") {\n            this.resetPeek(currentPeekOffset);\n            return true;\n        }\n        this.resetPeek(currentPeekOffset);\n        return false;\n    }\n    isAttributeStart() {\n        return this.currentPeek() === \".\";\n    }\n    skipToNextEntryStart(junkStart) {\n        let lastNewline = this.string.lastIndexOf(EOL, this.index);\n        if (junkStart < lastNewline) {\n            // Last seen newline is _after_ the junk start. It's safe to rewind\n            // without the risk of resuming at the same broken entry.\n            this.index = lastNewline;\n        }\n        while (this.currentChar()) {\n            // We're only interested in beginnings of line.\n            if (this.currentChar() !== EOL) {\n                this.next();\n                continue;\n            }\n            // Break if the first char in this line looks like an entry start.\n            const first = this.next();\n            if (this.isCharIdStart(first) || first === \"-\" || first === \"#\") {\n                break;\n            }\n        }\n    }\n    takeIDStart() {\n        if (this.isCharIdStart(this.currentChar())) {\n            const ret = this.currentChar();\n            this.next();\n            return ret;\n        }\n        throw new ParseError(\"E0004\", \"a-zA-Z\");\n    }\n    takeIDChar() {\n        const closure = (ch) => {\n            const cc = ch.charCodeAt(0);\n            return ((cc >= 97 && cc <= 122) || // a-z\n                (cc >= 65 && cc <= 90) || // A-Z\n                (cc >= 48 && cc <= 57) || // 0-9\n                cc === 95 || cc === 45); // _-\n        };\n        return this.takeChar(closure);\n    }\n    takeDigit() {\n        const closure = (ch) => {\n            const cc = ch.charCodeAt(0);\n            return (cc >= 48 && cc <= 57); // 0-9\n        };\n        return this.takeChar(closure);\n    }\n    takeHexDigit() {\n        const closure = (ch) => {\n            const cc = ch.charCodeAt(0);\n            return (cc >= 48 && cc <= 57) // 0-9\n                || (cc >= 65 && cc <= 70) // A-F\n                || (cc >= 97 && cc <= 102); // a-f\n        };\n        return this.takeChar(closure);\n    }\n}\n\n/*  eslint no-magic-numbers: [0]  */\nconst trailingWSRe = /[ \\t\\n\\r]+$/;\nfunction withSpan(fn) {\n    return function (ps, ...args) {\n        if (!this.withSpans) {\n            return fn.call(this, ps, ...args);\n        }\n        const start = ps.index;\n        const node = fn.call(this, ps, ...args);\n        // Don't re-add the span if the node already has it. This may happen when\n        // one decorated function calls another decorated function.\n        if (node.span) {\n            return node;\n        }\n        const end = ps.index;\n        node.addSpan(start, end);\n        return node;\n    };\n}\nclass FluentParser {\n    constructor({ withSpans = true } = {}) {\n        this.withSpans = withSpans;\n        // Poor man's decorators.\n        /* eslint-disable @typescript-eslint/unbound-method */\n        this.getComment = withSpan(this.getComment);\n        this.getMessage = withSpan(this.getMessage);\n        this.getTerm = withSpan(this.getTerm);\n        this.getAttribute = withSpan(this.getAttribute);\n        this.getIdentifier = withSpan(this.getIdentifier);\n        this.getVariant = withSpan(this.getVariant);\n        this.getNumber = withSpan(this.getNumber);\n        this.getPattern = withSpan(this.getPattern);\n        this.getTextElement = withSpan(this.getTextElement);\n        this.getPlaceable = withSpan(this.getPlaceable);\n        this.getExpression = withSpan(this.getExpression);\n        this.getInlineExpression = withSpan(this.getInlineExpression);\n        this.getCallArgument = withSpan(this.getCallArgument);\n        this.getCallArguments = withSpan(this.getCallArguments);\n        this.getString = withSpan(this.getString);\n        this.getLiteral = withSpan(this.getLiteral);\n        this.getComment = withSpan(this.getComment);\n        /* eslint-enable @typescript-eslint/unbound-method */\n    }\n    parse(source) {\n        const ps = new FluentParserStream(source);\n        ps.skipBlankBlock();\n        const entries = [];\n        let lastComment = null;\n        while (ps.currentChar()) {\n            const entry = this.getEntryOrJunk(ps);\n            const blankLines = ps.skipBlankBlock();\n            // Regular Comments require special logic. Comments may be attached to\n            // Messages or Terms if they are followed immediately by them. However\n            // they should parse as standalone when they're followed by Junk.\n            // Consequently, we only attach Comments once we know that the Message\n            // or the Term parsed successfully.\n            if (entry instanceof Comment\n                && blankLines.length === 0\n                && ps.currentChar()) {\n                // Stash the comment and decide what to do with it in the next pass.\n                lastComment = entry;\n                continue;\n            }\n            if (lastComment) {\n                if (entry instanceof Message || entry instanceof Term) {\n                    entry.comment = lastComment;\n                    if (this.withSpans) {\n                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                        entry.span.start = entry.comment.span.start;\n                    }\n                }\n                else {\n                    entries.push(lastComment);\n                }\n                // In either case, the stashed comment has been dealt with; clear it.\n                lastComment = null;\n            }\n            // No special logic for other types of entries.\n            entries.push(entry);\n        }\n        const res = new Resource(entries);\n        if (this.withSpans) {\n            res.addSpan(0, ps.index);\n        }\n        return res;\n    }\n    /*\n     * Parse the first Message or Term in `source`.\n     *\n     * Skip all encountered comments and start parsing at the first Message or\n     * Term start. Return Junk if the parsing is not successful.\n     *\n     * Preceding comments are ignored unless they contain syntax errors\n     * themselves, in which case Junk for the invalid comment is returned.\n     */\n    parseEntry(source) {\n        const ps = new FluentParserStream(source);\n        ps.skipBlankBlock();\n        while (ps.currentChar() === \"#\") {\n            const skipped = this.getEntryOrJunk(ps);\n            if (skipped instanceof Junk) {\n                // Don't skip Junk comments.\n                return skipped;\n            }\n            ps.skipBlankBlock();\n        }\n        return this.getEntryOrJunk(ps);\n    }\n    getEntryOrJunk(ps) {\n        const entryStartPos = ps.index;\n        try {\n            const entry = this.getEntry(ps);\n            ps.expectLineEnd();\n            return entry;\n        }\n        catch (err) {\n            if (!(err instanceof ParseError)) {\n                throw err;\n            }\n            let errorIndex = ps.index;\n            ps.skipToNextEntryStart(entryStartPos);\n            const nextEntryStart = ps.index;\n            if (nextEntryStart < errorIndex) {\n                // The position of the error must be inside of the Junk's span.\n                errorIndex = nextEntryStart;\n            }\n            // Create a Junk instance\n            const slice = ps.string.substring(entryStartPos, nextEntryStart);\n            const junk = new Junk(slice);\n            if (this.withSpans) {\n                junk.addSpan(entryStartPos, nextEntryStart);\n            }\n            const annot = new Annotation(err.code, err.args, err.message);\n            annot.addSpan(errorIndex, errorIndex);\n            junk.addAnnotation(annot);\n            return junk;\n        }\n    }\n    getEntry(ps) {\n        if (ps.currentChar() === \"#\") {\n            return this.getComment(ps);\n        }\n        if (ps.currentChar() === \"-\") {\n            return this.getTerm(ps);\n        }\n        if (ps.isIdentifierStart()) {\n            return this.getMessage(ps);\n        }\n        throw new ParseError(\"E0002\");\n    }\n    getComment(ps) {\n        // 0 - comment\n        // 1 - group comment\n        // 2 - resource comment\n        let level = -1;\n        let content = \"\";\n        while (true) {\n            let i = -1;\n            while (ps.currentChar() === \"#\" && (i < (level === -1 ? 2 : level))) {\n                ps.next();\n                i++;\n            }\n            if (level === -1) {\n                level = i;\n            }\n            if (ps.currentChar() !== EOL) {\n                ps.expectChar(\" \");\n                let ch;\n                while ((ch = ps.takeChar(x => x !== EOL))) {\n                    content += ch;\n                }\n            }\n            if (ps.isNextLineComment(level)) {\n                content += ps.currentChar();\n                ps.next();\n            }\n            else {\n                break;\n            }\n        }\n        let Comment$1;\n        switch (level) {\n            case 0:\n                Comment$1 = Comment;\n                break;\n            case 1:\n                Comment$1 = GroupComment;\n                break;\n            default:\n                Comment$1 = ResourceComment;\n        }\n        return new Comment$1(content);\n    }\n    getMessage(ps) {\n        const id = this.getIdentifier(ps);\n        ps.skipBlankInline();\n        ps.expectChar(\"=\");\n        const value = this.maybeGetPattern(ps);\n        const attrs = this.getAttributes(ps);\n        if (value === null && attrs.length === 0) {\n            throw new ParseError(\"E0005\", id.name);\n        }\n        return new Message(id, value, attrs);\n    }\n    getTerm(ps) {\n        ps.expectChar(\"-\");\n        const id = this.getIdentifier(ps);\n        ps.skipBlankInline();\n        ps.expectChar(\"=\");\n        const value = this.maybeGetPattern(ps);\n        if (value === null) {\n            throw new ParseError(\"E0006\", id.name);\n        }\n        const attrs = this.getAttributes(ps);\n        return new Term(id, value, attrs);\n    }\n    getAttribute(ps) {\n        ps.expectChar(\".\");\n        const key = this.getIdentifier(ps);\n        ps.skipBlankInline();\n        ps.expectChar(\"=\");\n        const value = this.maybeGetPattern(ps);\n        if (value === null) {\n            throw new ParseError(\"E0012\");\n        }\n        return new Attribute(key, value);\n    }\n    getAttributes(ps) {\n        const attrs = [];\n        ps.peekBlank();\n        while (ps.isAttributeStart()) {\n            ps.skipToPeek();\n            const attr = this.getAttribute(ps);\n            attrs.push(attr);\n            ps.peekBlank();\n        }\n        return attrs;\n    }\n    getIdentifier(ps) {\n        let name = ps.takeIDStart();\n        let ch;\n        while ((ch = ps.takeIDChar())) {\n            name += ch;\n        }\n        return new Identifier(name);\n    }\n    getVariantKey(ps) {\n        const ch = ps.currentChar();\n        if (ch === EOF) {\n            throw new ParseError(\"E0013\");\n        }\n        const cc = ch.charCodeAt(0);\n        if ((cc >= 48 && cc <= 57) || cc === 45) { // 0-9, -\n            return this.getNumber(ps);\n        }\n        return this.getIdentifier(ps);\n    }\n    getVariant(ps, hasDefault = false) {\n        let defaultIndex = false;\n        if (ps.currentChar() === \"*\") {\n            if (hasDefault) {\n                throw new ParseError(\"E0015\");\n            }\n            ps.next();\n            defaultIndex = true;\n        }\n        ps.expectChar(\"[\");\n        ps.skipBlank();\n        const key = this.getVariantKey(ps);\n        ps.skipBlank();\n        ps.expectChar(\"]\");\n        const value = this.maybeGetPattern(ps);\n        if (value === null) {\n            throw new ParseError(\"E0012\");\n        }\n        return new Variant(key, value, defaultIndex);\n    }\n    getVariants(ps) {\n        const variants = [];\n        let hasDefault = false;\n        ps.skipBlank();\n        while (ps.isVariantStart()) {\n            const variant = this.getVariant(ps, hasDefault);\n            if (variant.default) {\n                hasDefault = true;\n            }\n            variants.push(variant);\n            ps.expectLineEnd();\n            ps.skipBlank();\n        }\n        if (variants.length === 0) {\n            throw new ParseError(\"E0011\");\n        }\n        if (!hasDefault) {\n            throw new ParseError(\"E0010\");\n        }\n        return variants;\n    }\n    getDigits(ps) {\n        let num = \"\";\n        let ch;\n        while ((ch = ps.takeDigit())) {\n            num += ch;\n        }\n        if (num.length === 0) {\n            throw new ParseError(\"E0004\", \"0-9\");\n        }\n        return num;\n    }\n    getNumber(ps) {\n        let value = \"\";\n        if (ps.currentChar() === \"-\") {\n            ps.next();\n            value += `-${this.getDigits(ps)}`;\n        }\n        else {\n            value += this.getDigits(ps);\n        }\n        if (ps.currentChar() === \".\") {\n            ps.next();\n            value += `.${this.getDigits(ps)}`;\n        }\n        return new NumberLiteral(value);\n    }\n    // maybeGetPattern distinguishes between patterns which start on the same line\n    // as the identifier (a.k.a. inline signleline patterns and inline multiline\n    // patterns) and patterns which start on a new line (a.k.a. block multiline\n    // patterns). The distinction is important for the dedentation logic: the\n    // indent of the first line of a block pattern must be taken into account when\n    // calculating the maximum common indent.\n    maybeGetPattern(ps) {\n        ps.peekBlankInline();\n        if (ps.isValueStart()) {\n            ps.skipToPeek();\n            return this.getPattern(ps, false);\n        }\n        ps.peekBlankBlock();\n        if (ps.isValueContinuation()) {\n            ps.skipToPeek();\n            return this.getPattern(ps, true);\n        }\n        return null;\n    }\n    getPattern(ps, isBlock) {\n        const elements = [];\n        let commonIndentLength;\n        if (isBlock) {\n            // A block pattern is a pattern which starts on a new line. Store and\n            // measure the indent of this first line for the dedentation logic.\n            const blankStart = ps.index;\n            const firstIndent = ps.skipBlankInline();\n            elements.push(this.getIndent(ps, firstIndent, blankStart));\n            commonIndentLength = firstIndent.length;\n        }\n        else {\n            commonIndentLength = Infinity;\n        }\n        let ch;\n        elements: while ((ch = ps.currentChar())) {\n            switch (ch) {\n                case EOL: {\n                    const blankStart = ps.index;\n                    const blankLines = ps.peekBlankBlock();\n                    if (ps.isValueContinuation()) {\n                        ps.skipToPeek();\n                        const indent = ps.skipBlankInline();\n                        commonIndentLength = Math.min(commonIndentLength, indent.length);\n                        elements.push(this.getIndent(ps, blankLines + indent, blankStart));\n                        continue elements;\n                    }\n                    // The end condition for getPattern's while loop is a newline\n                    // which is not followed by a valid pattern continuation.\n                    ps.resetPeek();\n                    break elements;\n                }\n                case \"{\":\n                    elements.push(this.getPlaceable(ps));\n                    continue elements;\n                case \"}\":\n                    throw new ParseError(\"E0027\");\n                default:\n                    elements.push(this.getTextElement(ps));\n            }\n        }\n        const dedented = this.dedent(elements, commonIndentLength);\n        return new Pattern(dedented);\n    }\n    // Create a token representing an indent. It's not part of the AST and it will\n    // be trimmed and merged into adjacent TextElements, or turned into a new\n    // TextElement, if it's surrounded by two Placeables.\n    getIndent(ps, value, start) {\n        return new Indent(value, start, ps.index);\n    }\n    // Dedent a list of elements by removing the maximum common indent from the\n    // beginning of text lines. The common indent is calculated in getPattern.\n    dedent(elements, commonIndent) {\n        const trimmed = [];\n        for (let element of elements) {\n            if (element instanceof Placeable) {\n                trimmed.push(element);\n                continue;\n            }\n            if (element instanceof Indent) {\n                // Strip common indent.\n                element.value = element.value.slice(0, element.value.length - commonIndent);\n                if (element.value.length === 0) {\n                    continue;\n                }\n            }\n            let prev = trimmed[trimmed.length - 1];\n            if (prev && prev instanceof TextElement) {\n                // Join adjacent TextElements by replacing them with their sum.\n                const sum = new TextElement(prev.value + element.value);\n                if (this.withSpans) {\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    sum.addSpan(prev.span.start, element.span.end);\n                }\n                trimmed[trimmed.length - 1] = sum;\n                continue;\n            }\n            if (element instanceof Indent) {\n                // If the indent hasn't been merged into a preceding TextElement,\n                // convert it into a new TextElement.\n                const textElement = new TextElement(element.value);\n                if (this.withSpans) {\n                    textElement.addSpan(element.span.start, element.span.end);\n                }\n                element = textElement;\n            }\n            trimmed.push(element);\n        }\n        // Trim trailing whitespace from the Pattern.\n        const lastElement = trimmed[trimmed.length - 1];\n        if (lastElement instanceof TextElement) {\n            lastElement.value = lastElement.value.replace(trailingWSRe, \"\");\n            if (lastElement.value.length === 0) {\n                trimmed.pop();\n            }\n        }\n        return trimmed;\n    }\n    getTextElement(ps) {\n        let buffer = \"\";\n        let ch;\n        while ((ch = ps.currentChar())) {\n            if (ch === \"{\" || ch === \"}\") {\n                return new TextElement(buffer);\n            }\n            if (ch === EOL) {\n                return new TextElement(buffer);\n            }\n            buffer += ch;\n            ps.next();\n        }\n        return new TextElement(buffer);\n    }\n    getEscapeSequence(ps) {\n        const next = ps.currentChar();\n        switch (next) {\n            case \"\\\\\":\n            case \"\\\"\":\n                ps.next();\n                return `\\\\${next}`;\n            case \"u\":\n                return this.getUnicodeEscapeSequence(ps, next, 4);\n            case \"U\":\n                return this.getUnicodeEscapeSequence(ps, next, 6);\n            default:\n                throw new ParseError(\"E0025\", next);\n        }\n    }\n    getUnicodeEscapeSequence(ps, u, digits) {\n        ps.expectChar(u);\n        let sequence = \"\";\n        for (let i = 0; i < digits; i++) {\n            const ch = ps.takeHexDigit();\n            if (!ch) {\n                throw new ParseError(\"E0026\", `\\\\${u}${sequence}${ps.currentChar()}`);\n            }\n            sequence += ch;\n        }\n        return `\\\\${u}${sequence}`;\n    }\n    getPlaceable(ps) {\n        ps.expectChar(\"{\");\n        ps.skipBlank();\n        const expression = this.getExpression(ps);\n        ps.expectChar(\"}\");\n        return new Placeable(expression);\n    }\n    getExpression(ps) {\n        const selector = this.getInlineExpression(ps);\n        ps.skipBlank();\n        if (ps.currentChar() === \"-\") {\n            if (ps.peek() !== \">\") {\n                ps.resetPeek();\n                return selector;\n            }\n            // Validate selector expression according to\n            // abstract.js in the Fluent specification\n            if (selector instanceof MessageReference) {\n                if (selector.attribute === null) {\n                    throw new ParseError(\"E0016\");\n                }\n                else {\n                    throw new ParseError(\"E0018\");\n                }\n            }\n            else if (selector instanceof TermReference) {\n                if (selector.attribute === null) {\n                    throw new ParseError(\"E0017\");\n                }\n            }\n            else if (selector instanceof Placeable) {\n                throw new ParseError(\"E0029\");\n            }\n            ps.next();\n            ps.next();\n            ps.skipBlankInline();\n            ps.expectLineEnd();\n            const variants = this.getVariants(ps);\n            return new SelectExpression(selector, variants);\n        }\n        if (selector instanceof TermReference && selector.attribute !== null) {\n            throw new ParseError(\"E0019\");\n        }\n        return selector;\n    }\n    getInlineExpression(ps) {\n        if (ps.currentChar() === \"{\") {\n            return this.getPlaceable(ps);\n        }\n        if (ps.isNumberStart()) {\n            return this.getNumber(ps);\n        }\n        if (ps.currentChar() === '\"') {\n            return this.getString(ps);\n        }\n        if (ps.currentChar() === \"$\") {\n            ps.next();\n            const id = this.getIdentifier(ps);\n            return new VariableReference(id);\n        }\n        if (ps.currentChar() === \"-\") {\n            ps.next();\n            const id = this.getIdentifier(ps);\n            let attr;\n            if (ps.currentChar() === \".\") {\n                ps.next();\n                attr = this.getIdentifier(ps);\n            }\n            let args;\n            ps.peekBlank();\n            if (ps.currentPeek() === \"(\") {\n                ps.skipToPeek();\n                args = this.getCallArguments(ps);\n            }\n            return new TermReference(id, attr, args);\n        }\n        if (ps.isIdentifierStart()) {\n            const id = this.getIdentifier(ps);\n            ps.peekBlank();\n            if (ps.currentPeek() === \"(\") {\n                // It's a Function. Ensure it's all upper-case.\n                if (!/^[A-Z][A-Z0-9_-]*$/.test(id.name)) {\n                    throw new ParseError(\"E0008\");\n                }\n                ps.skipToPeek();\n                let args = this.getCallArguments(ps);\n                return new FunctionReference(id, args);\n            }\n            let attr;\n            if (ps.currentChar() === \".\") {\n                ps.next();\n                attr = this.getIdentifier(ps);\n            }\n            return new MessageReference(id, attr);\n        }\n        throw new ParseError(\"E0028\");\n    }\n    getCallArgument(ps) {\n        const exp = this.getInlineExpression(ps);\n        ps.skipBlank();\n        if (ps.currentChar() !== \":\") {\n            return exp;\n        }\n        if (exp instanceof MessageReference && exp.attribute === null) {\n            ps.next();\n            ps.skipBlank();\n            const value = this.getLiteral(ps);\n            return new NamedArgument(exp.id, value);\n        }\n        throw new ParseError(\"E0009\");\n    }\n    getCallArguments(ps) {\n        const positional = [];\n        const named = [];\n        const argumentNames = new Set();\n        ps.expectChar(\"(\");\n        ps.skipBlank();\n        while (true) {\n            if (ps.currentChar() === \")\") {\n                break;\n            }\n            const arg = this.getCallArgument(ps);\n            if (arg instanceof NamedArgument) {\n                if (argumentNames.has(arg.name.name)) {\n                    throw new ParseError(\"E0022\");\n                }\n                named.push(arg);\n                argumentNames.add(arg.name.name);\n            }\n            else if (argumentNames.size > 0) {\n                throw new ParseError(\"E0021\");\n            }\n            else {\n                positional.push(arg);\n            }\n            ps.skipBlank();\n            if (ps.currentChar() === \",\") {\n                ps.next();\n                ps.skipBlank();\n                continue;\n            }\n            break;\n        }\n        ps.expectChar(\")\");\n        return new CallArguments(positional, named);\n    }\n    getString(ps) {\n        ps.expectChar(\"\\\"\");\n        let value = \"\";\n        let ch;\n        while ((ch = ps.takeChar(x => x !== '\"' && x !== EOL))) {\n            if (ch === \"\\\\\") {\n                value += this.getEscapeSequence(ps);\n            }\n            else {\n                value += ch;\n            }\n        }\n        if (ps.currentChar() === EOL) {\n            throw new ParseError(\"E0020\");\n        }\n        ps.expectChar(\"\\\"\");\n        return new StringLiteral(value);\n    }\n    getLiteral(ps) {\n        if (ps.isNumberStart()) {\n            return this.getNumber(ps);\n        }\n        if (ps.currentChar() === '\"') {\n            return this.getString(ps);\n        }\n        throw new ParseError(\"E0014\");\n    }\n}\nclass Indent {\n    constructor(value, start, end) {\n        this.type = \"Indent\";\n        this.value = value;\n        this.span = new Span(start, end);\n    }\n}\n\nfunction parse(source, opts) {\n    const parser = new FluentParser(opts);\n    return parser.parse(source);\n}\n\nvar getTypeName = function getTypeName(item) {\n  return 'get' + item.type;\n};\n\nvar serializer = {\n  serialize: function serialize(item) {\n    if (this[getTypeName(item)]) {\n      return this[getTypeName(item)](item);\n    } else {\n      console.warn('unknown type:', item.type, item);\n    }\n  },\n  getComment: function getComment(item) {\n    return {\n      key: 'comment',\n      value: item.content\n    };\n  },\n  getGroupComment: function getGroupComment() {\n    return null;\n  },\n  getResourceComment: function getResourceComment() {\n    return null;\n  },\n  getMessage: function getMessage(item) {\n    var _this = this;\n\n    return {\n      key: this[getTypeName(item.id)](item.id),\n      value: this[getTypeName(item.value)](item.value),\n      comment: item.comment && this[getTypeName(item.comment)](item.comment),\n      attributes: item.attributes && item.attributes.map(function (attr) {\n        return _this.serialize(attr);\n      })\n    };\n  },\n  getAttribute: function getAttribute(item) {\n    return {\n      key: this[getTypeName(item.id)](item.id),\n      value: this[getTypeName(item.value)](item.value)\n    };\n  },\n  getTerm: function getTerm(item) {\n    var _this2 = this;\n\n    return {\n      key: \"-\".concat(this[getTypeName(item.id)](item.id)),\n      value: this[getTypeName(item.value)](item.value),\n      comment: item.comment && this[getTypeName(item.comment)](item.comment),\n      attributes: item.attributes && item.attributes.map(function (attr) {\n        return _this2.serialize(attr);\n      })\n    };\n  },\n  getIdentifier: function getIdentifier(item) {\n    return item.name;\n  },\n  getStringLiteral: function getStringLiteral(item) {\n    return item.value;\n  },\n  getPattern: function getPattern(item) {\n    var _this3 = this;\n\n    var items = item.elements.map(function (placeable) {\n      if (placeable.expression) {\n        if (!_this3[getTypeName(placeable.expression)]) {\n          return console.log('unknown1', getTypeName(placeable.expression), placeable.expression);\n        }\n\n        return _this3[getTypeName(placeable.expression)](placeable.expression);\n      } else {\n        if (!_this3[getTypeName(placeable)]) {\n          return console.log('unknown2', getTypeName(placeable), placeable);\n        }\n\n        return _this3[getTypeName(placeable)](placeable);\n      }\n    });\n    return items.join('');\n  },\n  getCallExpression: function getCallExpression(item) {\n    var _this4 = this;\n\n    var fcName = item.callee.name;\n    var positionals = item.positional.map(function (positional) {\n      return _this4[getTypeName(positional)](positional, true);\n    });\n    var nameds = item.named.map(function (named) {\n      return _this4[getTypeName(named)](named);\n    });\n    return '{ ' + fcName + '($' + positionals.join(' ') + (nameds.length ? ', ' + nameds.join(', ') : '') + ') }';\n  },\n  getNamedArgument: function getNamedArgument(item) {\n    return this[getTypeName(item.name)](item.name) + ': \"' + this[getTypeName(item.value)](item.value) + '\"';\n  },\n  getTextElement: function getTextElement(item) {\n    return item.value;\n  },\n  getSelectExpression: function getSelectExpression(item) {\n    var _this5 = this;\n\n    var id = this[getTypeName(item.selector)](item.selector, true);\n    var variants = item.variants.map(function (variant) {\n      return _this5[getTypeName(variant)](variant);\n    });\n    return '{ $' + id + ' ->\\n' + variants.join('\\n') + '\\n}';\n  },\n  getVariantExpression: function getVariantExpression(item) {\n    var ref = this[getTypeName(item.ref)](item.ref, true);\n    var key = this[getTypeName(item.key)](item.key);\n    if (key) return '{ ' + ref + '[' + key + '] }';\n    return ' { ' + ref + ' } ';\n  },\n  getVariableReference: function getVariableReference(item, plain) {\n    if (plain) return this[getTypeName(item.id)](item.id);\n    return '{ $' + this[getTypeName(item.id)](item.id) + ' }';\n  },\n  getTermReferences: function getTermReferences(item, plain) {\n    if (plain) return this[getTypeName(item.id)](item.id);\n    return '{ ' + this[getTypeName(item.id)](item.id) + ' }';\n  },\n  getVariantName: function getVariantName(item) {\n    return item.name;\n  },\n  getVariantList: function getVariantList(item) {\n    var _this6 = this;\n\n    var variants = item.variants.map(function (variant) {\n      return _this6[getTypeName(variant)](variant);\n    });\n    return '{\\n' + variants.join('\\n') + '\\n}';\n  },\n  getVariant: function getVariant(item) {\n    var name = item.key.name ? item.key.name : item.key.value;\n    var isDefault = item.default;\n    var pattern = this[getTypeName(item.value)](item.value);\n    var ret = '[' + name + '] ' + pattern;\n    if (isDefault) return ' *' + ret;\n    return '  ' + ret;\n  },\n  getFunctionReference: function getFunctionReference(item) {\n    var args = '';\n    item.arguments.positional.forEach(function (p, i) {\n      if (i > 0) args += ', ';\n      args += \"$\".concat(p.id.name);\n    });\n    item.arguments.named.forEach(function (n, i) {\n      if (i > 0 || args !== '') args += ', ';\n      args += \"\".concat(n.name.name, \": \\\"\").concat(n.value.value, \"\\\"\");\n    });\n    return \"{ \".concat(item.id.name, \"(\").concat(args, \") }\");\n  },\n  getTermReference: function getTermReference(item) {\n    return \"{ -\".concat(item.id.name, \" }\");\n  },\n  getJunk: function getJunk(item) {\n    var parts = item.content.split('=');\n    var key = parts.shift().trim();\n    var value = parts.join('=').trim().replace(/\\n {3}/g, '\\n ').replace(/\\n {2}}/g, '\\n}');\n    return {\n      key: key,\n      value: value\n    };\n  }\n};\n\nfunction ftlToJs(str, cb) {\n  var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    respectComments: true\n  };\n\n  if (typeof str !== 'string') {\n    if (!cb) throw new Error('The first parameter was not a string');\n    return cb(new Error('The first parameter was not a string'));\n  }\n\n  var parsed = parse(str, {\n    withSpans: false\n  });\n  var result = parsed.body.reduce(function (mem, segment) {\n    var item = serializer.serialize(segment);\n    if (!item) return mem;\n\n    if (item.attributes && item.attributes.length || item.comment && params.respectComments) {\n      var inner = {};\n      if (item.comment) inner[item.comment.key] = item.comment.value;\n\n      if (item.attributes && item.attributes.length) {\n        item.attributes.forEach(function (attr) {\n          inner[attr.key] = attr.value;\n        });\n      }\n\n      inner.val = item.value;\n      mem[item.key] = inner;\n    } else {\n      mem[item.key] = item.value;\n    }\n\n    return mem;\n  }, {});\n  if (cb) cb(null, result);\n  return result;\n}\n\nfunction addValue(k, value) {\n  var ftl = '';\n  ftl = ftl + k + ' =';\n\n  if (value && value.indexOf('\\n') > -1) {\n    ftl = ftl + '\\n  ';\n    ftl = ftl + value.split('\\n').join('\\n  ');\n  } else {\n    ftl = ftl + ' ' + value;\n  }\n\n  return ftl;\n}\n\nfunction addComment(comment) {\n  var ftl = '';\n  ftl = ftl + '# ' + comment.split('\\n').join('\\n# ');\n  ftl = ftl + '\\n';\n  return ftl;\n}\n\nfunction js2ftl(resources, cb) {\n  var ftl = '';\n  Object.keys(resources).forEach(function (k) {\n    var value = resources[k];\n\n    if (typeof value === 'string') {\n      ftl = ftl + addValue(k, value);\n      ftl = ftl + '\\n\\n';\n    } else {\n      if (value.comment) ftl = ftl + addComment(value.comment);\n      ftl = ftl + addValue(k, value.val);\n      Object.keys(value).forEach(function (innerK) {\n        if (innerK === 'comment' || innerK === 'val') return;\n        var innerValue = value[innerK];\n        ftl = ftl + addValue('\\n  .' + innerK, innerValue);\n      });\n      ftl = ftl + '\\n\\n';\n    }\n  });\n  if (cb) cb(null, ftl);\n  return ftl;\n}\n\nvar index = {\n  ftl2js: ftlToJs,\n  js2ftl: js2ftl\n};\n\nexport default index;\nexport { ftlToJs as ftl2js, js2ftl };\n","import getPrototypeOf from \"./getPrototypeOf.js\";\nimport isNativeReflectConstruct from \"./isNativeReflectConstruct.js\";\nimport possibleConstructorReturn from \"./possibleConstructorReturn.js\";\nexport default function _createSuper(Derived) {\n  var hasNativeReflectConstruct = isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return possibleConstructorReturn(this, result);\n  };\n}","export default function _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}","import setPrototypeOf from \"./setPrototypeOf.js\";\nimport isNativeReflectConstruct from \"./isNativeReflectConstruct.js\";\nexport default function _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    _construct = Reflect.construct.bind();\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n  return _construct.apply(null, arguments);\n}","import getPrototypeOf from \"./getPrototypeOf.js\";\nimport setPrototypeOf from \"./setPrototypeOf.js\";\nimport isNativeFunction from \"./isNativeFunction.js\";\nimport construct from \"./construct.js\";\nexport default function _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n      _cache.set(Class, Wrapper);\n    }\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  };\n  return _wrapNativeSuper(Class);\n}","export default function _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}"],"names":["BaseNode","this","type","other","ignoredFields","thisKeys","Set","Object","keys","otherKeys","fieldName","delete","size","has","thisVal","otherVal","Array","length","i","scalarsEqual","visit","value","clone","isArray","map","create","constructor","prototype","prop","equals","SyntaxNode","arguments","start","end","span","Span","Resource","body","Entry","Message","id","attributes","comment","Term","Pattern","elements","PatternElement","TextElement","Placeable","expression","Expression","Literal","StringLiteral","replace","match","codepoint4","codepoint6","codepoint","parseInt","String","fromCodePoint","NumberLiteral","parseFloat","decimalPos","indexOf","precision","MessageReference","attribute","TermReference","args","VariableReference","FunctionReference","SelectExpression","selector","variants","CallArguments","positional","named","Attribute","Variant","key","def","default","NamedArgument","name","Identifier","BaseComment","content","Comment","GroupComment","ResourceComment","Junk","annotations","annotation","push","Annotation","code","message","ParseError","getErrorMessage","Error","token","range","char","sequence","ParserStream","string","index","peekOffset","offset","charAt","EOL","EOF","undefined","SPECIAL_LINE_START_CHARS","FluentParserStream","currentPeek","peek","slice","blank","peekBlankInline","skipToPeek","lineStart","resetPeek","peekBlankBlock","peekBlank","ch","currentChar","next","f","cc","charCodeAt","isCharIdStart","isDigit","includes","column1","isCharPatternContinuation","level","currentPeekOffset","junkStart","lastNewline","lastIndexOf","first","ret","takeChar","trailingWSRe","withSpan","fn","ps","withSpans","call","node","addSpan","FluentParser","getComment","getMessage","getTerm","getAttribute","getIdentifier","getVariant","getNumber","getPattern","getTextElement","getPlaceable","getExpression","getInlineExpression","getCallArgument","getCallArguments","getString","getLiteral","source","skipBlankBlock","entries","lastComment","entry","getEntryOrJunk","blankLines","res","skipped","entryStartPos","getEntry","expectLineEnd","err","errorIndex","skipToNextEntryStart","nextEntryStart","substring","junk","annot","addAnnotation","isIdentifierStart","Comment$1","expectChar","x","isNextLineComment","skipBlankInline","maybeGetPattern","attrs","getAttributes","isAttributeStart","attr","takeIDStart","takeIDChar","hasDefault","defaultIndex","skipBlank","getVariantKey","isVariantStart","variant","num","takeDigit","getDigits","isValueStart","isValueContinuation","isBlock","commonIndentLength","blankStart","firstIndent","getIndent","Infinity","indent","Math","min","dedented","dedent","Indent","commonIndent","trimmed","element","prev","sum","textElement","lastElement","pop","buffer","getUnicodeEscapeSequence","u","digits","takeHexDigit","getVariants","isNumberStart","test","exp","argumentNames","arg","add","getEscapeSequence","parse","opts","getTypeName","item","serializer","serialize","console","warn","getGroupComment","getResourceComment","_this","_this2","concat","getStringLiteral","_this3","placeable","log","join","getCallExpression","_this4","fcName","callee","positionals","nameds","getNamedArgument","getSelectExpression","_this5","getVariantExpression","ref","getVariableReference","plain","getTermReferences","getVariantName","getVariantList","_this6","isDefault","getFunctionReference","forEach","p","n","getTermReference","getJunk","parts","split","shift","trim","ftlToJs","str","cb","params","respectComments","parsed","result","reduce","mem","segment","inner","val","addValue","k","ftl","js2ftl","resources","addComment","innerK","innerValue","ftl2js","_createSuper","Derived","hasNativeReflectConstruct","Super","NewTarget","Reflect","construct","apply","_isNativeReflectConstruct","sham","Proxy","Boolean","valueOf","e","_construct","Parent","Class","isNativeReflectConstruct","bind","a","instance","Function","setPrototypeOf","_wrapNativeSuper","_cache","Map","toString","TypeError","get","set","Wrapper","getPrototypeOf","enumerable","writable","configurable"],"sourceRoot":""}